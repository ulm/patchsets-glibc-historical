add x32 support; patch from https://github.com/hjl-tools/glibc

diff --git a/ChangeLog.backport b/ChangeLog.backport
new file mode 100644
index 0000000..9e2ce2b
--- /dev/null
+++ b/ChangeLog.backport
@@ -0,0 +1,33 @@
+2011-10-08  Roland McGrath  <roland@hack.frob.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/time.c: Move #include <dl-vdso.h>
+	inside [SHARED], where it is used.
+
+2011-09-06  Andreas Schwab  <schwab@redhat.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/gettimeofday.c [!SHARED]: Include
+	<errno.h>.
+
+2011-09-06  Ulrich Drepper  <drepper@gmail.com>
+
+	* sysdeps/unix/sysv/linux/kernel-features.h: Add entry for getcpu
+	syscall on x86-64.
+	* sysdeps/unix/sysv/linux/x86_64/gettimeofday.c [!SHARED]: Use real
+	syscall.
+	* sysdeps/unix/sysv/linux/x86_64/time.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S [!SHARED]: Use real
+	syscall if possible.
+
+2011-08-21  Ulrich Drepper  <drepper@gmail.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/gettimeofday.S: Removed.
+	* sysdeps/unix/sysv/linux/x86_64/time.S: Removed.
+	* sysdeps/unix/sysv/linux/x86_64/gettimeofday.c: New file.
+	* sysdeps/unix/sysv/linux/x86_64/time.c: New file.
+	* sysdeps/unix/sysv/linux/x86_64/bits/libc-vdso.h: Remove declaration
+	of __vdso_gettimeofday.
+	* sysdeps/unix/sysv/linux/x86_64/init-first.c: Remove definition of
+	__vdso_gettimeofday and __vdso_time.  Define __vdso_getcpu with
+	attribute_hidden.
+	(_libc_vdso_platform_setup): Remove initialization of
+	__vdso_gettimeofday and __vdso_time.
diff --git a/ChangeLog.x32 b/ChangeLog.x32
new file mode 100644
index 0000000..7a23b1b
--- /dev/null
+++ b/ChangeLog.x32
@@ -0,0 +1,568 @@
+2011-11-22  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/sysdep.h: Support 
+	!USE___THREAD.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR libc/12495
+	* malloc/malloc.c (sYSMALLOc): Don't update correction with
+	front_misalign.
+
+2007-11-30  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	PR libc/12495
+	* malloc/malloc.c (MALLOC_ALIGNMENT): Use __alignof__ (long double).
+	(SMALLBIN_CORRECTION): New.
+	(MIN_LARGE_SIZE, smallbin_index): Use it to handle 16-byte alignment.
+	(largebin_index_32_big): New.
+	(largebin_index): Use it for 16-byte alignment.
+	(sYSMALLOc): Handle MALLOC_ALIGNMENT > 2 * SIZE_SZ.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* stdio-common/_itoa.c (_itoa_base_table): Don't define if
+	PREFER_LONG_LONG is defined.
+	(_itoa): Use long long if PREFER_LONG_LONG is defined.
+	* stdio-common/_itowa.c (_itowa): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/x32/dl-machine.h: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/x32/Makefile: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/x32/divdi3.c: New.
+	* sysdeps/x86_64/x32/ffs.c: Likewise.
+	* sysdeps/x86_64/x32/gmp-mparam.h: Likewise.
+	* sysdeps/x86_64/x32/symbol-hacks.h: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/stackinfo.h (stackinfo_get_sp): Use RSP_LP.
+	(stackinfo_sub_sp): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf/tst-auditmod1.c: Support la_x32_gnu_pltenter and
+	la_x32_gnu_pltexit.
+	(pltexit): Cast int_retval to ptrdiff_t.
+	* elf/tst-auditmod3b.c: Likewise.
+	* elf/tst-auditmod4b.c: Likewise.
+	* elf/tst-auditmod5b.c: Likewise.
+	* elf/tst-auditmod6b.c: Likewise.
+	* elf/tst-auditmod6c.c: Likewise.
+	* elf/tst-auditmod7b.c: Likewise.
+
+	* sysdeps/generic/ldsodefs.h (audit_ifaces): Add x32_gnu_pltenter
+	and x32_gnu_pltexit.
+
+	* sysdeps/x86_64/bits/link.h: Check __x86_64__ instead of
+	__ELF_NATIVE_CLASS.
+	(la_x32_gnu_pltenter): New.
+	(la_x32_gnu_pltexit): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-machine.h: Replace Elf64_XXX with ElfW(XXX).
+	Replace ELF64_R_TYPE with ELF32_R_TYPE.
+	(elf_machine_load_address): Use ASM_ADDR.
+	(elf_machine_rela): Handle R_X86_64_RELATIVE64 for x32.  For x32,
+	sign extend relocation result to 64bit for R_X86_64_DTPOFF64
+	and R_X86_64_TPOFF64, and don't process R_X86_64_64.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-irel.h: Replace Elf64_XXX with ElfW(XXX).
+	Replace ELF64_R_TYPE with ELF32_R_TYPE.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-tls.h (dl_tls_index): Replace long with
+	long long.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-tlsdesc.h (tlsdesc): Pad for x32.
+	(dl_tls_index): Replace long with long long.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-trampoline.S: Check if RTLD_SAVESPACE_SSE
+	is 32byte aligned.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/fpu/bits/mathinline.h: Don't include
+	<bits/wordsize.h>.
+	(__signbitf): Check __x86_64__ instead of __WORDSIZE.
+	(__signbit): Likwise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/fpu/math_private.h (EXTRACT_WORDS64): Use
+	long long int instead of long int.
+	(INSERT_WORDS64): Likwise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/jmpbuf-unwind.h (_JMPBUF_CFA_UNWINDS_ADJ): Cast
+	_Unwind_GetCFA return to _Unwind_Ptr first.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/bits/mathdef.h: Don't include <bits/wordsize.h>.
+	Check __x86_64__ instead of __WORDSIZE.
+	* sysdeps/x86_64/bits/setjmp.h: Likewise.
+	* sysdeps/x86_64/fpu/bits/fenv.h: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/bits/byteswap.h: Don't include
+	<bits/wordsize.h>.
+	(__bswap_32): Check __x86_64__ instead of __WORDSIZE.  Also
+	check __corei7__.
+	(__bswap_64): Check __x86_64__ instead of __WORDSIZE.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/bits/atomic.h (__arch_compare_and_exchange_val_64_acq):
+	Use long long on 64bit integer.
+	(__arch_c_compare_and_exchange_val_64_acq): Likewise.
+	(atomic_exchange_acq): Likewise.
+	(__arch_exchange_and_add_body): Likewise.
+	(__arch_add_body): Likewise.
+	(atomic_add_negative): Likewise.
+	(atomic_add_zero): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/multiarch/strcmp.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/multiarch/memcpy-ssse3.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/multiarch/memcpy-ssse3-back.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/multiarch/memcmp-sse4.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* x86_64/dl-trampoline.h: Use R10_LP to load frame size.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/strcmp.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/memcpy.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/elf/start.S: Include <sysdep.h>.  Simulate
+	popping 4byte argument count for x32.  Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/__longjmp.S: Use RXX_LP.
+	* sysdeps/x86_64/setjmp.S: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/sysctl.c: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/sendfile64.c: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/pselect.c: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/syscalls.list: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/init-first.c: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/getdents.c: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/llseek.S: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/gettimeofday.c: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/time.c: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/preadv.c: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/pwritev.c: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/Makefile: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/getcpu.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu-static.c:
+	Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu.S: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/fallocate.c: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/posix_fadvise.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/posix_fallocate.c: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/alphasort.c: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/alphasort64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/fseeko.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/fseeko64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/ftello.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/ftello64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/ftw.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/ftw64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/glob.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofopen.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofopen64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/lockf.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/lockf64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/mkostemp.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/mkostemp64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/mkstemp.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/mkstemp64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/scandir.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/scandir64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/scandirat.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/scandirat64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/tmpfile.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/tmpfile64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/versionsort.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/versionsort64.c: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/dl-cache.h: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sigaction.c (RESTORE2): Replace
+	8byte data alignment with LP_SIZE alignment.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/clone.S: Load pointer to TID
+	into R10_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/Makefile (gen-as-const-headers):
+	Add sigaltstack.sym.
+
+	* sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S: Include
+	"sigaltstack.h".
+	(____longjmp_chk): Use RXX_LP, sizeSS, oSS_FLAGS, oSS_SP and
+	oSS_SIZE for alternate signal stack.
+
+	* sysdeps/unix/sysv/linux/x86_64/sigaltstack.sym: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/makecontext.c (__makecontext):
+	Use "unsigned long long int" instead of "unsigned long int".
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h: Include
+	<stdint.h>.
+	(GET_PC): Cast to uintptr_t first.
+	(GET_FRAME): Likewise.
+	(GET_STACK): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h: Don't include
+	<bits/wordsize.h>.  Check __x86_64__ instead of __WORDSIZE.
+	(DR_CONTROL_RESERVED): Use ULL instead of UL suffix.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/procfs.h (elf_greg_t): Use
+	"unsigned long long int" if __x86_64__ is defined.
+	Check __x86_64__ instead of __WORDSIZE.
+	(elf_prstatus): Use "unsigned long long int" instead of
+	"unsigned long int" if __x86_64__ is defined.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/reg.h: Don't
+	include <bits/wordsize.h>.  Check __x86_64__ instead of
+	__WORDSIZE.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h: Don't
+	include <bits/wordsize.h>.  Check __x86_64__ instead of
+	__WORDSIZE.
+	(greg_t): Use "long long int" if __x86_64__ is defined.
+	(mcontext_t): Replace "unsigned long" with "unsigned long long".
+	(ucontext_t): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/user.h: Don't
+	include <bits/wordsize.h>.  Check __x86_64__ instead of
+	__WORDSIZE.
+	(user_regs_struct): Use "unsigned long long" instead of
+	"unsigned long" if __x86_64__ is defined.
+	(user): Likewise.  Pad if __LP64__ isn't defined.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/msg.h: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed: Support x32.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/bits/wordsize.h: Moved to ...
+	* sysdeps/x86_64/64/bits/wordsize.h: Here.
+	(__WORDSIZE_COMPAT32): Removed.
+
+	* sysdeps/x86_64/x32/bits/wordsize.h: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/Implies: Moved to ...
+	* sysdeps/unix/sysv/linux/x86_64/64/Implies: Here. 
+
+	* sysdeps/x86_64/Implies: Moved to ...
+	* sysdeps/x86_64/64/Implies: Here.  Prepend x86_64/fpu.
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/Implies: New.
+	* sysdeps/x86_64/x32/Implies: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/a.out.h: Don't include
+	<bits/wordsize.h>.  Check __x86_64__ instead of __WORDSIZE.
+	* sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h: Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/msq.h: Don't include
+	<bits/wordsize.h>.
+	(msgqnum_t): Use __UNATIVE_LONG_TYPE.
+	(msglen_t): Likewise.
+	(msqid_ds): Check __x86_64__ instead of __WORDSIZE.  Use
+	__UNATIVE_LONG_TYPE.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/sem.h (semid_ds): Use
+	__UNATIVE_LONG_TYPE.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/shm.h (shmatt_t): Use
+	__UNATIVE_LONG_TYPE.
+	(shmid_ds): Add __unused1 and __unused2 only if __x86_64__ isn't
+	defined.  Use __UNATIVE_LONG_TYPE.
+	(shminfo): Use __UNATIVE_LONG_TYPE.
+	(shm_info): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h: Don't
+	include <bits/wordsize.h>.  Check __x86_64__ instead of
+	__WORDSIZE.
+	(sigcontext): Use "unsigned long long int" instead of
+	"unsigned long int" if __x86_64__ is defined.  Pad if __LP64__
+	isn't defined.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/stat.h (_STAT_VER_SVR4):
+	Check __x86_64__ instead of __WORDSIZE.
+	(_STAT_VER_LINUX): Likewise.
+	(stat): Check __x86_64__ instead of __WORDSIZE.  Use
+	__UNATIVE_LONG_TYPE.
+	(stat64): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/ipc.h: New.
+	* sysdeps/unix/sysv/linux/x86_64/bits/ipctypes.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/resource.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/statfs.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/statvfs.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/timex.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/utmp.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf/tls-macros.h (TLS_LE): Use mov instead of movq to load
+	thread pointer.
+	(TLS_IE): Use mov/add instead of movq/addq to load thread
+	pointer.
+	(TLS_GD_PREFIX): New.
+	(TLS_GD): Use it.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf/stackguard-macros.h (STACK_CHK_GUARD): Add x32 version.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf/cache.c (print_entry): Handle FLAG_X8664_LIBX32.
+
+	* sysdeps/generic/ldconfig.h (FLAG_X8664_LIBX32): New.
+
+	* sysdeps/unix/sysv/linux/i386/readelflib.c (process_elf_file):
+	Handle x32 libraries.
+	* sysdeps/unix/sysv/linux/x86_64/readelflib.c (process_elf_file):
+	Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/dl-cache.h (add_system_dir): New
+	Don't include <sysdeps/unix/sysv/linux/sparc/dl-cache.h>.
+
+	* sysdeps/unix/sysv/linux/x86_64/ldconfig.h
+	(SYSDEP_KNOWN_INTERPRETER_NAMES): Add /libx32/ld-linux-x32.so.2.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* stdlib/longlong.h (count_leading_zeros): Use long long builtin
+	for x86-64.
+	(count_trailing_zeros): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf/elf.h (R_X86_64_RELATIVE64): New.
+	(R_X86_64_NUM): Updated.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/ffsll.c: Add ffsl alias only if __LP64__ is
+	defined.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c: Moved to ...
+	* sysdeps/ieee754/dbl-64/wordsize-64/s_llround.c: This.  Updated.
+
+	* sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c: Empty file.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* time/mktime.c (ydhms_diff): Check TIME_T_MAX instead of
+	LONG_MAX.
+
+	* time/offtime.c (__offtime): Add more overflow check.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* bits/types.h (__snseconds_t): New.
+	* bits/typesizes.h (__SNSECONDS_T_TYPE): Likewise.
+	* sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h (__SNSECONDS_T_TYPE):
+	Likewise.
+	* sysdeps/unix/sysv/linux/s390/bits/typesizes.h (__SNSECONDS_T_TYPE):
+	Likewise.
+	* sysdeps/unix/sysv/linux/sparc/bits/typesizes.h (__SNSECONDS_T_TYPE):
+	Likewise.
+
+	* time/time.h (timespec): Use __snseconds_t on tv_nsec.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sysdep.h
+	(VSYSCALL_ADDR_vgettimeofday): New.
+	(VSYSCALL_ADDR_vtime): Likewise.
+	(VSYSCALL_ADDR_vgetcpu): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/gettimeofday.c
+	(VSYSCALL_ADDR_vgettimeofday): Removed.
+	* sysdeps/unix/sysv/linux/x86_64/init-first.c
+	(VSYSCALL_ADDR_vgetcpu): Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S
+	(VSYSCALL_ADDR_vgetcpu): Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/time.c (VSYSCALL_ADDR_vtime):
+	Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/sysdep.h: New.
+	* sysdeps/x86_64/x32/sysdep.h: Likewise.
+
+	* sysdeps/x86_64/sysdep.h (LP_SIZE): New.
+	(MOVE_LP): Likewise.
+	(ADD_LP): Likewise.
+	(SUB_LP): Likewise.
+	(CMP_LP): Likewise.
+	(ASM_ADDR): Likewise.
+	(RAX_LP): New.
+	(RBP_LP): Likewise.
+	(RBX_LP): Likewise.
+	(RCX_LP): Likewise.
+	(RDI_LP): Likewise.
+	(RSI_LP): Likewise.
+	(RSP_LP): Likewise.
+	(R8_LP): Likewise.
+	(R9_LP): Likewise.
+	(R10_LP): Likewise.
+	(R10_LP): Likewise.
+	(R11_LP): Likewise.
+	(R12_LP): Likewise.
+	(R13_LP): Likewise.
+	(R14_LP): Likewise.
+	(R15_LP): Likewise.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* shlib-versions: Move ld name for x86_64-.*-linux.* to ...
+	* sysdeps/x86_64/64/shlib-versions: Here.  New.
+
+	* sysdeps/x86_64/x32/shlib-versions: New.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makeconfig ($(common-objpfx)gnu/lib-names.stmp): Depend on
+	$(lib-names_awk) instead of scripts/lib-names.awk.
+
+	* Makefile ($(inst_includedir)/gnu/stubs.h): Depend on
+	$(stubs-biarch_h) instead of include/stubs-biarch.h.
+	(data-machine): New.
+	(check-data): Use it.
+
+	* config.make.in (data-machine): New.
+	(stubs-biarch_h): Likewise.
+	(lib-names_awk): Likewise.
+	(use-default-syscall-macros): Likewise.
+
+	* configure.in: Add sysdeps preconfigure fragment support.
+	(data_machine): Substitute.
+	(stubs_biarch_h): Set to include/stubs-biarch.h if not set.
+	Substitute.
+	(lib_names_awk): Set to scripts/lib-names.awk if not set.
+	Substitute.
+	(use_default_syscall_macros): Set to yes if not set.
+	Substitute.
+	* configure: Regenerated.
+
+	* scripts/data/c++-types-x32-linux-gnu.data: New.
+	* sysdeps/unix/sysv/linux/x86_64/stubs-triarch.h: Likewise.
+	* sysdeps/x86_64/lib-names.awk: Likewise.
+	* sysdeps/x86_64/preconfigure: Likewise.
+	* sysdeps/x86_64/stubs-biarch.h: Likewise.
+
+	* sysdeps/unix/sysv/linux/Makefile ($(objpfx)syscall-%.h
+	$(objpfx)syscall-%.d): Defined only if
+	$(use-default-syscall-macros) is set to yes.
+
+	* sysdeps/unix/sysv/linux/configure.in: Require kernel 2.6.35
+	or above for x32.  Check x86_64/x64 instead of x86_64.
+	* sysdeps/unix/sysv/linux/configure: Regenerated.
+
+	* sysdeps/x86_64/preconfigure (stubs_biarch_h): Set to
+	sysdeps/x86_64/stubs-biarch.h.
+
+	* sysdeps/unix/sysv/linux/x86_64/Makefile (64bit-predefine): Add
+	__LP64__.
+	($(objpfx)syscall-%.h $(objpfx)syscall-%.d): New.
diff --git a/Makeconfig b/Makeconfig
index b34cacf..ad6354b 100644
--- a/Makeconfig
+++ b/Makeconfig
@@ -885,7 +885,7 @@ postclean-generated += soversions.mk soversions.i \
 before-compile += $(common-objpfx)gnu/lib-names.h
 ifeq ($(soversions.mk-done),t)
 $(common-objpfx)gnu/lib-names.h: $(common-objpfx)gnu/lib-names.stmp; @:
-$(common-objpfx)gnu/lib-names.stmp: $(..)scripts/lib-names.awk \
+$(common-objpfx)gnu/lib-names.stmp: $(..)$(lib-names_awk) \
 				    $(common-objpfx)soversions.i
 	$(make-target-directory)
 	@rm -f ${@:stmp=T} $@
diff --git a/Makefile b/Makefile
index ea7a5b5..7c57213 100644
--- a/Makefile
+++ b/Makefile
@@ -178,7 +178,7 @@ installed-stubs = $(inst_includedir)/gnu/stubs.h
 else
 installed-stubs = $(inst_includedir)/gnu/stubs-$(biarch).h
 
-$(inst_includedir)/gnu/stubs.h: include/stubs-biarch.h $(+force)
+$(inst_includedir)/gnu/stubs.h: $(stubs-biarch_h) $(+force)
 	$(make-target-directory)
 	$(INSTALL_DATA) $< $@
 
@@ -260,13 +260,15 @@ tests-clean:
 
 tests: $(objpfx)c++-types-check.out $(objpfx)check-local-headers.out
 ifneq ($(CXX),no)
+ifeq ($(data-machine),)
+data-machine = $(config-machine) $(base-machine)
+endif
 check-data := $(firstword $(wildcard \
 		$(foreach D,$(add-ons) scripts,\
 			  $(patsubst %,$D/data/c++-types-%.data,\
 				     $(abi-name) \
 				     $(addsuffix -$(config-os),\
-						 $(config-machine) \
-						 $(base-machine))))))
+						 $(data-machine))))))
 ifneq (,$(check-data))
 $(objpfx)c++-types-check.out: $(check-data) scripts/check-c++-types.sh
 	scripts/check-c++-types.sh $< $(CXX) $(filter-out -std=gnu99 -Wstrict-prototypes,$(CFLAGS)) $(CPPFLAGS) > $@
diff --git a/bits/types.h b/bits/types.h
index 3ebe82f..d6915d7 100644
--- a/bits/types.h
+++ b/bits/types.h
@@ -149,6 +149,7 @@ __STD_TYPE __ID_T_TYPE __id_t;		/* General type for IDs.  */
 __STD_TYPE __TIME_T_TYPE __time_t;	/* Seconds since the Epoch.  */
 __STD_TYPE __USECONDS_T_TYPE __useconds_t; /* Count of microseconds.  */
 __STD_TYPE __SUSECONDS_T_TYPE __suseconds_t; /* Signed count of microseconds.  */
+__STD_TYPE __SNSECONDS_T_TYPE __snseconds_t; /* Signed count of nanoseconds.  */
 
 __STD_TYPE __DADDR_T_TYPE __daddr_t;	/* The type of a disk address.  */
 __STD_TYPE __SWBLK_T_TYPE __swblk_t;	/* Type of a swap block maybe?  */
diff --git a/bits/typesizes.h b/bits/typesizes.h
index e9226c4..63ef936 100644
--- a/bits/typesizes.h
+++ b/bits/typesizes.h
@@ -1,5 +1,6 @@
 /* bits/typesizes.h -- underlying types for *_t.  Generic version.
-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003, 2011
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -58,6 +59,7 @@
 #define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
 #define __FSID_T_TYPE		struct { int __val[2]; }
 #define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
 
 /* Number of descriptors that can fit in an `fd_set'.  */
 #define	__FD_SETSIZE		1024
diff --git a/config.make.in b/config.make.in
index d722a8b..3656be3 100644
--- a/config.make.in
+++ b/config.make.in
@@ -28,6 +28,7 @@ ldd-rewrite-script = @ldd_rewrite_script@
 # System configuration.
 config-machine = @host_cpu@
 base-machine = @base_machine@
+data-machine = @data_machine@
 config-vendor = @host_vendor@
 config-os = @host_os@
 config-sysdirs = @sysnames@
@@ -78,6 +79,10 @@ no-whole-archive = @no_whole_archive@
 exceptions = @exceptions@
 multi-arch = @multi_arch@
 
+stubs-biarch_h = @stubs_biarch_h@
+lib-names_awk = @lib_names_awk@
+use-default-syscall-macros = @use_default_syscall_macros@
+
 mach-interface-list = @mach_interface_list@
 
 have-bash2 = @libc_cv_have_bash2@
diff --git a/configure b/configure
index 6cf85e5..91a514d 100755
--- a/configure
+++ b/configure
@@ -599,6 +599,9 @@ ac_subst_vars='LTLIBOBJS
 LIBOBJS
 RELEASE
 VERSION
+use_default_syscall_macros
+lib_names_awk
+stubs_biarch_h
 mach_interface_list
 DEFINES
 nopic_initfini
@@ -679,6 +682,7 @@ sysdeps_add_ons
 sysnames
 submachine
 multi_arch
+data_machine
 base_machine
 add_on_subdirs
 add_ons
@@ -4106,6 +4110,17 @@ if test "$base_machine" = "i386"; then
 
 fi
 
+# Now run sysdeps preconfigure fragment.
+preconfigure=$srcdir/sysdeps/$base_machine/preconfigure
+if test -r $preconfigure; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: running preconfigure fragment for $base_machine" >&5
+$as_echo "running preconfigure fragment for $base_machine" >&6; }
+  . $preconfigure
+fi
+
+# sysdeps preconfigure fragment may set data_machine.
+
+
 # For the multi-arch option we need support in the assembler.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for assembler gnu_indirect_function symbol type support" >&5
 $as_echo_n "checking for assembler gnu_indirect_function symbol type support... " >&6; }
@@ -7732,6 +7747,21 @@ $as_echo "$libc_cv_pic_default" >&6; }
 
 
 
+if test -z "${stubs_biarch_h}"; then
+  stubs_biarch_h=include/stubs-biarch.h
+fi
+
+
+if test -z "${lib_names_awk}"; then
+  lib_names_awk=scripts/lib-names.awk
+fi
+
+
+if test -z "${use_default_syscall_macros}"; then
+  use_default_syscall_macros=yes
+fi
+
+
 if test "`(cd $srcdir; pwd)`" = "`pwd`"; then
   config_makefile=
 else
diff --git a/configure.in b/configure.in
index fbc64b9..3744d5c 100644
--- a/configure.in
+++ b/configure.in
@@ -600,6 +600,16 @@ if test "$base_machine" = "i386"; then
   AC_DEFINE(USE_REGPARMS)
 fi
 
+# Now run sysdeps preconfigure fragment.
+preconfigure=$srcdir/sysdeps/$base_machine/preconfigure
+if test -r $preconfigure; then
+  AC_MSG_RESULT(running preconfigure fragment for $base_machine)
+  . $preconfigure
+fi
+
+# sysdeps preconfigure fragment may set data_machine.
+AC_SUBST(data_machine)
+
 # For the multi-arch option we need support in the assembler.
 AC_CACHE_CHECK([for assembler gnu_indirect_function symbol type support],
 	       libc_cv_asm_gnu_indirect_function, [dnl
@@ -2266,6 +2276,21 @@ AC_SUBST(DEFINES)
 dnl See sysdeps/mach/configure.in for this variable.
 AC_SUBST(mach_interface_list)
 
+if test -z "${stubs_biarch_h}"; then
+  stubs_biarch_h=include/stubs-biarch.h
+fi
+AC_SUBST(stubs_biarch_h)
+
+if test -z "${lib_names_awk}"; then
+  lib_names_awk=scripts/lib-names.awk
+fi
+AC_SUBST(lib_names_awk)
+
+if test -z "${use_default_syscall_macros}"; then
+  use_default_syscall_macros=yes
+fi
+AC_SUBST(use_default_syscall_macros)
+
 if test "`(cd $srcdir; pwd)`" = "`pwd`"; then
   config_makefile=
 else
diff --git a/elf/cache.c b/elf/cache.c
index 0988593..8881ccc 100644
--- a/elf/cache.c
+++ b/elf/cache.c
@@ -91,6 +91,10 @@ print_entry (const char *lib, int flag, unsigned int osversion,
       break;
     case FLAG_MIPS64_LIBN64:
       fputs (",64bit", stdout);
+      break;
+    case FLAG_X8664_LIBX32:
+      fputs (",x32", stdout);
+      break;
     case 0:
       break;
     default:
diff --git a/elf/elf.h b/elf/elf.h
index ca5abbf..0f87b4e 100644
--- a/elf/elf.h
+++ b/elf/elf.h
@@ -2712,8 +2712,9 @@ typedef Elf32_Addr Elf32_Conflict;
 					   descriptor.  */
 #define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
 #define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
+#define R_X86_64_RELATIVE64	38	/* 64bit adjust by program base */
 
-#define R_X86_64_NUM		38
+#define R_X86_64_NUM		39
 
 
 /* AM33 relocations.  */
diff --git a/elf/stackguard-macros.h b/elf/stackguard-macros.h
index 97db8bc..8b85425 100644
--- a/elf/stackguard-macros.h
+++ b/elf/stackguard-macros.h
@@ -4,8 +4,13 @@
 # define STACK_CHK_GUARD \
   ({ uintptr_t x; asm ("movl %%gs:0x14, %0" : "=r" (x)); x; })
 #elif defined __x86_64__
-# define STACK_CHK_GUARD \
+# ifdef __LP64__
+#  define STACK_CHK_GUARD \
   ({ uintptr_t x; asm ("movq %%fs:0x28, %0" : "=r" (x)); x; })
+# else
+#  define STACK_CHK_GUARD \
+  ({ uintptr_t x; asm ("movl %%fs:0x18, %0" : "=r" (x)); x; })
+# endif
 #elif defined __powerpc64__
 # define STACK_CHK_GUARD \
   ({ uintptr_t x; asm ("ld %0,-28688(13)" : "=r" (x)); x; })
diff --git a/elf/tls-macros.h b/elf/tls-macros.h
index 781256d..947e2bb 100644
--- a/elf/tls-macros.h
+++ b/elf/tls-macros.h
@@ -101,15 +101,15 @@
 
 # define TLS_LE(x) \
   ({ int *__l;								      \
-     asm ("movq %%fs:0,%0\n\t"						      \
-	  "leaq " #x "@tpoff(%0), %0"					      \
+     asm ("mov %%fs:0,%0\n\t"						      \
+	  "lea " #x "@tpoff(%0), %0"					      \
 	  : "=r" (__l));						      \
      __l; })
 
 # define TLS_IE(x) \
   ({ int *__l;								      \
-     asm ("movq %%fs:0,%0\n\t"						      \
-	  "addq " #x "@gottpoff(%%rip),%0"				      \
+     asm ("mov %%fs:0,%0\n\t"						      \
+	  "add " #x "@gottpoff(%%rip),%0"				      \
 	  : "=r" (__l));						      \
      __l; })
 
@@ -122,9 +122,15 @@
 	  : : "rdi", "rsi", "r8", "r9", "r10", "r11"); 			      \
      __l; })
 
+# ifdef __LP64__
+#  define TLS_GD_PREFIX	".byte 0x66\n\t"
+# else
+#  define TLS_GD_PREFIX
+# endif
+
 # define TLS_GD(x) \
   ({ int *__l, __c, __d;						      \
-     asm (".byte 0x66\n\t"						      \
+     asm (TLS_GD_PREFIX							      \
 	  "leaq " #x "@tlsgd(%%rip),%%rdi\n\t"				      \
 	  ".word 0x6666\n\t"						      \
 	  "rex64\n\t"							      \
diff --git a/elf/tst-auditmod1.c b/elf/tst-auditmod1.c
index 2d39df2..15a8e34 100644
--- a/elf/tst-auditmod1.c
+++ b/elf/tst-auditmod1.c
@@ -109,8 +109,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
 # define La_retval La_i86_retval
 # define int_retval lrv_eax
 #elif defined __x86_64__
-# define pltenter la_x86_64_gnu_pltenter
-# define pltexit la_x86_64_gnu_pltexit
+# ifdef __LP64__
+#  define pltenter la_x86_64_gnu_pltenter
+#  define pltexit la_x86_64_gnu_pltexit
+# else
+#  define pltenter la_x32_gnu_pltenter
+#  define pltexit la_x32_gnu_pltexit
+# endif
 # define La_regs La_x86_64_regs
 # define La_retval La_x86_64_retval
 # define int_retval lrv_rax
@@ -194,7 +199,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
   return 0;
 }
diff --git a/elf/tst-auditmod3b.c b/elf/tst-auditmod3b.c
index 388ed6e..d1bb9b0 100644
--- a/elf/tst-auditmod3b.c
+++ b/elf/tst-auditmod3b.c
@@ -105,8 +105,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -140,7 +145,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
   __m128i xmm = _mm_set1_epi32 (-1);
   asm volatile ("movdqa %0, %%xmm0" : : "x" (xmm) : "xmm0" );
diff --git a/elf/tst-auditmod4b.c b/elf/tst-auditmod4b.c
index a6d3c6a..93f107f 100644
--- a/elf/tst-auditmod4b.c
+++ b/elf/tst-auditmod4b.c
@@ -94,8 +94,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -177,7 +182,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
 #ifdef __AVX__
   if (check_avx () && strcmp (symname, "audit_test") == 0)
diff --git a/elf/tst-auditmod5b.c b/elf/tst-auditmod5b.c
index 7e1e941..78fe838 100644
--- a/elf/tst-auditmod5b.c
+++ b/elf/tst-auditmod5b.c
@@ -95,8 +95,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -150,7 +155,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
   __m128i xmm;
 
diff --git a/elf/tst-auditmod6b.c b/elf/tst-auditmod6b.c
index f756b50..048dd7a 100644
--- a/elf/tst-auditmod6b.c
+++ b/elf/tst-auditmod6b.c
@@ -94,8 +94,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -179,7 +184,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
 #ifdef __AVX__
   if (check_avx () && strcmp (symname, "audit_test") == 0)
diff --git a/elf/tst-auditmod6c.c b/elf/tst-auditmod6c.c
index 49cbf05..81cbaa1 100644
--- a/elf/tst-auditmod6c.c
+++ b/elf/tst-auditmod6c.c
@@ -94,8 +94,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -185,7 +190,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
 #ifdef __AVX__
   if (check_avx () && strcmp (symname, "audit_test") == 0)
diff --git a/elf/tst-auditmod7b.c b/elf/tst-auditmod7b.c
index eb23758..91c4b7a 100644
--- a/elf/tst-auditmod7b.c
+++ b/elf/tst-auditmod7b.c
@@ -94,8 +94,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -177,7 +182,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
 #ifdef __AVX__
   if (check_avx () && strcmp (symname, "audit_test") == 0)
diff --git a/malloc/malloc.c b/malloc/malloc.c
index dccb6cc..66a0e09 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -2157,18 +2157,23 @@ typedef struct malloc_chunk* mbinptr;
 
     The bins top out around 1MB because we expect to service large
     requests via mmap.
+
+    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be
+    a valid chunk size the small bins are bumped up one.
 */
 
 #define NBINS             128
 #define NSMALLBINS         64
 #define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
-#define MIN_LARGE_SIZE    (NSMALLBINS * SMALLBIN_WIDTH)
+#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > 2 * SIZE_SZ)
+#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)
 
 #define in_smallbin_range(sz)  \
   ((unsigned long)(sz) < (unsigned long)MIN_LARGE_SIZE)
 
 #define smallbin_index(sz) \
-  (SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) >> 4) : (((unsigned)(sz)) >> 3))
+  ((SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) >> 4) : (((unsigned)(sz)) >> 3)) \
+   + SMALLBIN_CORRECTION)
 
 #define largebin_index_32(sz)                                                \
 (((((unsigned long)(sz)) >>  6) <= 38)?  56 + (((unsigned long)(sz)) >>  6): \
@@ -2178,6 +2183,14 @@ typedef struct malloc_chunk* mbinptr;
  ((((unsigned long)(sz)) >> 18) <=  2)? 124 + (((unsigned long)(sz)) >> 18): \
 					126)
 
+#define largebin_index_32_big(sz)                                            \
+(((((unsigned long)(sz)) >>  6) <= 45)?  49 + (((unsigned long)(sz)) >>  6): \
+ ((((unsigned long)(sz)) >>  9) <= 20)?  91 + (((unsigned long)(sz)) >>  9): \
+ ((((unsigned long)(sz)) >> 12) <= 10)? 110 + (((unsigned long)(sz)) >> 12): \
+ ((((unsigned long)(sz)) >> 15) <=  4)? 119 + (((unsigned long)(sz)) >> 15): \
+ ((((unsigned long)(sz)) >> 18) <=  2)? 124 + (((unsigned long)(sz)) >> 18): \
+                                        126)
+
 // XXX It remains to be seen whether it is good to keep the widths of
 // XXX the buckets the same or whether it should be scaled by a factor
 // XXX of two as well.
@@ -2190,7 +2203,9 @@ typedef struct malloc_chunk* mbinptr;
 					126)
 
 #define largebin_index(sz) \
-  (SIZE_SZ == 8 ? largebin_index_64 (sz) : largebin_index_32 (sz))
+  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \
+   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \
+   : largebin_index_32 (sz))
 
 #define bin_index(sz) \
  ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))
@@ -3010,14 +3025,14 @@ static Void_t* sYSMALLOc(nb, av) INTERNAL_SIZE_T nb; mstate av;
       Round up size to nearest page.  For mmapped chunks, the overhead
       is one SIZE_SZ unit larger than for normal chunks, because there
       is no following chunk whose prev_size field could be used.
+
+      See the front_misalign handling below, for glibc there is no
+      need for further alignments unless we have have high alignment.
     */
-#if 1
-    /* See the front_misalign handling below, for glibc there is no
-       need for further alignments.  */
-    size = (nb + SIZE_SZ + pagemask) & ~pagemask;
-#else
-    size = (nb + SIZE_SZ + MALLOC_ALIGN_MASK + pagemask) & ~pagemask;
-#endif
+    if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
+      size = (nb + SIZE_SZ + pagemask) & ~pagemask;
+    else
+      size = (nb + SIZE_SZ + MALLOC_ALIGN_MASK + pagemask) & ~pagemask;
     tried_mmap = true;
 
     /* Don't try if size wraps around 0 */
@@ -3035,13 +3050,16 @@ static Void_t* sYSMALLOc(nb, av) INTERNAL_SIZE_T nb; mstate av;
 	  address argument for later munmap in free() and realloc().
 	*/
 
-#if 1
-	/* For glibc, chunk2mem increases the address by 2*SIZE_SZ and
-	   MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap'ed area is page
-	   aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */
-	assert (((INTERNAL_SIZE_T)chunk2mem(mm) & MALLOC_ALIGN_MASK) == 0);
-#else
-	front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) & MALLOC_ALIGN_MASK;
+	if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
+	  {
+	    /* For glibc, chunk2mem increases the address by 2*SIZE_SZ and
+	       MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap'ed area is page
+	       aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */
+	    assert (((INTERNAL_SIZE_T)chunk2mem(mm) & MALLOC_ALIGN_MASK) == 0);
+	    front_misalign = 0;
+	  }
+	else
+	  front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) & MALLOC_ALIGN_MASK;
 	if (front_misalign > 0) {
 	  correction = MALLOC_ALIGNMENT - front_misalign;
 	  p = (mchunkptr)(mm + correction);
@@ -3049,7 +3067,6 @@ static Void_t* sYSMALLOc(nb, av) INTERNAL_SIZE_T nb; mstate av;
 	  set_head(p, (size - correction) |IS_MMAPPED);
 	}
 	else
-#endif
 	  {
 	    p = (mchunkptr)mm;
 	    set_head(p, size|IS_MMAPPED);
@@ -3346,8 +3363,24 @@ static Void_t* sYSMALLOc(nb, av) INTERNAL_SIZE_T nb; mstate av;
 
       /* handle non-contiguous cases */
       else {
-	/* MORECORE/mmap must correctly align */
-	assert(((unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK) == 0);
+	if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
+	  /* MORECORE/mmap must correctly align */
+	  assert(((unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK) == 0);
+	else {
+	  front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) & MALLOC_ALIGN_MASK;
+	  if (front_misalign > 0) {
+
+	    /*
+	      Skip over some bytes to arrive at an aligned position.
+	      We don't need to specially mark these wasted front bytes.
+	      They will never be accessed anyway because
+	      prev_inuse of av->top (and any chunk created from its start)
+	      is always true after initialization.
+	    */
+
+	    aligned_brk += MALLOC_ALIGNMENT - front_misalign;
+	  }
+	}
 
 	/* Find out current end of memory */
 	if (snd_brk == (char*)(MORECORE_FAILURE)) {
diff --git a/nptl/ChangeLog.backport b/nptl/ChangeLog.backport
new file mode 100644
index 0000000..dadb557
--- /dev/null
+++ b/nptl/ChangeLog.backport
@@ -0,0 +1,28 @@
+2011-10-29  Ulrich Drepper  <drepper@gmail.com>
+
+	[BZ #13358]
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
+	(__pthread_cond_timedwait): Initialize %r15 correctly also for code
+	path for kernels with FUTEX_CLOCK_REALTIME.
+	Debugged by H.J. Lu <hjl.tools@gmail.com>.
+
+2011-09-08  Ulrich Drepper  <drepper@gmail.com>
+
+	[BZ #12403]
+	* sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S
+	(pthread_rwlock_timedwrlock): Use correct macro in test.
+	Patch by H.J. Lu <hongjiu.lu@intel.com>.
+
+2011-09-06  Ulrich Drepper  <drepper@gmail.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S (sem_timedwait): Don't
+	use gettimeofday vsyscall, just call gettimeofday.
+	* sysdeps/unix/sysv/linux/x86_64/lowlevellock.S: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S:
+	Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S:
+	Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S: Likewise.
+	Simplify __vdso_clock_gettime use.
+
diff --git a/nptl/ChangeLog.x32 b/nptl/ChangeLog.x32
new file mode 100644
index 0000000..12cbb53
--- /dev/null
+++ b/nptl/ChangeLog.x32
@@ -0,0 +1,72 @@
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* pthread_create.c (start_thread): Check __PTHREAD_MUTEX_HAVE_PREV
+	instead of __WORDSIZE.
+
+	* sysdeps/pthread/pthread.h (PTHREAD_MUTEX_INITIALIZER): Check
+	__PTHREAD_MUTEX_HAVE_PREV instead of __WORDSIZE.
+	(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP): Likewise.
+	(PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP): Likewise.
+	(PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP): Likewise.
+	(__PTHREAD_RWLOCK_INT_FLAGS_SHARED): New.
+	(PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP): Check
+	__PTHREAD_RWLOCK_INT_FLAGS_SHARED instead of __WORDSIZE.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h: Define x32
+	__SIZEOF_PTHREAD_XXX_T.
+	(__pthread_internal_list): Check __x86_64__ instead of __WORDSIZE.
+	(pthread_mutex_t): Likewise.
+	(pthread_rwlock_t): Likewise. 
+	(__PTHREAD_RWLOCK_INT_FLAGS_SHARED): New.  Defined if __x86_64__
+	is defined.
+
+	* sysdeps/x86_64/tls.h: Don't include <bits/wordsize.h>.
+	Check __x86_64__ instead of __WORDSIZE.
+	(tcbhead_t): Pad rtld_savespace_sse to 32byte aligned.
+	(THREAD_SETMEM): Use long long on 64bit integer.
+	(THREAD_SETMEM_NC): Likewise.
+
+	* sysdeps/x86_64/x32/tls.h: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/pthreaddef.h (CURRENT_STACK_FRAME): Use
+	RSP_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/lowlevellock.h (__NR_futex): New.
+	(SYS_futex): Use it.
+	(LLL_STUB_UNWIND_INFO_START): Align label to LP_SIZE instead
+	of 8.
+	(LLL_STUB_UNWIND_INFO_END): Likewise.  Use RDX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* unwind.c (unwind_stop): Cast _Unwind_GetCFA return to
+	_Unwind_Ptr first.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/cancellation.S: Use MOVE_LP
+	and RDI_LP.
+
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S: Use
+	RXX_LP and CMP_LP.
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S: Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S: Use
+	 RXX_LP and CMP_LP.  Use LP_SIZE and ASM_ADDR on
+	 __gcc_personality_v0.
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S: Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/pthread_once.S: Use LP_SIZE
+	and ASM_ADDR.
+
+	* sysdeps/unix/sysv/linux/x86_64/sem_post.S: Use CMP_LP on
+	NWAITERS.
+
+	* sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S: Use ADD_LP
+	and SUB_LP on NWAITERS.  Use LP_SIZE and ASM_ADDR on
+	__gcc_personality_v0.
+	* sysdeps/unix/sysv/linux/x86_64/sem_wait.S: Likewise.
diff --git a/nptl/pthread_create.c b/nptl/pthread_create.c
index 34d83f9..174cec8 100644
--- a/nptl/pthread_create.c
+++ b/nptl/pthread_create.c
@@ -352,7 +352,7 @@ start_thread (void *arg)
 
 #ifndef __ASSUME_SET_ROBUST_LIST
   /* If this thread has any robust mutexes locked, handle them now.  */
-# if __WORDSIZE == 64
+# ifdef __PTHREAD_MUTEX_HAVE_PREV
   void *robust = pd->robust_head.list;
 # else
   __pthread_slist_t *robust = pd->robust_list.__next;
diff --git a/nptl/sysdeps/pthread/pthread.h b/nptl/sysdeps/pthread/pthread.h
index 4c83665..d2172da 100644
--- a/nptl/sysdeps/pthread/pthread.h
+++ b/nptl/sysdeps/pthread/pthread.h
@@ -85,7 +85,7 @@ enum
 
 
 /* Mutex initializers.  */
-#if __WORDSIZE == 64
+#ifdef __PTHREAD_MUTEX_HAVE_PREV
 # define PTHREAD_MUTEX_INITIALIZER \
   { { 0, 0, 0, 0, 0, 0, { 0, 0 } } }
 # ifdef __USE_GNU
@@ -120,11 +120,17 @@ enum
   PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
 };
 
+#ifndef __PTHREAD_RWLOCK_INT_FLAGS_SHARED
+# if __WORDSIZE == 64
+#  define __PTHREAD_RWLOCK_INT_FLAGS_SHARED 1
+# endif
+#endif
+
 /* Read-write lock initializers.  */
 # define PTHREAD_RWLOCK_INITIALIZER \
   { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
 # ifdef __USE_GNU
-#  if __WORDSIZE == 64
+#  ifdef __PTHREAD_RWLOCK_INT_FLAGS_SHARED
 #   define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \
   { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,					      \
 	PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP } }
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h b/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h
index 7a09c81..43e5119 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h
@@ -22,16 +22,28 @@
 
 #include <bits/wordsize.h>
 
-#if __WORDSIZE == 64
-# define __SIZEOF_PTHREAD_ATTR_T 56
-# define __SIZEOF_PTHREAD_MUTEX_T 40
-# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
-# define __SIZEOF_PTHREAD_COND_T 48
-# define __SIZEOF_PTHREAD_CONDATTR_T 4
-# define __SIZEOF_PTHREAD_RWLOCK_T 56
-# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
-# define __SIZEOF_PTHREAD_BARRIER_T 32
-# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#ifdef __x86_64__
+# if __WORDSIZE == 64
+#  define __SIZEOF_PTHREAD_ATTR_T 56
+#  define __SIZEOF_PTHREAD_MUTEX_T 40
+#  define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#  define __SIZEOF_PTHREAD_COND_T 48
+#  define __SIZEOF_PTHREAD_CONDATTR_T 4
+#  define __SIZEOF_PTHREAD_RWLOCK_T 56
+#  define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#  define __SIZEOF_PTHREAD_BARRIER_T 32
+#  define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+# else
+#  define __SIZEOF_PTHREAD_ATTR_T 32
+#  define __SIZEOF_PTHREAD_MUTEX_T 32
+#  define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#  define __SIZEOF_PTHREAD_COND_T 48
+#  define __SIZEOF_PTHREAD_CONDATTR_T 4
+#  define __SIZEOF_PTHREAD_RWLOCK_T 44
+#  define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#  define __SIZEOF_PTHREAD_BARRIER_T 20
+#  define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+# endif
 #else
 # define __SIZEOF_PTHREAD_ATTR_T 36
 # define __SIZEOF_PTHREAD_MUTEX_T 24
@@ -57,7 +69,7 @@ typedef union
 } pthread_attr_t;
 
 
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 typedef struct __pthread_internal_list
 {
   struct __pthread_internal_list *__prev;
@@ -80,13 +92,13 @@ typedef union
     int __lock;
     unsigned int __count;
     int __owner;
-#if __WORDSIZE == 64
+#ifdef __x86_64__
     unsigned int __nusers;
 #endif
     /* KIND must stay at this position in the structure to maintain
        binary compatibility.  */
     int __kind;
-#if __WORDSIZE == 64
+#ifdef __x86_64__
     int __spins;
     __pthread_list_t __list;
 # define __PTHREAD_MUTEX_HAVE_PREV	1
@@ -149,7 +161,7 @@ typedef int pthread_once_t;
    structure of the attribute type is not exposed on purpose.  */
 typedef union
 {
-# if __WORDSIZE == 64
+# ifdef __x86_64__
   struct
   {
     int __lock;
@@ -165,6 +177,7 @@ typedef union
     /* FLAGS must stay at this position in the structure to maintain
        binary compatibility.  */
     unsigned int __flags;
+# define __PTHREAD_RWLOCK_INT_FLAGS_SHARED	1
   } __data;
 # else
   struct
@@ -217,7 +230,7 @@ typedef union
 #endif
 
 
-#if __WORDSIZE == 32
+#ifndef __x86_64__
 /* Extra attributes for the cleanup functions.  */
 # define __cleanup_fct_attribute __attribute__ ((__regparm__ (1)))
 #endif
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S b/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S
index a06cd9b..fe33f69 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S
@@ -73,10 +73,10 @@ ENTRY(__pthread_enable_asynccancel)
 
 3:	subq	$8, %rsp
 	cfi_adjust_cfa_offset(8)
-	movq	$TCB_PTHREAD_CANCELED, %fs:RESULT
+	MOVE_LP	$TCB_PTHREAD_CANCELED, %fs:RESULT
 	lock
 	orl	$TCB_EXITING_BITMASK, %fs:CANCELHANDLING
-	movq	%fs:CLEANUP_JMP_BUF, %rdi
+	mov	%fs:CLEANUP_JMP_BUF, %RDI_LP
 #ifdef SHARED
 	call	__pthread_unwind@PLT
 #else
@@ -107,7 +107,7 @@ ENTRY(__pthread_disable_asynccancel)
 	/* Performance doesn't matter in this loop.  We will
 	   delay until the thread is canceled.  And we will unlikely
 	   enter the loop twice.  */
-4:	movq	%fs:0, %rdi
+4:	mov	%fs:0, %RDI_LP
 	movl	$__NR_futex, %eax
 	xorq	%r10, %r10
 	addq	$CANCELHANDLING, %rdi
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S
index 3195db2..018da0c 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.S
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002-2006, 2007, 2009, 2010 Free Software Foundation, Inc.
+/* Copyright (C) 2002-2007, 2009, 2010, 2011 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -68,10 +68,6 @@
 #endif
 
 
-/* For the calculation see asm/vsyscall.h.  */
-#define VSYSCALL_ADDR_vgettimeofday	0xffffffffff600000
-
-
 	.globl	__lll_lock_wait_private
 	.type	__lll_lock_wait_private,@function
 	.hidden	__lll_lock_wait_private
@@ -250,10 +246,9 @@ __lll_timedlock_wait:
 	/* Get current time.  */
 	movq	%rsp, %rdi
 	xorl	%esi, %esi
-	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
-	/* This is a regular function call, all caller-save registers
-	   might be clobbered.  */
-	callq	*%rax
+	/* This call works because we directly jump to a system call entry
+	   which preserves all the registers.  */
+	call	JUMPTARGET(__gettimeofday)
 
 	/* Compute relative timeout.  */
 	movq	8(%rsp), %rax
@@ -402,8 +397,9 @@ __lll_timedwait_tid:
 	/* Get current time.  */
 2:	movq	%rsp, %rdi
 	xorl	%esi, %esi
-	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
-	callq	*%rax
+	/* This call works because we directly jump to a system call entry
+	   which preserves all the registers.  */
+	call	JUMPTARGET(__gettimeofday)
 
 	/* Compute relative timeout.  */
 	movq	8(%rsp), %rax
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
index 9b15bfb..023a675 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
@@ -44,7 +44,11 @@
 # endif
 #endif
 
-#define SYS_futex		202
+#ifndef __NR_futex
+# define __NR_futex		202
+#endif
+
+#define SYS_futex		__NR_futex
 #define FUTEX_WAIT		0
 #define FUTEX_WAKE		1
 #define FUTEX_CMP_REQUEUE	4
@@ -120,7 +124,7 @@
 	".byte	0x12	# DW_CFA_def_cfa_sf\n\t" 		\
 	".uleb128 0x7\n\t" 					\
 	".sleb128 16\n\t" 					\
-	".align 8\n" 						\
+	".align " LP_SIZE "\n" 					\
 "9:\t"	".long	23f-10f	# FDE Length\n" 			\
 "10:\t"	".long	10b-7b	# FDE CIE offset\n\t" 			\
 	".long	1b-.	# FDE initial location\n\t" 		\
@@ -167,7 +171,7 @@
 	".uleb128 22f-21f\n" 					\
 "21:\t"	".byte	0x80	# DW_OP_breg16\n\t" 			\
 	".sleb128 4b-5b\n" 					\
-"22:\t"	".align 8\n" 						\
+"22:\t"	".align " LP_SIZE "\n" 					\
 "23:\t"	".previous\n"
 
 /* Unwind info for
@@ -408,7 +412,7 @@ LLL_STUB_UNWIND_INFO_END
 		       ".type _L_timedlock_%=, @function\n"		      \
 		       "_L_timedlock_%=:\n"				      \
 		       "1:\tleaq %4, %%rdi\n"				      \
-		       "0:\tmovq %8, %%rdx\n"				      \
+		       "0:\tmov %8, %%" RDX_LP "\n"			      \
 		       "2:\tsubq $128, %%rsp\n"				      \
 		       "3:\tcallq __lll_timedlock_wait\n"		      \
 		       "4:\taddq $128, %%rsp\n"				      \
@@ -432,7 +436,7 @@ LLL_STUB_UNWIND_INFO_END
 		       ".type _L_robust_timedlock_%=, @function\n"	      \
 		       "_L_robust_timedlock_%=:\n"			      \
 		       "1:\tleaq %4, %%rdi\n"				      \
-		       "0:\tmovq %8, %%rdx\n"				      \
+		       "0:\tmov %8, %%" RDX_LP "\n"			      \
 		       "2:\tsubq $128, %%rsp\n"				      \
 		       "3:\tcallq __lll_robust_timedlock_wait\n"	      \
 		       "4:\taddq $128, %%rsp\n"				      \
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S
index 5218a4f..b7b8b34 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevelrobustlock.S
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002=2007, 2009, 2010 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2011=2007, 2009, 2010 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -50,9 +50,6 @@
 	orl	$FUTEX_WAIT_BITSET | FUTEX_CLOCK_REALTIME, reg
 #endif
 
-/* For the calculation see asm/vsyscall.h.  */
-#define VSYSCALL_ADDR_vgettimeofday	0xffffffffff600000
-
 
 	.globl	__lll_robust_lock_wait
 	.type	__lll_robust_lock_wait,@function
@@ -219,10 +216,9 @@ __lll_robust_timedlock_wait:
 	/* Get current time.  */
 	movq	%rsp, %rdi
 	xorl	%esi, %esi
-	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
-	/* This is a regular function call, all caller-save registers
-	   might be clobbered.  */
-	callq	*%rax
+	/* This call works because we directly jump to a system call entry
+	   which preserves all the registers.  */
+	call	JUMPTARGET(__gettimeofday)
 
 	/* Compute relative timeout.  */
 	movq	8(%rsp), %rax
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S
index 224a560..5c89c04 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S
@@ -60,14 +60,14 @@ __pthread_cond_broadcast:
 	incl	broadcast_seq-cond_futex(%rdi)
 
 	/* Get the address of the mutex used.  */
-	movq	dep_mutex-cond_futex(%rdi), %r8
+	mov	dep_mutex-cond_futex(%rdi), %R8_LP
 
 	/* Unlock.  */
 	LOCK
 	decl	cond_lock-cond_futex(%rdi)
 	jne	7f
 
-8:	cmpq	$-1, %r8
+8:	CMP_LP	$-1, %R8_LP
 	je	9f
 
 	/* Do not use requeue for pshared condvars.  */
@@ -129,7 +129,7 @@ __pthread_cond_broadcast:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -141,7 +141,7 @@ __pthread_cond_broadcast:
 
 	/* Unlock in loop requires wakeup.  */
 5:	addq	$cond_lock-cond_futex, %rdi
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -150,7 +150,7 @@ __pthread_cond_broadcast:
 
 	/* Unlock in loop requires wakeup.  */
 7:	addq	$cond_lock-cond_futex, %rdi
-	cmpq	$-1, %r8
+	CMP_LP	$-1, %R8_LP
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -159,7 +159,7 @@ __pthread_cond_broadcast:
 	jmp	8b
 
 9:	/* The futex requeue functionality is not available.  */
-	cmpq	$-1, %r8
+	CMP_LP	$-1, %R8_LP
 	movl	$0x7fffffff, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAKE, %eax
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
index d1d83a8..9f05d28 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
@@ -56,14 +56,14 @@ __pthread_cond_signal:
 	addl	$1, (%rdi)
 
 	/* Wake up one thread.  */
-	cmpq	$-1, dep_mutex(%r8)
+	CMP_LP	$-1, dep_mutex(%r8)
 	movl	$FUTEX_WAKE_OP, %esi
 	movl	$1, %edx
 	movl	$SYS_futex, %eax
 	je	8f
 
 	/* Get the address of the mutex used.  */
-	movq    dep_mutex(%r8), %rcx
+	mov     dep_mutex(%r8), %RCX_LP
 	movl	MUTEX_KIND(%rcx), %r11d
 	andl	$(ROBUST_BIT|PI_BIT), %r11d
 	cmpl	$PI_BIT, %r11d
@@ -135,7 +135,7 @@ __pthread_cond_signal:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -151,7 +151,7 @@ __pthread_cond_signal:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
index 48ea8b9..048d0ce 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002-2005, 2007, 2009, 2010, 2011 Free Software Foundation, Inc.
+/* Copyright (C) 2002-2005,2007,2009,2010,2011 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -26,9 +26,6 @@
 
 #include <kernel-features.h>
 
-/* For the calculation see asm/vsyscall.h.  */
-#define VSYSCALL_ADDR_vgettimeofday	0xffffffffff600000
-
 
 	.text
 
@@ -93,7 +90,7 @@ __pthread_cond_timedwait:
 		    +--------------------------+
 	*/
 
-	cmpq	$-1, dep_mutex(%rdi)
+	CMP_LP	$-1, dep_mutex(%rdi)
 
 	/* Prepare structure passed to cancellation handler.  */
 	movq	%rdi, 8(%rsp)
@@ -101,9 +98,11 @@ __pthread_cond_timedwait:
 	movq	%rdx, %r13
 
 	je	22f
-	movq	%rsi, dep_mutex(%rdi)
+	mov	%RSI_LP, dep_mutex(%rdi)
 
 22:
+	xorl	%r15d, %r15d
+
 #ifndef __ASSUME_FUTEX_CLOCK_REALTIME
 #  ifdef PIC
 	cmpl	$0, __have_futex_clock_realtime(%rip)
@@ -165,10 +164,10 @@ __pthread_cond_timedwait:
 
 	movq	%r13, %r10
 	movl	$FUTEX_WAIT_BITSET, %esi
-	cmpq	$-1, dep_mutex(%rdi)
+	CMP_LP	$-1, dep_mutex(%rdi)
 	je	60f
 
-	movq	dep_mutex(%rdi), %r8
+	mov	dep_mutex(%rdi), %R8_LP
 	/* Requeue to a non-robust PI mutex if the PI bit is set and
 	the robust bit is not set.  */
 	movl	MUTEX_KIND(%r8), %eax
@@ -270,7 +269,7 @@ __pthread_cond_timedwait:
 	jne	55f
 
 	addq	$cond_nwaiters, %rdi
-	cmpq	$-1, dep_mutex-cond_nwaiters(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_nwaiters(%rdi)
 	movl	$1, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAKE, %eax
@@ -333,7 +332,7 @@ __pthread_cond_timedwait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -345,7 +344,7 @@ __pthread_cond_timedwait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -357,7 +356,7 @@ __pthread_cond_timedwait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -372,7 +371,7 @@ __pthread_cond_timedwait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -393,7 +392,7 @@ __pthread_cond_timedwait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -405,8 +404,6 @@ __pthread_cond_timedwait:
 
 #ifndef __ASSUME_FUTEX_CLOCK_REALTIME
 .Lreltmo:
-	xorl	%r15d, %r15d
-
 	/* Get internal lock.  */
 	movl	$1, %esi
 	xorl	%eax, %eax
@@ -450,16 +447,14 @@ __pthread_cond_timedwait:
 	   kernel.  */
 	leaq	32(%rsp), %rsi
 #  ifdef SHARED
-	movq	__vdso_clock_gettime@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	PTR_DEMANGLE (%rax)
-	jz	26f
+	mov	__vdso_clock_gettime@GOTPCREL(%rip), %RAX_LP
+	mov	(%rax), %RAX_LP
+	PTR_DEMANGLE (%RAX_LP)
 	call	*%rax
-	jmp	27f
-#  endif
-26:	movl	$__NR_clock_gettime, %eax
+#  else
+	movl	$__NR_clock_gettime, %eax
 	syscall
-27:
+#  endif
 #  ifndef __ASSUME_POSIX_TIMERS
 	cmpq	$-ENOSYS, %rax
 	je	19f
@@ -473,8 +468,9 @@ __pthread_cond_timedwait:
 # else
 	leaq	24(%rsp), %rdi
 	xorl	%esi, %esi
-	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
-	callq	*%rax
+	/* This call works because we directly jump to a system call entry
+	   which preserves all the registers.  */
+	call	JUMPTARGET(__gettimeofday)
 
 	/* Compute relative timeout.  */
 	movq	40(%rsp), %rax
@@ -513,7 +509,7 @@ __pthread_cond_timedwait:
 	movl	%eax, (%rsp)
 
 	leaq	32(%rsp), %r10
-	cmpq	$-1, dep_mutex(%rdi)
+	CMP_LP	$-1, dep_mutex(%rdi)
 	movq	%r12, %rdx
 # ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAIT, %eax
@@ -573,7 +569,7 @@ __pthread_cond_timedwait:
 # if cond_lock != 0
 	addq	$cond_lock, %rdi
 # endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -585,7 +581,7 @@ __pthread_cond_timedwait:
 # if cond_lock != 0
 	addq	$cond_lock, %rdi
 # endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -597,7 +593,7 @@ __pthread_cond_timedwait:
 # if cond_lock != 0
 	addq	$cond_lock, %rdi
 # endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -611,8 +607,9 @@ __pthread_cond_timedwait:
 	/* clock_gettime not available.  */
 19:	leaq	32(%rsp), %rdi
 	xorl	%esi, %esi
-	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
-	callq	*%rax
+	/* This call works because we directly jump to a system call entry
+	   which preserves all the registers.  */
+	call	JUMPTARGET(__gettimeofday)
 
 	/* Compute relative timeout.  */
 	movq	40(%rsp), %rax
@@ -679,7 +676,7 @@ __condvar_cleanup2:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -712,7 +709,7 @@ __condvar_cleanup2:
 	andl	$~((1 << nwaiters_shift) - 1), %eax
 	jne	4f
 
-	cmpq	$-1, dep_mutex(%rdi)
+	CMP_LP	$-1, dep_mutex(%rdi)
 	leaq	cond_nwaiters(%rdi), %rdi
 	movl	$1, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
@@ -740,7 +737,7 @@ __condvar_cleanup2:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -750,7 +747,7 @@ __condvar_cleanup2:
 2:	testq	%r12, %r12
 	jnz	5f
 	addq	$cond_futex, %rdi
-	cmpq	$-1, dep_mutex-cond_futex(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_futex(%rdi)
 	movl	$0x7fffffff, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAKE, %eax
@@ -809,9 +806,9 @@ __condvar_cleanup2:
 	.hidden	DW.ref.__gcc_personality_v0
 	.weak	DW.ref.__gcc_personality_v0
 	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	8
+	.align	LP_SIZE
 	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, 8
+	.size	DW.ref.__gcc_personality_v0, LP_SIZE
 DW.ref.__gcc_personality_v0:
-	.quad	__gcc_personality_v0
+	ASM_ADDR __gcc_personality_v0
 #endif
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
index 7535baa..275e045 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
@@ -65,14 +65,14 @@ __pthread_cond_wait:
 	            +--------------------------+
 	*/
 
-	cmpq	$-1, dep_mutex(%rdi)
+	CMP_LP	$-1, dep_mutex(%rdi)
 
 		/* Prepare structure passed to cancellation handler.  */
 	movq	%rdi, 8(%rsp)
 	movq	%rsi, 16(%rsp)
 
 	je	15f
-	movq	%rsi, dep_mutex(%rdi)
+	mov	%RSI_LP, dep_mutex(%rdi)
 
 	/* Get internal lock.  */
 15:	movl	$1, %esi
@@ -120,12 +120,12 @@ __pthread_cond_wait:
 	movl	%eax, (%rsp)
 
 	xorq	%r10, %r10
-	cmpq	$-1, dep_mutex(%rdi)
+	CMP_LP	$-1, dep_mutex(%rdi)
 	leaq	cond_futex(%rdi), %rdi
 	movl	$FUTEX_WAIT, %esi
 	je	60f
 
-	movq	dep_mutex-cond_futex(%rdi), %r8
+	mov	dep_mutex-cond_futex(%rdi), %R8_LP
 	/* Requeue to a non-robust PI mutex if the PI bit is set and
 	the robust bit is not set.  */
 	movl	MUTEX_KIND(%r8), %eax
@@ -203,7 +203,7 @@ __pthread_cond_wait:
 	jne	17f
 
 	addq	$cond_nwaiters, %rdi
-	cmpq	$-1, dep_mutex-cond_nwaiters(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_nwaiters(%rdi)
 	movl	$1, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAKE, %eax
@@ -252,7 +252,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -264,7 +264,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -280,7 +280,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -295,7 +295,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -316,7 +316,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -367,7 +367,7 @@ __condvar_cleanup1:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -400,7 +400,7 @@ __condvar_cleanup1:
 	andl	$~((1 << nwaiters_shift) - 1), %eax
 	jne	4f
 
-	cmpq	$-1, dep_mutex(%rdi)
+	CMP_LP	$-1, dep_mutex(%rdi)
 	leaq	cond_nwaiters(%rdi), %rdi
 	movl	$1, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
@@ -428,7 +428,7 @@ __condvar_cleanup1:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -439,7 +439,7 @@ __condvar_cleanup1:
 2:	testl	%ecx, %ecx
 	jnz	5f
 	addq	$cond_futex, %rdi
-	cmpq	$-1, dep_mutex-cond_futex(%rdi)
+	CMP_LP	$-1, dep_mutex-cond_futex(%rdi)
 	movl	$0x7fffffff, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAKE, %eax
@@ -488,9 +488,9 @@ __condvar_cleanup1:
 	.hidden	DW.ref.__gcc_personality_v0
 	.weak	DW.ref.__gcc_personality_v0
 	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	8
+	.align	LP_SIZE
 	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, 8
+	.size	DW.ref.__gcc_personality_v0, LP_SIZE
 DW.ref.__gcc_personality_v0:
-	.quad	__gcc_personality_v0
+	ASM_ADDR __gcc_personality_v0
 #endif
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
index ccc1849..4b28743 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
@@ -189,9 +189,9 @@ clear_once_control:
 	.hidden	DW.ref.__gcc_personality_v0
 	.weak	DW.ref.__gcc_personality_v0
 	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	8
+	.align	LP_SIZE
 	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, 8
+	.size	DW.ref.__gcc_personality_v0, LP_SIZE
 DW.ref.__gcc_personality_v0:
-	.quad	__gcc_personality_v0
+	ASM_ADDR __gcc_personality_v0
 #endif
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S
index f5d055c..0e6a6ee 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedrdlock.S
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002-2005, 2007, 2009, 2010 Free Software Foundation, Inc.
+/* Copyright (C) 2002-2005,2007,2009,2010,2011 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -23,10 +23,6 @@
 #include <pthread-errnos.h>
 #include <kernel-features.h>
 
-
-/* For the calculation see asm/vsyscall.h.  */
-#define VSYSCALL_ADDR_vgettimeofday	0xffffffffff600000
-
 	.text
 
 	.globl	pthread_rwlock_timedrdlock
@@ -123,8 +119,9 @@ pthread_rwlock_timedrdlock:
 	/* Get current time.  */
 	movq	%rsp, %rdi
 	xorl	%esi, %esi
-	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
-	callq	*%rax
+	/* This call works because we directly jump to a system call entry
+	   which preserves all the registers.  */
+	call	JUMPTARGET(__gettimeofday)
 
 	/* Compute relative timeout.  */
 	movq	8(%rsp), %rax
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S
index 6ed8b49..16bf920 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_rwlock_timedwrlock.S
@@ -1,4 +1,5 @@
-/* Copyright (C) 2002, 2003, 2005, 2007, 2009, 2010 Free Software Foundation, Inc.
+/* Copyright (C) 2002, 2003, 2005, 2007, 2009, 2010, 2011
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -23,10 +24,6 @@
 #include <pthread-errnos.h>
 #include <kernel-features.h>
 
-
-/* For the calculation see asm/vsyscall.h.  */
-#define VSYSCALL_ADDR_vgettimeofday	0xffffffffff600000
-
 	.text
 
 	.globl	pthread_rwlock_timedwrlock
@@ -120,8 +117,9 @@ pthread_rwlock_timedwrlock:
 	/* Get current time.  */
 	movq	%rsp, %rdi
 	xorl	%esi, %esi
-	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
-	callq	*%rax
+	/* This call works because we directly jump to a system call entry
+	   which preserves all the registers.  */
+	call	JUMPTARGET(__gettimeofday)
 
 	/* Compute relative timeout.  */
 	movq	8(%rsp), %rax
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S
index 979b1bf..2a631cf 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S
@@ -46,7 +46,7 @@ sem_post:
 #endif
 	jnz	0b
 
-	cmpq	$0, NWAITERS(%rdi)
+	CMP_LP	$0, NWAITERS(%rdi)
 	je	2f
 
 	movl	$SYS_futex, %eax
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S
index ca49cb8..b8db189 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S
@@ -1,4 +1,4 @@
-/* Copyright (C) 2002,2003,2005,2007,2009,2010 Free Software Foundation, Inc.
+/* Copyright (C) 2002,2003,2005,2007,2009,2010,2011 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
 
@@ -24,10 +24,6 @@
 #include <pthread-errnos.h>
 #include <structsem.h>
 
-
-/* For the calculation see asm/vsyscall.h.  */
-#define VSYSCALL_ADDR_vgettimeofday	0xffffffffff600000
-
 	.text
 
 	.globl	sem_timedwait
@@ -88,7 +84,7 @@ sem_timedwait:
 	movq	%rsi, %r10
 
 	LOCK
-	addq	$1, NWAITERS(%rdi)
+	ADD_LP	$1, NWAITERS(%rdi)
 
 .LcleanupSTART:
 13:	call	__pthread_enable_asynccancel
@@ -139,7 +135,7 @@ sem_timedwait:
 	xorl	%eax, %eax
 
 15:	LOCK
-	subq	$1, NWAITERS(%rdi)
+	SUB_LP	$1, NWAITERS(%rdi)
 
 	leaq	8(%rsp), %rsp
 	cfi_adjust_cfa_offset(-8)
@@ -209,12 +205,13 @@ sem_timedwait:
 	movq	%rsi, %r13
 
 	LOCK
-	addq	$1, NWAITERS(%r12)
+	ADD_LP	$1, NWAITERS(%r12)
 
 7:	xorl	%esi, %esi
-	movq	%rsp, %rdi
-	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
-	callq	*%rax
+	movq	%rsp,%rdi
+	/* This call works because we directly jump to a system call entry
+	   which preserves all the registers.  */
+	call	JUMPTARGET(__gettimeofday)
 
 	/* Compute relative timeout.  */
 	movq	8(%rsp), %rax
@@ -285,7 +282,7 @@ sem_timedwait:
 	xorl	%eax, %eax
 
 45:	LOCK
-	subq	$1, NWAITERS(%r12)
+	SUB_LP	$1, NWAITERS(%r12)
 
 	addq	$STACKFRAME, %rsp
 	cfi_adjust_cfa_offset(-STACKFRAME)
@@ -328,7 +325,7 @@ sem_timedwait_cleanup:
 
 	movq	(%rsp), %rdi
 	LOCK
-	subq	$1, NWAITERS(%rdi)
+	SUB_LP	$1, NWAITERS(%rdi)
 	movq	%rax, %rdi
 .LcallUR:
 	call	_Unwind_Resume@PLT
@@ -348,7 +345,7 @@ sem_timedwait_cleanup2:
 	cfi_rel_offset(%r14, STACKFRAME)
 
 	LOCK
-	subq	$1, NWAITERS(%r12)
+	SUB_LP	$1, NWAITERS(%r12)
 	movq	%rax, %rdi
 	movq	STACKFRAME(%rsp), %r14
 	movq	STACKFRAME+8(%rsp), %r13
@@ -396,9 +393,9 @@ sem_timedwait_cleanup2:
 	.hidden	DW.ref.__gcc_personality_v0
 	.weak	DW.ref.__gcc_personality_v0
 	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	8
+	.align	LP_SIZE
 	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, 8
+	.size	DW.ref.__gcc_personality_v0, LP_SIZE
 DW.ref.__gcc_personality_v0:
-	.quad	__gcc_personality_v0
+	ASM_ADDR __gcc_personality_v0
 #endif
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S
index 2cf6ec1..12d9e93 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S
@@ -67,7 +67,7 @@ sem_wait:
 	cfi_adjust_cfa_offset(8)
 
 	LOCK
-	addq	$1, NWAITERS(%rdi)
+	ADD_LP	$1, NWAITERS(%rdi)
 
 .LcleanupSTART:
 6:	call	__pthread_enable_asynccancel
@@ -116,7 +116,7 @@ sem_wait:
 	xorl	%eax, %eax
 
 9:	LOCK
-	subq	$1, NWAITERS(%rdi)
+	SUB_LP	$1, NWAITERS(%rdi)
 
 	leaq	8(%rsp), %rsp
 	cfi_adjust_cfa_offset(-8)
@@ -143,7 +143,7 @@ sem_wait:
 sem_wait_cleanup:
 	movq	(%rsp), %rdi
 	LOCK
-	subq	$1, NWAITERS(%rdi)
+	SUB_LP	$1, NWAITERS(%rdi)
 	movq	%rax, %rdi
 .LcallUR:
 	call	_Unwind_Resume@PLT
@@ -175,9 +175,9 @@ sem_wait_cleanup:
 	.hidden	DW.ref.__gcc_personality_v0
 	.weak	DW.ref.__gcc_personality_v0
 	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	8
+	.align	LP_SIZE
 	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, 8
+	.size	DW.ref.__gcc_personality_v0, LP_SIZE
 DW.ref.__gcc_personality_v0:
-	.quad	__gcc_personality_v0
+	ASM_ADDR __gcc_personality_v0
 #endif
diff --git a/nptl/sysdeps/x86_64/pthreaddef.h b/nptl/sysdeps/x86_64/pthreaddef.h
index 8ec135c..1dbc0cf 100644
--- a/nptl/sysdeps/x86_64/pthreaddef.h
+++ b/nptl/sysdeps/x86_64/pthreaddef.h
@@ -34,7 +34,7 @@
 
 /* Location of current stack frame.  The frame pointer is not usable.  */
 #define CURRENT_STACK_FRAME \
-  ({ char *frame; asm ("movq %%rsp, %0" : "=r" (frame)); frame; })
+  ({ char *frame; asm ("mov %%" RSP_LP ", %0" : "=r" (frame)); frame; })
 
 
 /* XXX Until we have a better place keep the definitions here.  */
diff --git a/nptl/sysdeps/x86_64/tls.h b/nptl/sysdeps/x86_64/tls.h
index 41b5e6d..0b45844 100644
--- a/nptl/sysdeps/x86_64/tls.h
+++ b/nptl/sysdeps/x86_64/tls.h
@@ -28,7 +28,6 @@
 # include <stdlib.h>
 # include <sysdep.h>
 # include <kernel-features.h>
-# include <bits/wordsize.h>
 # include <xmmintrin.h>
 
 
@@ -61,17 +60,22 @@ typedef struct
 # else
   int __unused1;
 # endif
-# if __WORDSIZE == 64
+# ifdef __x86_64__
   int rtld_must_xmm_save;
 # endif
   /* Reservation of some values for the TM ABI.  */
   void *__private_tm[5];
-# if __WORDSIZE == 64
+# ifdef __x86_64__
+#  ifdef __LP64__
   long int __unused2;
+#  else
+  /* Pad rtld_savespace_sse to 32byte aligned.  */
+  void *__padding1[5];
+#  endif
   /* Have space for the post-AVX register size.  */
   __m128 rtld_savespace_sse[8][4];
 
-  void *__padding[8];
+  void *__padding2[8];
 # endif
 } tcbhead_t;
 
@@ -274,7 +278,7 @@ typedef struct
 	   abort ();							      \
 									      \
 	 asm volatile ("movq %q0,%%fs:%P1" :				      \
-		       : IMM_MODE ((unsigned long int) value),		      \
+		       : IMM_MODE ((unsigned long long int) value),	      \
 			 "i" (offsetof (struct pthread, member)));	      \
        }})
 
@@ -299,7 +303,7 @@ typedef struct
 	   abort ();							      \
 									      \
 	 asm volatile ("movq %q0,%%fs:%P1(,%q2,8)" :			      \
-		       : IMM_MODE ((unsigned long int) value),		      \
+		       : IMM_MODE ((unsigned long long int) value),	      \
 			 "i" (offsetof (struct pthread, member[0])),	      \
 			 "r" (idx));					      \
        }})
diff --git a/nptl/sysdeps/x86_64/x32/tls.h b/nptl/sysdeps/x86_64/x32/tls.h
new file mode 100644
index 0000000..6622b4e
--- /dev/null
+++ b/nptl/sysdeps/x86_64/x32/tls.h
@@ -0,0 +1,49 @@
+/* Definition for thread-local data handling.  nptl/x32 version.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _X32_TLS_H
+#define _X32_TLS_H	1
+
+#include <sysdeps/x86_64/tls.h>
+
+#ifndef __ASSEMBLER__
+
+# undef THREAD_SELF
+# define THREAD_SELF \
+  ({ struct pthread *__self;						      \
+     asm ("movl %%fs:%c1,%k0" : "=r" (__self)				      \
+	  : "i" (offsetof (struct pthread, header.self)));	 	      \
+     __self;})
+
+# undef CALL_THREAD_FCT
+# define CALL_THREAD_FCT(descr) \
+  ({ void *__res;							      \
+     asm volatile ("movl %%fs:%P2, %%edi\n\t"				      \
+		   "movl %%fs:%P1, %k0\n\t"				      \
+		   "callq *%q0"						      \
+		   : "=a" (__res)					      \
+		   : "i" (offsetof (struct pthread, start_routine)),	      \
+		     "i" (offsetof (struct pthread, arg))		      \
+		   : "di", "si", "cx", "dx", "r8", "r9", "r10", "r11",	      \
+		     "memory", "cc");					      \
+     __res; })
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* x32/tls.h */
diff --git a/nptl/unwind.c b/nptl/unwind.c
index 9a35695..37eeba7 100644
--- a/nptl/unwind.c
+++ b/nptl/unwind.c
@@ -69,7 +69,7 @@ unwind_stop (int version, _Unwind_Action actions,
 	 registered with the old method which would be unwound by this
 	 step.  */
       struct _pthread_cleanup_buffer *oldp = buf->priv.data.cleanup;
-      void *cfa = (void *) _Unwind_GetCFA (context);
+      void *cfa = (void *) (_Unwind_Ptr) _Unwind_GetCFA (context);
 
       if (curp != oldp && (do_longjump || FRAME_LEFT (cfa, curp, adj)))
 	{
diff --git a/scripts/data/c++-types-x32-linux-gnu.data b/scripts/data/c++-types-x32-linux-gnu.data
new file mode 100644
index 0000000..0a89e27
--- /dev/null
+++ b/scripts/data/c++-types-x32-linux-gnu.data
@@ -0,0 +1,67 @@
+blkcnt64_t:x
+blkcnt_t:x
+blksize_t:x
+caddr_t:Pc
+clockid_t:i
+clock_t:l
+daddr_t:i
+dev_t:y
+fd_mask:l
+fsblkcnt64_t:y
+fsblkcnt_t:y
+fsfilcnt64_t:y
+fsfilcnt_t:y
+fsid_t:8__fsid_t
+gid_t:j
+id_t:j
+ino64_t:y
+ino_t:y
+int16_t:s
+int32_t:i
+int64_t:x
+int8_t:a
+intptr_t:i
+key_t:i
+loff_t:x
+mode_t:j
+nlink_t:y
+off64_t:x
+off_t:x
+pid_t:i
+pthread_attr_t:14pthread_attr_t
+pthread_barrier_t:17pthread_barrier_t
+pthread_barrierattr_t:21pthread_barrierattr_t
+pthread_cond_t:14pthread_cond_t
+pthread_condattr_t:18pthread_condattr_t
+pthread_key_t:j
+pthread_mutex_t:15pthread_mutex_t
+pthread_mutexattr_t:19pthread_mutexattr_t
+pthread_once_t:i
+pthread_rwlock_t:16pthread_rwlock_t
+pthread_rwlockattr_t:20pthread_rwlockattr_t
+pthread_spinlock_t:i
+pthread_t:m
+quad_t:x
+register_t:x
+rlim64_t:y
+rlim_t:y
+sigset_t:10__sigset_t
+size_t:j
+socklen_t:j
+ssize_t:i
+suseconds_t:x
+time_t:x
+u_char:h
+uid_t:j
+uint:j
+u_int:j
+u_int16_t:t
+u_int32_t:j
+u_int64_t:y
+u_int8_t:h
+ulong:m
+u_long:m
+u_quad_t:y
+useconds_t:j
+ushort:t
+u_short:t
diff --git a/shlib-versions b/shlib-versions
index d3e8407..75e0365 100644
--- a/shlib-versions
+++ b/shlib-versions
@@ -28,7 +28,6 @@
 
 s390x-.*-linux.*        DEFAULT			GLIBC_2.2
 cris-.*-linux.*		DEFAULT			GLIBC_2.2
-x86_64-.*-linux.*       DEFAULT			GLIBC_2.2.5
 powerpc64-.*-linux.*	DEFAULT			GLIBC_2.3
 .*-.*-gnu-gnu.*		DEFAULT			GLIBC_2.2.6
 
@@ -85,7 +84,6 @@ ia64-.*-linux.*		ld=ld-linux-ia64.so.2	GLIBC_2.2
 s390x-.*-linux.*	ld=ld64.so.1		GLIBC_2.2
 powerpc64.*-.*-linux.*	ld=ld64.so.1		GLIBC_2.3
 cris-.*-linux.*		ld=ld.so.1		GLIBC_2.2
-x86_64-.*-linux.*	ld=ld-linux-x86-64.so.2	GLIBC_2.2.5
 # We use the ELF ABI standard name for the default.
 .*-.*-.*		ld=ld.so.1
 
diff --git a/stdio-common/_itoa.c b/stdio-common/_itoa.c
index 373843f..abb28aa 100644
--- a/stdio-common/_itoa.c
+++ b/stdio-common/_itoa.c
@@ -80,7 +80,7 @@ struct base_table_t
 
 
 /* We do not compile _itoa if we always can use _itoa_word.  */
-#if LLONG_MAX != LONG_MAX
+#if LLONG_MAX != LONG_MAX && !defined PREFER_LONG_LONG
 /* Local variables.  */
 const struct base_table_t _itoa_base_table[] attribute_hidden =
 {
@@ -202,7 +202,6 @@ _itoa_word (unsigned long value, char *buflim,
     }
   return buflim;
 }
-#undef SPECIAL
 
 
 #if LLONG_MAX != LONG_MAX
@@ -216,11 +215,31 @@ _itoa (value, buflim, base, upper_case)
   const char *digits = (upper_case
 			? INTUSE(_itoa_upper_digits)
 			: INTUSE(_itoa_lower_digits));
+
+# ifdef PREFER_LONG_LONG
+  switch (base)
+    {
+#define SPECIAL(Base)							      \
+    case Base:								      \
+      do								      \
+	*--buflim = digits[value % Base];				      \
+      while ((value /= Base) != 0);					      \
+      break
+
+      SPECIAL (10);
+      SPECIAL (16);
+      SPECIAL (8);
+    default:
+      do
+	*--buflim = digits[value % base];
+      while ((value /= base) != 0);
+    }
+# else
   const struct base_table_t *brec = &_itoa_base_table[base - 2];
 
   switch (base)
     {
-# define RUN_2N(BITS) \
+#  define RUN_2N(BITS) \
       do								      \
         {								      \
 	  /* `unsigned long long int' always has 64 bits.  */		      \
@@ -275,7 +294,7 @@ _itoa (value, buflim, base, upper_case)
     default:
       {
 	char *bufend = buflim;
-# if BITS_PER_MP_LIMB == 64
+#  if BITS_PER_MP_LIMB == 64
 	mp_limb_t base_multiplier = brec->base_multiplier;
 	if (brec->flag)
 	  while (value != 0)
@@ -299,8 +318,8 @@ _itoa (value, buflim, base, upper_case)
 	      *--buflim = digits[rem];
 	      value = quo;
 	    }
-# endif
-# if BITS_PER_MP_LIMB == 32
+#  endif
+#  if BITS_PER_MP_LIMB == 32
 	mp_limb_t t[3];
 	int n;
 
@@ -308,11 +327,11 @@ _itoa (value, buflim, base, upper_case)
 	   Optimize for frequent cases of 32 bit numbers.  */
 	if ((mp_limb_t) (value >> 32) >= 1)
 	  {
-#  if UDIV_TIME > 2 * UMUL_TIME || UDIV_NEEDS_NORMALIZATION
+#   if UDIV_TIME > 2 * UMUL_TIME || UDIV_NEEDS_NORMALIZATION
 	    int big_normalization_steps = brec->big.normalization_steps;
 	    mp_limb_t big_base_norm
 	      = brec->big.base << big_normalization_steps;
-#  endif
+#   endif
 	    if ((mp_limb_t) (value >> 32) >= brec->big.base)
 	      {
 		mp_limb_t x1hi, x1lo, r;
@@ -321,7 +340,7 @@ _itoa (value, buflim, base, upper_case)
 		   always be very small.  It might be faster just to
 		   subtract in a tight loop.  */
 
-#  if UDIV_TIME > 2 * UMUL_TIME
+#   if UDIV_TIME > 2 * UMUL_TIME
 		mp_limb_t x, xh, xl;
 
 		if (big_normalization_steps == 0)
@@ -346,7 +365,7 @@ _itoa (value, buflim, base, upper_case)
 		udiv_qrnnd_preinv (t[0], x, xh, xl, big_base_norm,
 				   brec->big.base_ninv);
 		t[1] = x >> big_normalization_steps;
-#  elif UDIV_NEEDS_NORMALIZATION
+#   elif UDIV_NEEDS_NORMALIZATION
 		mp_limb_t x, xh, xl;
 
 		if (big_normalization_steps == 0)
@@ -368,17 +387,17 @@ _itoa (value, buflim, base, upper_case)
 		xl = x1lo << big_normalization_steps;
 		udiv_qrnnd (t[0], x, xh, xl, big_base_norm);
 		t[1] = x >> big_normalization_steps;
-#  else
+#   else
 		udiv_qrnnd (x1hi, r, 0, (mp_limb_t) (value >> 32),
 			    brec->big.base);
 		udiv_qrnnd (x1lo, t[2], r, (mp_limb_t) value, brec->big.base);
 		udiv_qrnnd (t[0], t[1], x1hi, x1lo, brec->big.base);
-#  endif
+#   endif
 		n = 3;
 	      }
 	    else
 	      {
-#  if UDIV_TIME > 2 * UMUL_TIME
+#   if UDIV_TIME > 2 * UMUL_TIME
 		mp_limb_t x;
 
 		value <<= brec->big.normalization_steps;
@@ -386,17 +405,17 @@ _itoa (value, buflim, base, upper_case)
 				   (mp_limb_t) value, big_base_norm,
 				   brec->big.base_ninv);
 		t[1] = x >> brec->big.normalization_steps;
-#  elif UDIV_NEEDS_NORMALIZATION
+#   elif UDIV_NEEDS_NORMALIZATION
 		mp_limb_t x;
 
 		value <<= big_normalization_steps;
 		udiv_qrnnd (t[0], x, (mp_limb_t) (value >> 32),
 			    (mp_limb_t) value, big_base_norm);
 		t[1] = x >> big_normalization_steps;
-#  else
+#   else
 		udiv_qrnnd (t[0], t[1], (mp_limb_t) (value >> 32),
 			    (mp_limb_t) value, brec->big.base);
-#  endif
+#   endif
 		n = 2;
 	      }
 	  }
@@ -412,7 +431,7 @@ _itoa (value, buflim, base, upper_case)
 	    mp_limb_t ti = t[--n];
 	    int ndig_for_this_limb = 0;
 
-#  if UDIV_TIME > 2 * UMUL_TIME
+#   if UDIV_TIME > 2 * UMUL_TIME
 	    mp_limb_t base_multiplier = brec->base_multiplier;
 	    if (brec->flag)
 	      while (ti != 0)
@@ -438,7 +457,7 @@ _itoa (value, buflim, base, upper_case)
 		  ti = quo;
 		  ++ndig_for_this_limb;
 		}
-#  else
+#   else
 	    while (ti != 0)
 	      {
 		mp_limb_t quo, rem;
@@ -449,7 +468,7 @@ _itoa (value, buflim, base, upper_case)
 		ti = quo;
 		++ndig_for_this_limb;
 	      }
-#  endif
+#   endif
 	    /* If this wasn't the most significant word, pad with zeros.  */
 	    if (n != 0)
 	      while (ndig_for_this_limb < brec->big.ndigits)
@@ -459,17 +478,20 @@ _itoa (value, buflim, base, upper_case)
 		}
 	  }
 	while (n != 0);
-# endif
+#  endif
 	if (buflim == bufend)
 	  *--buflim = '0';
       }
       break;
     }
+# endif /* PREFER_LONG_LONG */
 
   return buflim;
 }
 #endif
 
+#undef SPECIAL
+
 char *
 _fitoa_word (unsigned long value, char *buf, unsigned int base, int upper_case)
 {
diff --git a/stdio-common/_itowa.c b/stdio-common/_itowa.c
index 09a961d..689798f 100644
--- a/stdio-common/_itowa.c
+++ b/stdio-common/_itowa.c
@@ -97,11 +97,32 @@ _itowa (value, buflim, base, upper_case)
   const wchar_t *digits = (upper_case
 			   ? _itowa_upper_digits : _itowa_lower_digits);
   wchar_t *bp = buflim;
+
+# ifdef PREFER_LONG_LONG
+  switch (base)
+    {
+#  define SPECIAL(Base)							      \
+    case Base:								      \
+      do								      \
+	*--bp = digits[value % Base];					      \
+      while ((value /= Base) != 0);					      \
+      break
+
+      SPECIAL (10);
+      SPECIAL (16);
+      SPECIAL (8);
+    default:
+      do
+	*--bp = digits[value % base];
+      while ((value /= base) != 0);
+    }
+#  undef SPECIAL
+# else
   const struct base_table_t *brec = &_itoa_base_table[base - 2];
 
   switch (base)
     {
-# define RUN_2N(BITS) \
+#  define RUN_2N(BITS) \
       do								      \
         {								      \
 	  /* `unsigned long long int' always has 64 bits.  */		      \
@@ -155,7 +176,7 @@ _itowa (value, buflim, base, upper_case)
 
     default:
       {
-# if BITS_PER_MP_LIMB == 64
+#  if BITS_PER_MP_LIMB == 64
 	mp_limb_t base_multiplier = brec->base_multiplier;
 	if (brec->flag)
 	  while (value != 0)
@@ -179,8 +200,8 @@ _itowa (value, buflim, base, upper_case)
 	      *--bp = digits[rem];
 	      value = quo;
 	    }
-# endif
-# if BITS_PER_MP_LIMB == 32
+#  endif
+#  if BITS_PER_MP_LIMB == 32
 	mp_limb_t t[3];
 	int n;
 
@@ -188,11 +209,11 @@ _itowa (value, buflim, base, upper_case)
 	   Optimize for frequent cases of 32 bit numbers.  */
 	if ((mp_limb_t) (value >> 32) >= 1)
 	  {
-# if UDIV_TIME > 2 * UMUL_TIME || UDIV_NEEDS_NORMALIZATION
+#  if UDIV_TIME > 2 * UMUL_TIME || UDIV_NEEDS_NORMALIZATION
 	    int big_normalization_steps = brec->big.normalization_steps;
 	    mp_limb_t big_base_norm
 	      = brec->big.base << big_normalization_steps;
-# endif
+#  endif
 	    if ((mp_limb_t) (value >> 32) >= brec->big.base)
 	      {
 		mp_limb_t x1hi, x1lo, r;
@@ -201,7 +222,7 @@ _itowa (value, buflim, base, upper_case)
 		   always be very small.  It might be faster just to
 		   subtract in a tight loop.  */
 
-# if UDIV_TIME > 2 * UMUL_TIME
+#  if UDIV_TIME > 2 * UMUL_TIME
 		mp_limb_t x, xh, xl;
 
 		if (big_normalization_steps == 0)
@@ -226,7 +247,7 @@ _itowa (value, buflim, base, upper_case)
 		udiv_qrnnd_preinv (t[0], x, xh, xl, big_base_norm,
 				   brec->big.base_ninv);
 		t[1] = x >> big_normalization_steps;
-# elif UDIV_NEEDS_NORMALIZATION
+#  elif UDIV_NEEDS_NORMALIZATION
 		mp_limb_t x, xh, xl;
 
 		if (big_normalization_steps == 0)
@@ -248,17 +269,17 @@ _itowa (value, buflim, base, upper_case)
 		xl = x1lo << big_normalization_steps;
 		udiv_qrnnd (t[0], x, xh, xl, big_base_norm);
 		t[1] = x >> big_normalization_steps;
-# else
+#  else
 		udiv_qrnnd (x1hi, r, 0, (mp_limb_t) (value >> 32),
 			    brec->big.base);
 		udiv_qrnnd (x1lo, t[2], r, (mp_limb_t) value, brec->big.base);
 		udiv_qrnnd (t[0], t[1], x1hi, x1lo, brec->big.base);
-# endif
+#  endif
 		n = 3;
 	      }
 	    else
 	      {
-# if UDIV_TIME > 2 * UMUL_TIME
+#  if UDIV_TIME > 2 * UMUL_TIME
 		mp_limb_t x;
 
 		value <<= brec->big.normalization_steps;
@@ -266,17 +287,17 @@ _itowa (value, buflim, base, upper_case)
 				   (mp_limb_t) value, big_base_norm,
 				   brec->big.base_ninv);
 		t[1] = x >> brec->big.normalization_steps;
-# elif UDIV_NEEDS_NORMALIZATION
+#  elif UDIV_NEEDS_NORMALIZATION
 		mp_limb_t x;
 
 		value <<= big_normalization_steps;
 		udiv_qrnnd (t[0], x, (mp_limb_t) (value >> 32),
 			    (mp_limb_t) value, big_base_norm);
 		t[1] = x >> big_normalization_steps;
-# else
+#  else
 		udiv_qrnnd (t[0], t[1], (mp_limb_t) (value >> 32),
 			    (mp_limb_t) value, brec->big.base);
-# endif
+#  endif
 		n = 2;
 	      }
 	  }
@@ -292,7 +313,7 @@ _itowa (value, buflim, base, upper_case)
 	    mp_limb_t ti = t[--n];
 	    int ndig_for_this_limb = 0;
 
-# if UDIV_TIME > 2 * UMUL_TIME
+#  if UDIV_TIME > 2 * UMUL_TIME
 	    mp_limb_t base_multiplier = brec->base_multiplier;
 	    if (brec->flag)
 	      while (ti != 0)
@@ -318,7 +339,7 @@ _itowa (value, buflim, base, upper_case)
 		  ti = quo;
 		  ++ndig_for_this_limb;
 		}
-# else
+#  else
 	    while (ti != 0)
 	      {
 		mp_limb_t quo, rem;
@@ -329,7 +350,7 @@ _itowa (value, buflim, base, upper_case)
 		ti = quo;
 		++ndig_for_this_limb;
 	      }
-# endif
+#  endif
 	    /* If this wasn't the most significant word, pad with zeros.  */
 	    if (n != 0)
 	      while (ndig_for_this_limb < brec->big.ndigits)
@@ -339,10 +360,11 @@ _itowa (value, buflim, base, upper_case)
 		}
 	  }
 	while (n != 0);
-# endif
+#  endif
       }
       break;
     }
+# endif /* PREFER_LONG_LONG */
 
   return bp;
 }
diff --git a/stdlib/longlong.h b/stdlib/longlong.h
index 1bab76d..d5c0cd9 100644
--- a/stdlib/longlong.h
+++ b/stdlib/longlong.h
@@ -430,8 +430,8 @@ UDItype __umulsidi3 (USItype, USItype);
 	   : "0" ((UDItype) (n0)),					\
 	     "1" ((UDItype) (n1)),					\
 	     "rm" ((UDItype) (dv)))
-#define count_leading_zeros(count, x)	((count) = __builtin_clzl (x))
-#define count_trailing_zeros(count, x)	((count) = __builtin_ctzl (x))
+#define count_leading_zeros(count, x)	((count) = __builtin_clzll (x))
+#define count_trailing_zeros(count, x)	((count) = __builtin_ctzll (x))
 #define UMUL_TIME 40
 #define UDIV_TIME 40
 #endif /* x86_64 */
diff --git a/sysdeps/generic/ldconfig.h b/sysdeps/generic/ldconfig.h
index fadd5ec..57ead17 100644
--- a/sysdeps/generic/ldconfig.h
+++ b/sysdeps/generic/ldconfig.h
@@ -34,6 +34,7 @@
 #define FLAG_POWERPC_LIB64	0x0500
 #define FLAG_MIPS64_LIBN32	0x0600
 #define FLAG_MIPS64_LIBN64	0x0700
+#define FLAG_X8664_LIBX32	0x0800
 
 /* Name of auxiliary cache.  */
 #define _PATH_LDCONFIG_AUX_CACHE "/var/cache/ldconfig/aux-cache"
diff --git a/sysdeps/generic/ldsodefs.h b/sysdeps/generic/ldsodefs.h
index d040590..3f8264a 100644
--- a/sysdeps/generic/ldsodefs.h
+++ b/sysdeps/generic/ldsodefs.h
@@ -230,6 +230,10 @@ struct audit_ifaces
 				       uintptr_t *, struct La_x86_64_regs *,
 				       unsigned int *, const char *name,
 				       long int *framesizep);
+    Elf32_Addr (*x32_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *,
+				    uintptr_t *, struct La_x86_64_regs *,
+				    unsigned int *, const char *name,
+				    long int *framesizep);
     Elf32_Addr (*ppc32_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *,
 				      uintptr_t *, struct La_ppc32_regs *,
 				      unsigned int *, const char *name,
@@ -282,6 +286,11 @@ struct audit_ifaces
 					const struct La_x86_64_regs *,
 					struct La_x86_64_retval *,
 					const char *);
+    unsigned int (*x32_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *,
+				     uintptr_t *,
+				     const struct La_x86_64_regs *,
+				     struct La_x86_64_retval *,
+				     const char *);
     unsigned int (*ppc32_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *,
 				       uintptr_t *,
 				       const struct La_ppc32_regs *,
diff --git a/sysdeps/ieee754/dbl-64/wordsize-64/s_llround.c b/sysdeps/ieee754/dbl-64/wordsize-64/s_llround.c
index f7c9ea5..2fbbd64 100644
--- a/sysdeps/ieee754/dbl-64/wordsize-64/s_llround.c
+++ b/sysdeps/ieee754/dbl-64/wordsize-64/s_llround.c
@@ -1 +1,80 @@
-/* The code is the same as lround.  Use an alias, see l_round.c.  */
+/* Round double value to long long int.
+   Copyright (C) 1997, 2004, 2009, 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define lround __hidden_lround
+#define __lround __hidden___lround
+
+#include <math.h>
+
+#include "math_private.h"
+
+
+long long int
+__llround (double x)
+{
+  int32_t j0;
+  int64_t i0;
+  long long int result;
+  int sign;
+
+  EXTRACT_WORDS64 (i0, x);
+  j0 = ((i0 >> 52) & 0x7ff) - 0x3ff;
+  sign = i0 < 0 ? -1 : 1;
+  i0 &= UINT64_C(0xfffffffffffff);
+  i0 |= UINT64_C(0x10000000000000);
+
+  if (j0 < (int32_t) (8 * sizeof (long long int)) - 1)
+    {
+      if (j0 < 0)
+	return j0 < -1 ? 0 : sign;
+      else if (j0 >= 52)
+	result = i0 << (j0 - 52);
+      else
+	{
+	  i0 += UINT64_C(0x8000000000000) >> j0;
+
+	  result = i0 >> (52 - j0);
+	}
+    }
+  else
+    {
+      /* The number is too large.  It is left implementation defined
+	 what happens.  */
+      return (long long int) x;
+    }
+
+  return sign * result;
+}
+
+weak_alias (__llround, llround)
+#ifdef NO_LONG_DOUBLE
+strong_alias (__llround, __lroundl)
+weak_alias (__llround, lroundl)
+#endif
+
+/* long has the same width as long long on 64-bit machines.  */
+#undef lround
+#undef __lround
+strong_alias (__llround, __lround)
+weak_alias (__llround, lround)
+#ifdef NO_LONG_DOUBLE
+strong_alias (__llround, __llroundl)
+weak_alias (__llround, llroundl)
+#endif
diff --git a/sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c b/sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c
index 30ea5db..16db260 100644
--- a/sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c
+++ b/sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c
@@ -1,80 +1 @@
-/* Round double value to long int.
-   Copyright (C) 1997, 2004, 2009 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#define llround __hidden_llround
-#define __llround __hidden___llround
-
-#include <math.h>
-
-#include "math_private.h"
-
-
-long int
-__lround (double x)
-{
-  int32_t j0;
-  int64_t i0;
-  long int result;
-  int sign;
-
-  EXTRACT_WORDS64 (i0, x);
-  j0 = ((i0 >> 52) & 0x7ff) - 0x3ff;
-  sign = i0 < 0 ? -1 : 1;
-  i0 &= UINT64_C(0xfffffffffffff);
-  i0 |= UINT64_C(0x10000000000000);
-
-  if (j0 < (int32_t) (8 * sizeof (long int)) - 1)
-    {
-      if (j0 < 0)
-	return j0 < -1 ? 0 : sign;
-      else if (j0 >= 52)
-	result = i0 << (j0 - 52);
-      else
-	{
-	  i0 += UINT64_C(0x8000000000000) >> j0;
-
-	  result = i0 >> (52 - j0);
-	}
-    }
-  else
-    {
-      /* The number is too large.  It is left implementation defined
-	 what happens.  */
-      return (long int) x;
-    }
-
-  return sign * result;
-}
-
-weak_alias (__lround, lround)
-#ifdef NO_LONG_DOUBLE
-strong_alias (__lround, __lroundl)
-weak_alias (__lround, lroundl)
-#endif
-
-/* long long has the same width as long on 64-bit machines.  */
-#undef llround
-#undef __llround
-strong_alias (__lround, __llround)
-weak_alias (__lround, llround)
-#ifdef NO_LONG_DOUBLE
-strong_alias (__lround, __llroundl)
-weak_alias (__lround, llroundl)
-#endif
+/* The code is the same as llround.  Use an alias, see ll_round.c.  */
diff --git a/sysdeps/mach/hurd/bits/typesizes.h b/sysdeps/mach/hurd/bits/typesizes.h
index 4322617..8db5866 100644
--- a/sysdeps/mach/hurd/bits/typesizes.h
+++ b/sysdeps/mach/hurd/bits/typesizes.h
@@ -58,6 +58,7 @@
 #define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
 #define __FSID_T_TYPE		__UQUAD_TYPE
 #define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
 
 /* Number of descriptors that can fit in an `fd_set'.  */
 #define	__FD_SETSIZE		256
diff --git a/sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h b/sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h
index c0e267f..26ea5a6 100644
--- a/sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h
+++ b/sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h
@@ -58,6 +58,7 @@
 #define __BLKSIZE_T_TYPE	__U32_TYPE
 #define __FSID_T_TYPE		struct { int __val[2]; }
 #define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
 
 /* Number of descriptors that can fit in an `fd_set'.  */
 #define	__FD_SETSIZE		1024
diff --git a/sysdeps/unix/sysv/linux/Makefile b/sysdeps/unix/sysv/linux/Makefile
index 05834e3..9087230 100644
--- a/sysdeps/unix/sysv/linux/Makefile
+++ b/sysdeps/unix/sysv/linux/Makefile
@@ -37,6 +37,7 @@ install-others += $(inst_includedir)/bits/syscall.h
 
 tests += tst-clone
 
+ifeq (yes,$(use-default-syscall-macros))
 # Generate the list of SYS_* macros for the system calls (__NR_* macros).
 # For bi-arch platforms, the CPU/Makefile defines {32,64}bit-predefine and
 # we generate a file that uses <bits/wordsize.h>.
@@ -81,6 +82,7 @@ else
 endif
 	rm -f $(@:.h=.d)-t1 $(@:.h=.d)-t2
 	mv -f $(@:.h=.d)-t3 $(@:.h=.d)
+endif
 
 $(inst_includedir)/bits/syscall.h: $(objpfx)syscall-list.h $(+force)
 	$(make-target-directory)
diff --git a/sysdeps/unix/sysv/linux/configure b/sysdeps/unix/sysv/linux/configure
index d05bd13..e8b3e45 100644
--- a/sysdeps/unix/sysv/linux/configure
+++ b/sysdeps/unix/sysv/linux/configure
@@ -332,6 +332,9 @@ case "$machine" in
     libc_cv_gcc_unwind_find_fde=yes
     arch_minimum_kernel=2.0.10
     ;;
+  x86_64/x32*)
+    arch_minimum_kernel=2.6.35
+    ;;
   x86_64*)
     arch_minimum_kernel=2.4.0
     ;;
@@ -412,7 +415,7 @@ case "$prefix" in
   # and libc_cv_localedir.
   test -n "$libc_cv_slibdir" || \
   case $machine in
-  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64)
+  sparc/sparc64 | x86_64/64 | powerpc/powerpc64 | s390/s390-64)
     libc_cv_slibdir="/lib64"
     if test "$libdir" = '${exec_prefix}/lib'; then
       libdir='${exec_prefix}/lib64';
diff --git a/sysdeps/unix/sysv/linux/configure.in b/sysdeps/unix/sysv/linux/configure.in
index 8f00407..617622c 100644
--- a/sysdeps/unix/sysv/linux/configure.in
+++ b/sysdeps/unix/sysv/linux/configure.in
@@ -89,6 +89,9 @@ case "$machine" in
     libc_cv_gcc_unwind_find_fde=yes
     arch_minimum_kernel=2.0.10
     ;;
+  x86_64/x32*)
+    arch_minimum_kernel=2.6.35
+    ;;
   x86_64*)
     arch_minimum_kernel=2.4.0
     ;;
@@ -151,7 +154,7 @@ case "$prefix" in
   # and libc_cv_localedir.
   test -n "$libc_cv_slibdir" || \
   case $machine in
-  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64)
+  sparc/sparc64 | x86_64/64 | powerpc/powerpc64 | s390/s390-64)
     libc_cv_slibdir="/lib64"
     if test "$libdir" = '${exec_prefix}/lib'; then
       libdir='${exec_prefix}/lib64';
diff --git a/sysdeps/unix/sysv/linux/i386/readelflib.c b/sysdeps/unix/sysv/linux/i386/readelflib.c
index a6374e6..6e39b3d 100644
--- a/sysdeps/unix/sysv/linux/i386/readelflib.c
+++ b/sysdeps/unix/sysv/linux/i386/readelflib.c
@@ -36,8 +36,18 @@ process_elf_file (const char *file_name, const char *lib, int *flag,
   int ret;
 
   if (elf_header->e_ident [EI_CLASS] == ELFCLASS32)
-    return process_elf32_file (file_name, lib, flag, osversion, soname,
-			       file_contents, file_length);
+    {
+      ret = process_elf32_file (file_name, lib, flag, osversion, soname,
+				file_contents, file_length);
+      /* X32 libraries are always libc.so.6+.  */
+      if (!ret)
+	switch (elf_header->e_machine)
+	  {
+	  case EM_X86_64:
+	    *flag = FLAG_X8664_LIBX32|FLAG_ELF_LIBC6;
+	    break;
+	  }
+    }
   else
     {
       switch (elf_header->e_machine)
diff --git a/sysdeps/unix/sysv/linux/kernel-features.h b/sysdeps/unix/sysv/linux/kernel-features.h
index d91f581..58f833e 100644
--- a/sysdeps/unix/sysv/linux/kernel-features.h
+++ b/sysdeps/unix/sysv/linux/kernel-features.h
@@ -546,3 +546,8 @@
 #if __LINUX_KERNEL_VERSION >= 0x020627
 # define __ASSUME_SENDMMSG	1
 #endif
+
+/* getcpu is a syscall for x86-64 since 3.1.  */
+#if defined __x86_64__ && __LINUX_KERNEL_VERSION >= 0x030100
+# define __ASSUME_GETCPU_SYSCALL	1
+#endif
diff --git a/sysdeps/unix/sysv/linux/s390/bits/typesizes.h b/sysdeps/unix/sysv/linux/s390/bits/typesizes.h
index 2d9cd87..b97f42a 100644
--- a/sysdeps/unix/sysv/linux/s390/bits/typesizes.h
+++ b/sysdeps/unix/sysv/linux/s390/bits/typesizes.h
@@ -64,6 +64,7 @@
 /* size_t is unsigned long int on s390 -m31.  */
 #define __SSIZE_T_TYPE		__SLONGWORD_TYPE
 #endif
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
 
 /* Number of descriptors that can fit in an `fd_set'.  */
 #define	__FD_SETSIZE		1024
diff --git a/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h b/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h
index b0dd1bd..3f062c0 100644
--- a/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h
+++ b/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h
@@ -58,6 +58,7 @@
 #define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
 #define __FSID_T_TYPE		struct { int __val[2]; }
 #define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
 
 /* Number of descriptors that can fit in an `fd_set'.  */
 #define	__FD_SETSIZE		1024
diff --git a/sysdeps/unix/sysv/linux/x86_64/64/Implies b/sysdeps/unix/sysv/linux/x86_64/64/Implies
new file mode 100644
index 0000000..8d91c80
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/64/Implies
@@ -0,0 +1 @@
+unix/sysv/linux/wordsize-64
diff --git a/sysdeps/unix/sysv/linux/x86_64/Implies b/sysdeps/unix/sysv/linux/x86_64/Implies
deleted file mode 100644
index 8d91c80..0000000
--- a/sysdeps/unix/sysv/linux/x86_64/Implies
+++ /dev/null
@@ -1 +0,0 @@
-unix/sysv/linux/wordsize-64
diff --git a/sysdeps/unix/sysv/linux/x86_64/Makefile b/sysdeps/unix/sysv/linux/x86_64/Makefile
index 6e2741a..326a617 100644
--- a/sysdeps/unix/sysv/linux/x86_64/Makefile
+++ b/sysdeps/unix/sysv/linux/x86_64/Makefile
@@ -1,5 +1,5 @@
 32bit-predefine = __i386__
-64bit-predefine = __x86_64__
+64bit-predefine = __x86_64__ __LP64__
 
 ifeq ($(subdir),misc)
 sysdep_routines += ioperm iopl
@@ -14,6 +14,55 @@ ifeq ($(subdir),csu)
 gen-as-const-headers += ucontext_i.sym
 endif
 
+ifeq ($(subdir),misc)
+gen-as-const-headers += sigaltstack.sym
+endif
+
 ifeq ($(subdir),elf)
 sysdep_routines += dl-vdso
 endif
+
+# Generate the list of SYS_* macros for the system calls (__NR_* macros).
+# For bi-arch platforms, the CPU/Makefile defines {32,64}bit-predefine and
+# we generate a file that uses <bits/wordsize.h>.
+$(objpfx)syscall-%.h $(objpfx)syscall-%.d: ../sysdeps/unix/sysv/linux/sys/syscall.h
+	$(make-target-directory)
+	{ \
+	 echo '/* Generated at libc build time from kernel syscall list.  */';\
+	 echo ''; \
+	 echo '#ifndef _SYSCALL_H'; \
+	 echo '# error "Never use <bits/syscall.h> directly; include <sys/syscall.h> instead."'; \
+	 echo '#endif'; \
+	 echo ''; \
+	 $(CC) -E -MD -MP -MF $(@:.h=.d)-t1 -MT '$(@:.d=.h) $(@:.h=.d)' \
+	       -x c $(sysincludes) $< $(addprefix -U,$(64bit-predefine)) \
+	       $(addprefix -D,$(32bit-predefine)) -D_LIBC -dM | \
+	 sed -n 's@^#define __NR_\([^ ]*\) .*$$@#define SYS_\1 __NR_\1@p' | \
+	 LC_ALL=C sort > $(@:.d=.h).new32; \
+	 $(CC) -E -MD -MP -MF $(@:.h=.d)-t2 -MT '$(@:.d=.h) $(@:.h=.d)' \
+	       -x c $(sysincludes) $< $(addprefix -U,$(32bit-predefine)) \
+	       $(addprefix -D,$(64bit-predefine)) -D_LIBC -dM | \
+	       grep -i -v _x32_ | grep -v "COMMON_SYSCALL(n)" | \
+	 sed -n 's@^#define __NR_\([^ ]*\) .*$$@#define SYS_\1 __NR_\1@p' | \
+	 LC_ALL=C sort > $(@:.d=.h).new64; \
+	 if cmp -s $(@:.d=.h).new32 $(@:.d=.h).new64; then \
+	   cat $(@:.d=.h).new32; \
+	 else \
+	   echo ''; \
+	   LC_ALL=C comm -12 $(@:.d=.h).new32 $(@:.d=.h).new64; \
+	   echo '#ifdef __x86_64__'; \
+	   LC_ALL=C comm -13 $(@:.d=.h).new32 $(@:.d=.h).new64; \
+	   echo '#else'; \
+	   LC_ALL=C comm -23 $(@:.d=.h).new32 $(@:.d=.h).new64; \
+	   echo '#endif'; \
+	 fi; \
+	 rm -f $(@:.d=.h).new32 $(@:.d=.h).new64; \
+	} > $(@:.d=.h).new
+	mv -f $(@:.d=.h).new $(@:.d=.h)
+ifneq (,$(objpfx))
+	sed $(sed-remove-objpfx) $(@:.h=.d)-t1 $(@:.h=.d)-t2 > $(@:.h=.d)-t3
+else
+	cat $(@:.h=.d)-t1 $(@:.h=.d)-t2 > $(@:.h=.d)-t3
+endif
+	rm -f $(@:.h=.d)-t1 $(@:.h=.d)-t2
+	mv -f $(@:.h=.d)-t3 $(@:.h=.d)
diff --git a/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S b/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S
index 3881082..98a3e66 100644
--- a/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S
+++ b/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S
@@ -20,6 +20,8 @@
 #include <jmpbuf-offsets.h>
 #include <asm-syntax.h>
 
+#include "sigaltstack.h"
+
 	.section .rodata.str1.1,"aMS",@progbits,1
 	.type	longjmp_msg,@object
 longjmp_msg:
@@ -41,7 +43,7 @@ longjmp_msg:
 # define CALL_FAIL	subq	$8, %rsp;				      \
 			cfi_remember_state;				      \
 			cfi_def_cfa_offset(16);				      \
-			movq	$longjmp_msg, %rdi;			      \
+			mov	$longjmp_msg, %RDI_LP;			      \
 			call	HIDDEN_JUMPTARGET(__fortify_fail);	      \
 			nop;						      \
 			cfi_restore_state
@@ -57,9 +59,9 @@ ENTRY(____longjmp_chk)
 	movq	(JB_RBP*8)(%rdi), %r9
 	movq	(JB_PC*8)(%rdi), %rdx
 #ifdef PTR_DEMANGLE
-	PTR_DEMANGLE (%r8)
-	PTR_DEMANGLE (%r9)
-	PTR_DEMANGLE (%rdx)
+	PTR_DEMANGLE (%R8_LP)
+	PTR_DEMANGLE (%R9_LP)
+	PTR_DEMANGLE (%RDX_LP)
 #endif
 
 	cmpq	%r8, %rsp
@@ -72,19 +74,19 @@ ENTRY(____longjmp_chk)
 	cfi_register (%rsi, %rbx)
 
 	xorl	%edi, %edi
-	leaq	-24(%rsp), %rsi
+	lea	-sizeSS(%rsp), %RSI_LP
 	movl	$__NR_sigaltstack, %eax
 	syscall
 	/* Without working sigaltstack we cannot perform the test.  */
 	testl	%eax, %eax
 	jne	.Lok2
-	testl	$1, -16(%rsp)
+	testl	$1, (-sizeSS + oSS_FLAGS)(%rsp)
 	jz	.Lfail
 
-	movq	-24(%rsp), %rax
-	addq	-8(%rsp), %rax
+	mov	(-sizeSS + oSS_SP)(%rsp), %RAX_LP
+	add	(-sizeSS + oSS_SIZE)(%rsp), %RAX_LP
 	subq	%r8, %rax
-	cmpq	-8(%rsp), %rax
+	cmp	(-sizeSS + oSS_SIZE)(%rsp), %RAX_LP
 	jae	.Lok2
 
 .Lfail:	CALL_FAIL
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/a.out.h b/sysdeps/unix/sysv/linux/x86_64/bits/a.out.h
index 228a8d4..0e4a7c9 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/a.out.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/a.out.h
@@ -2,9 +2,7 @@
 # error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
 #endif
 
-#include <bits/wordsize.h>
-
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 
 /* Signal to users of this header that this architecture really doesn't
    support a.out binary format.  */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h b/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h
index 7f18562..0d00c69 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h
@@ -23,7 +23,6 @@
 #endif
 
 #include <sys/types.h>
-#include <bits/wordsize.h>
 #ifdef __USE_GNU
 # include <bits/uio.h>
 #endif
@@ -66,7 +65,7 @@
 #endif
 
 #ifdef __USE_LARGEFILE64
-# if __WORDSIZE == 64
+# ifdef __x86_64__
 #  define O_LARGEFILE	0
 # else
 #  define O_LARGEFILE	0100000
@@ -79,7 +78,7 @@
 #define F_SETFD		2	/* Set file descriptor flags.  */
 #define F_GETFL		3	/* Get file status flags.  */
 #define F_SETFL		4	/* Set file status flags.  */
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 # define F_GETLK	5	/* Get record locking info.  */
 # define F_SETLK	6	/* Set record locking info (non-blocking).  */
 # define F_SETLKW	7	/* Set record locking info (blocking).	*/
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/ipc.h b/sysdeps/unix/sysv/linux/x86_64/bits/ipc.h
new file mode 100644
index 0000000..27758ce
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/ipc.h
@@ -0,0 +1,57 @@
+/* Copyright (C) 1995-1999, 2000, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Mode bits for `msgget', `semget', and `shmget'.  */
+#define IPC_CREAT	01000		/* Create key if key does not exist. */
+#define IPC_EXCL	02000		/* Fail if key exists.  */
+#define IPC_NOWAIT	04000		/* Return error on wait.  */
+
+/* Control commands for `msgctl', `semctl', and `shmctl'.  */
+#define IPC_RMID	0		/* Remove identifier.  */
+#define IPC_SET		1		/* Set `ipc_perm' options.  */
+#define IPC_STAT	2		/* Get `ipc_perm' options.  */
+#ifdef __USE_GNU
+# define IPC_INFO	3		/* See ipcs.  */
+#endif
+
+/* Special key values.  */
+#define IPC_PRIVATE	((__key_t) 0)	/* Private key.  */
+
+
+/* Data structure used to pass permission information to IPC operations.  */
+struct ipc_perm
+  {
+    __key_t __key;			/* Key.  */
+    __uid_t uid;			/* Owner's user ID.  */
+    __gid_t gid;			/* Owner's group ID.  */
+    __uid_t cuid;			/* Creator's user ID.  */
+    __gid_t cgid;			/* Creator's group ID.  */
+    unsigned short int mode;		/* Read/write permission.  */
+    unsigned short int __pad1;
+    unsigned short int __seq;		/* Sequence number.  */
+    unsigned short int __pad2;
+    __UNATIVE_LONG_TYPE __unused1;
+    __UNATIVE_LONG_TYPE __unused2;
+  };
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/ipctypes.h b/sysdeps/unix/sysv/linux/x86_64/bits/ipctypes.h
new file mode 100644
index 0000000..f8101b1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/ipctypes.h
@@ -0,0 +1,32 @@
+/* bits/ipctypes.h -- Define some types used by SysV IPC/MSG/SHM.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipctypes.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#ifndef _BITS_IPCTYPES_H
+#define _BITS_IPCTYPES_H	1
+
+#include <bits/types.h>
+
+/* Used in `struct shmid_ds'.  */
+typedef __pid_t __ipc_pid_t;
+
+#endif /* bits/ipctypes.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/libc-vdso.h b/sysdeps/unix/sysv/linux/x86_64/bits/libc-vdso.h
index d7123c9..f9bf84e 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/libc-vdso.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/libc-vdso.h
@@ -1,5 +1,5 @@
 /* Resolve function pointers to VDSO functions.
-   Copyright (C) 2005, 2007 Free Software Foundation, Inc.
+   Copyright (C) 2005, 2007, 2011 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -25,9 +25,6 @@
 
 #ifdef SHARED
 
-extern long int (*__vdso_gettimeofday) (struct timeval *, void *)
-  attribute_hidden;
-
 extern long int (*__vdso_clock_gettime) (clockid_t, struct timespec *);
 
 #endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h b/sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h
new file mode 100644
index 0000000..3c2c006
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 2004, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MQUEUE_H
+# error "Never use <bits/mqueue.h> directly; include <mqueue.h> instead."
+#endif
+
+#include <sys/types.h>
+
+typedef int mqd_t;
+
+struct mq_attr
+{
+  __SNATIVE_LONG_TYPE mq_flags;		/* Message queue flags.  */
+  __SNATIVE_LONG_TYPE mq_maxmsg;	/* Maximum number of messages.  */
+  __SNATIVE_LONG_TYPE mq_msgsize;	/* Maximum message size.  */
+  __SNATIVE_LONG_TYPE mq_curmsgs;	/* Number of messages currently queued.  */
+  __SNATIVE_LONG_TYPE __pad[4];
+};
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/msq.h b/sysdeps/unix/sysv/linux/x86_64/bits/msq.h
index 422218a..376e16f 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/msq.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/msq.h
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2011
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,7 +22,6 @@
 #endif
 
 #include <bits/types.h>
-#include <bits/wordsize.h>
 
 /* Define options for message queue functions.  */
 #define MSG_NOERROR	010000	/* no error if message is too big */
@@ -30,8 +30,8 @@
 #endif
 
 /* Types used in the structure definition.  */
-typedef unsigned long int msgqnum_t;
-typedef unsigned long int msglen_t;
+typedef __UNATIVE_LONG_TYPE msgqnum_t;
+typedef __UNATIVE_LONG_TYPE msglen_t;
 
 /* Structure of record for one message inside the kernel.
    The type `struct msg' is opaque.  */
@@ -39,24 +39,24 @@ struct msqid_ds
 {
   struct ipc_perm msg_perm;	/* structure describing operation permission */
   __time_t msg_stime;		/* time of last msgsnd command */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
   unsigned long int __unused1;
 #endif
   __time_t msg_rtime;		/* time of last msgrcv command */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
   unsigned long int __unused2;
 #endif
   __time_t msg_ctime;		/* time of last change */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
   unsigned long int __unused3;
 #endif
-  unsigned long int __msg_cbytes; /* current number of bytes on queue */
+  __UNATIVE_LONG_TYPE __msg_cbytes; /* current number of bytes on queue */
   msgqnum_t msg_qnum;		/* number of messages currently on queue */
   msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
   __pid_t msg_lspid;		/* pid of last msgsnd() */
   __pid_t msg_lrpid;		/* pid of last msgrcv() */
-  unsigned long int __unused4;
-  unsigned long int __unused5;
+  __UNATIVE_LONG_TYPE __unused4;
+  __UNATIVE_LONG_TYPE __unused5;
 };
 
 #ifdef __USE_MISC
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/resource.h b/sysdeps/unix/sysv/linux/x86_64/bits/resource.h
new file mode 100644
index 0000000..dea74be
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/resource.h
@@ -0,0 +1,310 @@
+/* Bit values & structures for resource limits.  Linux version.
+   Copyright (C) 1994, 1996-2000, 2004, 2005, 2008, 2009, 2010, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  __RLIMIT_RSS = 5,
+#define	RLIMIT_RSS __RLIMIT_RSS
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 7,
+  __RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+#define RLIMIT_NOFILE RLIMIT_NOFILE
+#define RLIMIT_OFILE __RLIMIT_OFILE
+
+  /* Address space limit.  */
+  RLIMIT_AS = 9,
+#define RLIMIT_AS RLIMIT_AS
+
+  /* Number of processes.  */
+  __RLIMIT_NPROC = 6,
+#define RLIMIT_NPROC __RLIMIT_NPROC
+
+  /* Locked-in-memory address space.  */
+  __RLIMIT_MEMLOCK = 8,
+#define RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
+
+  /* Maximum number of file locks.  */
+  __RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS __RLIMIT_LOCKS
+
+  /* Maximum number of pending signals.  */
+  __RLIMIT_SIGPENDING = 11,
+#define RLIMIT_SIGPENDING __RLIMIT_SIGPENDING
+
+  /* Maximum bytes in POSIX message queues.  */
+  __RLIMIT_MSGQUEUE = 12,
+#define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
+
+  /* Maximum nice priority allowed to raise to.
+     Nice levels 19 .. -20 correspond to 0 .. 39
+     values of this resource limit.  */
+  __RLIMIT_NICE = 13,
+#define RLIMIT_NICE __RLIMIT_NICE
+
+  /* Maximum realtime priority allowed for non-priviledged
+     processes.  */
+  __RLIMIT_RTPRIO = 14,
+#define RLIMIT_RTPRIO __RLIMIT_RTPRIO
+
+  /* Maximum CPU time in s that a process scheduled under a real-time
+     scheduling policy may consume without making a blocking system
+     call before being forcibly descheduled.  */
+  __RLIMIT_RTTIME = 15,
+#define RLIMIT_RTTIME __RLIMIT_RTTIME
+
+  __RLIMIT_NLIMITS = 16,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((__rlim_t) -1)
+#else
+# define RLIM_INFINITY 0xffffffffffffffffuLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0xffffffffffffffffuLL
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+
+#ifdef __USE_GNU
+  ,
+  /* The calling thread.  */
+  RUSAGE_THREAD = 1
+# define RUSAGE_THREAD RUSAGE_THREAD
+  /* Name for the same functionality on Solaris.  */
+# define RUSAGE_LWP RUSAGE_THREAD
+#endif
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused1;
+#endif
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused2;
+#endif
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused3;
+#endif
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused4;
+#endif
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused5;
+#endif
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused6;
+#endif
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused7;
+#endif
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused8;
+#endif
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused9;
+#endif
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused10;
+#endif
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused11;
+#endif
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused12;
+#endif
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused13;
+#endif
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused14;
+#endif
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
+
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+/* Modify and return resource limits of a process atomically.  */
+# ifndef __USE_FILE_OFFSET64
+extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
+		    __const struct rlimit *__new_limit,
+		    struct rlimit *__old_limit) __THROW;
+# else
+#  ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (prlimit, (__pid_t __pid,
+				     enum __rlimit_resource __resource,
+				     __const struct rlimit *__new_limit,
+				     struct rlimit *__old_limit), prlimit64);
+#  else
+#   define prlimit prlimit64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
+		      __const struct rlimit64 *__new_limit,
+		      struct rlimit64 *__old_limit) __THROW;
+# endif
+#endif
+
+__END_DECLS
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/sem.h b/sysdeps/unix/sysv/linux/x86_64/bits/sem.h
index 9b1d993..61fcfd8 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/sem.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/sem.h
@@ -40,12 +40,12 @@ struct semid_ds
 {
   struct ipc_perm sem_perm;		/* operation permission struct */
   __time_t sem_otime;			/* last semop() time */
-  unsigned long int __unused1;
+  __UNATIVE_LONG_TYPE __unused1;
   __time_t sem_ctime;			/* last time changed by semctl() */
-  unsigned long int __unused2;
-  unsigned long int sem_nsems;		/* number of semaphores in set */
-  unsigned long int __unused3;
-  unsigned long int __unused4;
+  __UNATIVE_LONG_TYPE __unused2;
+  __UNATIVE_LONG_TYPE sem_nsems;	/* number of semaphores in set */
+  __UNATIVE_LONG_TYPE __unused3;
+  __UNATIVE_LONG_TYPE __unused4;
 };
 
 /* The user should define a union like the following to use it for arguments
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/shm.h b/sysdeps/unix/sysv/linux/x86_64/bits/shm.h
index 04f5cc5..6d09cdd 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/shm.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/shm.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2004, 2009
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2004, 2009, 2011
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -45,7 +45,7 @@ extern int __getpagesize (void) __THROW __attribute__ ((__const__));
 
 
 /* Type to count number of attaches.  */
-typedef unsigned long int shmatt_t;
+typedef __UNATIVE_LONG_TYPE shmatt_t;
 
 /* Data structure describing a shared memory segment.  */
 struct shmid_ds
@@ -53,22 +53,22 @@ struct shmid_ds
     struct ipc_perm shm_perm;		/* operation permission struct */
     size_t shm_segsz;			/* size of segment in bytes */
     __time_t shm_atime;			/* time of last shmat() */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
     unsigned long int __unused1;
 #endif
     __time_t shm_dtime;			/* time of last shmdt() */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
     unsigned long int __unused2;
 #endif
     __time_t shm_ctime;			/* time of last change by shmctl() */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
     unsigned long int __unused3;
 #endif
     __pid_t shm_cpid;			/* pid of creator */
     __pid_t shm_lpid;			/* pid of last shmop */
     shmatt_t shm_nattch;		/* number of current attaches */
-    unsigned long int __unused4;
-    unsigned long int __unused5;
+    __UNATIVE_LONG_TYPE __unused4;
+    __UNATIVE_LONG_TYPE __unused5;
   };
 
 #ifdef __USE_MISC
@@ -85,25 +85,25 @@ struct shmid_ds
 
 struct	shminfo
   {
-    unsigned long int shmmax;
-    unsigned long int shmmin;
-    unsigned long int shmmni;
-    unsigned long int shmseg;
-    unsigned long int shmall;
-    unsigned long int __unused1;
-    unsigned long int __unused2;
-    unsigned long int __unused3;
-    unsigned long int __unused4;
+    __UNATIVE_LONG_TYPE shmmax;
+    __UNATIVE_LONG_TYPE shmmin;
+    __UNATIVE_LONG_TYPE shmmni;
+    __UNATIVE_LONG_TYPE shmseg;
+    __UNATIVE_LONG_TYPE shmall;
+    __UNATIVE_LONG_TYPE __unused1;
+    __UNATIVE_LONG_TYPE __unused2;
+    __UNATIVE_LONG_TYPE __unused3;
+    __UNATIVE_LONG_TYPE __unused4;
   };
 
 struct shm_info
   {
     int used_ids;
-    unsigned long int shm_tot;	/* total allocated shm */
-    unsigned long int shm_rss;	/* total resident shm */
-    unsigned long int shm_swp;	/* total swapped shm */
-    unsigned long int swap_attempts;
-    unsigned long int swap_successes;
+    __UNATIVE_LONG_TYPE shm_tot;	/* total allocated shm */
+    __UNATIVE_LONG_TYPE shm_rss;	/* total resident shm */
+    __UNATIVE_LONG_TYPE shm_swp;	/* total swapped shm */
+    __UNATIVE_LONG_TYPE swap_attempts;
+    __UNATIVE_LONG_TYPE swap_successes;
   };
 
 #endif /* __USE_MISC */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h b/sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h
index c0d5fe7..f470b22 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h
@@ -23,8 +23,6 @@
 # error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
 #endif
 
-#include <bits/wordsize.h>
-
 struct _fpreg
 {
   unsigned short significand[4];
@@ -45,7 +43,7 @@ struct _xmmreg
 
 
 
-#if __WORDSIZE == 32
+#ifndef __x86_64__
 
 struct _fpstate
 {
@@ -104,7 +102,7 @@ struct sigcontext
   unsigned long cr2;
 };
 
-#else /* __WORDSIZE == 64 */
+#else /* __x86_64__ */
 
 struct _fpstate
 {
@@ -124,36 +122,39 @@ struct _fpstate
 
 struct sigcontext
 {
-  unsigned long r8;
-  unsigned long r9;
-  unsigned long r10;
-  unsigned long r11;
-  unsigned long r12;
-  unsigned long r13;
-  unsigned long r14;
-  unsigned long r15;
-  unsigned long rdi;
-  unsigned long rsi;
-  unsigned long rbp;
-  unsigned long rbx;
-  unsigned long rdx;
-  unsigned long rax;
-  unsigned long rcx;
-  unsigned long rsp;
-  unsigned long rip;
-  unsigned long eflags;
+  unsigned long long r8;
+  unsigned long long r9;
+  unsigned long long r10;
+  unsigned long long r11;
+  unsigned long long r12;
+  unsigned long long r13;
+  unsigned long long r14;
+  unsigned long long r15;
+  unsigned long long rdi;
+  unsigned long long rsi;
+  unsigned long long rbp;
+  unsigned long long rbx;
+  unsigned long long rdx;
+  unsigned long long rax;
+  unsigned long long rcx;
+  unsigned long long rsp;
+  unsigned long long rip;
+  unsigned long long eflags;
   unsigned short cs;
   unsigned short gs;
   unsigned short fs;
   unsigned short __pad0;
-  unsigned long err;
-  unsigned long trapno;
-  unsigned long oldmask;
-  unsigned long cr2;
+  unsigned long long err;
+  unsigned long long trapno;
+  unsigned long long oldmask;
+  unsigned long long cr2;
   struct _fpstate * fpstate;
-  unsigned long __reserved1 [8];
+#ifndef __LP64__
+  unsigned int pad0;
+#endif
+  unsigned long long __reserved1 [8];
 };
 
-#endif /* __WORDSIZE == 64 */
+#endif /* __x86_64__ */
 
 #endif /* _BITS_SIGCONTEXT_H */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/stat.h b/sysdeps/unix/sysv/linux/x86_64/bits/stat.h
index c7e4e1f..49dec53 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/stat.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/stat.h
@@ -26,7 +26,7 @@
 /* Versions of the `struct stat' data structure.  */
 #define _STAT_VER_KERNEL	0
 
-#if __WORDSIZE == 32
+#ifndef __x86_64__ 
 # define _STAT_VER_SVR4		2
 # define _STAT_VER_LINUX	3
 
@@ -46,37 +46,37 @@
 struct stat
   {
     __dev_t st_dev;		/* Device.  */
-#if __WORDSIZE == 32
+#ifndef __x86_64__ 
     unsigned short int __pad1;
 #endif
-#if __WORDSIZE == 64 || !defined __USE_FILE_OFFSET64
+#if defined __x86_64__ || !defined __USE_FILE_OFFSET64
     __ino_t st_ino;		/* File serial number.	*/
 #else
-    __ino_t __st_ino;			/* 32bit file serial number.	*/
+    __ino_t __st_ino;		/* 32bit file serial number.	*/
 #endif
-#if __WORDSIZE == 32
-    __mode_t st_mode;			/* File mode.  */
-    __nlink_t st_nlink;			/* Link count.  */
+#ifndef __x86_64__ 
+    __mode_t st_mode;		/* File mode.  */
+    __nlink_t st_nlink;		/* Link count.  */
 #else
     __nlink_t st_nlink;		/* Link count.  */
     __mode_t st_mode;		/* File mode.  */
 #endif
     __uid_t st_uid;		/* User ID of the file's owner.	*/
     __gid_t st_gid;		/* Group ID of the file's group.*/
-#if __WORDSIZE == 64
+#ifdef __x86_64__ 
     int __pad0;
 #endif
     __dev_t st_rdev;		/* Device number, if device.  */
-#if __WORDSIZE == 32
+#ifndef __x86_64__ 
     unsigned short int __pad2;
 #endif
-#if __WORDSIZE == 64 || !defined __USE_FILE_OFFSET64
+#if defined __x86_64__ || !defined __USE_FILE_OFFSET64
     __off_t st_size;			/* Size of file, in bytes.  */
 #else
     __off64_t st_size;			/* Size of file, in bytes.  */
 #endif
     __blksize_t st_blksize;	/* Optimal block size for I/O.  */
-#if __WORDSIZE == 64 || !defined __USE_FILE_OFFSET64
+#if defined __x86_64__  || !defined __USE_FILE_OFFSET64
     __blkcnt_t st_blocks;		/* Number 512-byte blocks allocated. */
 #else
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
@@ -96,14 +96,14 @@ struct stat
 # define st_ctime st_ctim.tv_sec
 #else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __UNATIVE_LONG_TYPE st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __UNATIVE_LONG_TYPE st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+    __UNATIVE_LONG_TYPE st_ctimensec;	/* Nsecs of last status change.  */
 #endif
-#if __WORDSIZE == 64
-    long int __unused[3];
+#ifdef __x86_64__ 
+    long long int __unused[3];
 #else
 # ifndef __USE_FILE_OFFSET64
     unsigned long int __unused4;
@@ -119,7 +119,7 @@ struct stat
 struct stat64
   {
     __dev_t st_dev;		/* Device.  */
-# if __WORDSIZE == 64
+# ifdef __x86_64__
     __ino64_t st_ino;		/* File serial number.  */
     __nlink_t st_nlink;		/* Link count.  */
     __mode_t st_mode;		/* File mode.  */
@@ -131,7 +131,7 @@ struct stat64
 # endif
     __uid_t st_uid;		/* User ID of the file's owner.	*/
     __gid_t st_gid;		/* Group ID of the file's group.*/
-# if __WORDSIZE == 64
+# ifdef __x86_64__
     int __pad0;
     __dev_t st_rdev;		/* Device number, if device.  */
     __off_t st_size;		/* Size of file, in bytes.  */
@@ -157,14 +157,14 @@ struct stat64
 #  define st_ctime st_ctim.tv_sec
 # else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __UNATIVE_LONG_TYPE st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __UNATIVE_LONG_TYPE st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+    __UNATIVE_LONG_TYPE st_ctimensec;	/* Nsecs of last status change.  */
 # endif
-# if __WORDSIZE == 64
-    long int __unused[3];
+# ifdef __x86_64__ 
+    long long int __unused[3];
 # else
     __ino64_t st_ino;			/* File serial number.		*/
 # endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/statfs.h b/sysdeps/unix/sysv/linux/x86_64/bits/statfs.h
new file mode 100644
index 0000000..2829607
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/statfs.h
@@ -0,0 +1,71 @@
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2010, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STATFS_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <bits/types.h>
+
+struct statfs
+  {
+    __SNATIVE_LONG_TYPE f_type;
+    __SNATIVE_LONG_TYPE f_bsize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+#endif
+    __fsid_t f_fsid;
+    __SNATIVE_LONG_TYPE f_namelen;
+    __SNATIVE_LONG_TYPE f_frsize;
+    __SNATIVE_LONG_TYPE f_flags;
+    __SNATIVE_LONG_TYPE f_spare[4];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+    __SNATIVE_LONG_TYPE f_type;
+    __SNATIVE_LONG_TYPE f_bsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsid_t f_fsid;
+    __SNATIVE_LONG_TYPE f_namelen;
+    __SNATIVE_LONG_TYPE f_frsize;
+    __SNATIVE_LONG_TYPE f_flags;
+    __SNATIVE_LONG_TYPE f_spare[4];
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define _STATFS_F_NAMELEN
+#define _STATFS_F_FRSIZE
+#define _STATFS_F_FLAGS
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/statvfs.h b/sysdeps/unix/sysv/linux/x86_64/bits/statvfs.h
new file mode 100644
index 0000000..a2769bd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/statvfs.h
@@ -0,0 +1,110 @@
+/* Copyright (C) 1997,1998,2000,2001,2002,2006,2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STATVFS_H
+# error "Never include <bits/statvfs.h> directly; use <sys/statvfs.h> instead."
+#endif
+
+#include <bits/types.h>  /* For __fsblkcnt_t and __fsfilcnt_t.  */
+
+#ifndef __x86_64__
+#define _STATVFSBUF_F_UNUSED
+#endif
+
+struct statvfs
+  {
+    unsigned long int f_bsize;
+    unsigned long int f_frsize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+    __fsfilcnt_t f_favail;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsfilcnt64_t f_favail;
+#endif
+    unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
+    int __f_unused;
+#endif
+    unsigned long int f_flag;
+    unsigned long int f_namemax;
+    int __f_spare[6];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statvfs64
+  {
+    unsigned long int f_bsize;
+    unsigned long int f_frsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsfilcnt64_t f_favail;
+    unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
+    int __f_unused;
+#endif
+    unsigned long int f_flag;
+    unsigned long int f_namemax;
+    int __f_spare[6];
+  };
+#endif
+
+/* Definitions for the flag in `f_flag'.  These definitions should be
+   kept in sync with the definitions in <sys/mount.h>.  */
+enum
+{
+  ST_RDONLY = 1,		/* Mount read-only.  */
+#define ST_RDONLY	ST_RDONLY
+  ST_NOSUID = 2			/* Ignore suid and sgid bits.  */
+#define ST_NOSUID	ST_NOSUID
+#ifdef __USE_GNU
+  ,
+  ST_NODEV = 4,			/* Disallow access to device special files.  */
+# define ST_NODEV	ST_NODEV
+  ST_NOEXEC = 8,		/* Disallow program execution.  */
+# define ST_NOEXEC	ST_NOEXEC
+  ST_SYNCHRONOUS = 16,		/* Writes are synced at once.  */
+# define ST_SYNCHRONOUS	ST_SYNCHRONOUS
+  ST_MANDLOCK = 64,		/* Allow mandatory locks on an FS.  */
+# define ST_MANDLOCK	ST_MANDLOCK
+  ST_WRITE = 128,		/* Write on file/directory/symlink.  */
+# define ST_WRITE	ST_WRITE
+  ST_APPEND = 256,		/* Append-only file.  */
+# define ST_APPEND	ST_APPEND
+  ST_IMMUTABLE = 512,		/* Immutable file.  */
+# define ST_IMMUTABLE	ST_IMMUTABLE
+  ST_NOATIME = 1024,		/* Do not update access times.  */
+# define ST_NOATIME	ST_NOATIME
+  ST_NODIRATIME = 2048,		/* Do not update directory access times.  */
+# define ST_NODIRATIME	ST_NODIRATIME
+  ST_RELATIME = 4096		/* Update atime relative to mtime/ctime.  */
+# define ST_RELATIME	ST_RELATIME
+#endif	/* Use GNU.  */
+};
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/timex.h b/sysdeps/unix/sysv/linux/x86_64/bits/timex.h
new file mode 100644
index 0000000..702a8c4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/timex.h
@@ -0,0 +1,128 @@
+/* Copyright (C) 1995-1997, 1999, 2007, 2009, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_BITS_TIMEX_H
+#define	_BITS_TIMEX_H	1
+
+/* These definitions from linux/timex.h as of 2.6.30.  */
+
+struct timex
+{
+  /* mode selector */
+  unsigned int modes;
+  /* time offset (usec) */
+  __SNATIVE_LONG_TYPE offset;
+  /* frequency offset (scaled ppm) */
+  __SNATIVE_LONG_TYPE freq;
+  /* maximum error (usec) */
+  __SNATIVE_LONG_TYPE maxerror;
+  /* estimated error (usec) */
+  __SNATIVE_LONG_TYPE esterror;
+  /* clock command/status */
+  int status;
+  /* pll time constant */
+  __SNATIVE_LONG_TYPE constant;
+  /* clock precision (usec) (read only) */
+  __SNATIVE_LONG_TYPE precision;
+  /* clock frequency tolerance (ppm) (read only) */
+  __SNATIVE_LONG_TYPE tolerance;
+  /* (read only) */
+  struct timeval time;
+  /* (modified) usecs between clock ticks */
+  __SNATIVE_LONG_TYPE tick;
+  /* pps frequency (scaled ppm) (ro) */
+  __SNATIVE_LONG_TYPE ppsfreq;
+  /* pps jitter (us) (ro) */
+  __SNATIVE_LONG_TYPE jitter;
+  /* interval duration (s) (shift) (ro) */
+  int shift;
+  /* pps stability (scaled ppm) (ro) */
+  __SNATIVE_LONG_TYPE stabil;
+  /* jitter limit exceeded (ro) */
+  __SNATIVE_LONG_TYPE jitcnt;
+  /* calibration intervals (ro) */
+  __SNATIVE_LONG_TYPE calcnt;
+  /* calibration errors (ro) */
+  __SNATIVE_LONG_TYPE errcnt;
+  /* stability limit exceeded (ro) */
+  __SNATIVE_LONG_TYPE stbcnt;
+
+  /* TAI offset (ro) */
+  int tai;
+
+  /* ??? */
+  int  :32; int  :32; int  :32; int  :32;
+  int  :32; int  :32; int  :32; int  :32;
+  int  :32; int  :32; int  :32;
+};
+
+/* Mode codes (timex.mode) */
+#define ADJ_OFFSET		0x0001	/* time offset */
+#define ADJ_FREQUENCY		0x0002	/* frequency offset */
+#define ADJ_MAXERROR		0x0004	/* maximum time error */
+#define ADJ_ESTERROR		0x0008	/* estimated time error */
+#define ADJ_STATUS		0x0010	/* clock status */
+#define ADJ_TIMECONST		0x0020	/* pll time constant */
+#define ADJ_TAI			0x0080	/* set TAI offset */
+#define ADJ_MICRO		0x1000	/* select microsecond resolution */
+#define ADJ_NANO		0x2000	/* select nanosecond resolution */
+#define ADJ_TICK		0x4000	/* tick value */
+#define ADJ_OFFSET_SINGLESHOT	0x8001	/* old-fashioned adjtime */
+#define ADJ_OFFSET_SS_READ	0xa001	/* read-only adjtime */
+
+/* xntp 3.4 compatibility names */
+#define MOD_OFFSET	ADJ_OFFSET
+#define MOD_FREQUENCY	ADJ_FREQUENCY
+#define MOD_MAXERROR	ADJ_MAXERROR
+#define MOD_ESTERROR	ADJ_ESTERROR
+#define MOD_STATUS	ADJ_STATUS
+#define MOD_TIMECONST	ADJ_TIMECONST
+#define MOD_CLKB	ADJ_TICK
+#define MOD_CLKA	ADJ_OFFSET_SINGLESHOT /* 0x8000 in original */
+#define MOD_TAI		ADJ_TAI
+#define MOD_MICRO	ADJ_MICRO
+#define MOD_NANO	ADJ_NANO
+
+
+/* Status codes (timex.status) */
+#define STA_PLL		0x0001	/* enable PLL updates (rw) */
+#define STA_PPSFREQ	0x0002	/* enable PPS freq discipline (rw) */
+#define STA_PPSTIME	0x0004	/* enable PPS time discipline (rw) */
+#define STA_FLL		0x0008	/* select frequency-lock mode (rw) */
+
+#define STA_INS		0x0010	/* insert leap (rw) */
+#define STA_DEL		0x0020	/* delete leap (rw) */
+#define STA_UNSYNC	0x0040	/* clock unsynchronized (rw) */
+#define STA_FREQHOLD	0x0080	/* hold frequency (rw) */
+
+#define STA_PPSSIGNAL	0x0100	/* PPS signal present (ro) */
+#define STA_PPSJITTER	0x0200	/* PPS signal jitter exceeded (ro) */
+#define STA_PPSWANDER	0x0400	/* PPS signal wander exceeded (ro) */
+#define STA_PPSERROR	0x0800	/* PPS signal calibration error (ro) */
+
+#define STA_CLOCKERR	0x1000	/* clock hardware fault (ro) */
+#define STA_NANO	0x2000	/* resolution (0 = us, 1 = ns) (ro) */
+#define STA_MODE	0x4000	/* mode (0 = PLL, 1 = FLL) (ro) */
+#define STA_CLK		0x8000	/* clock source (0 = A, 1 = B) (ro) */
+
+/* Read-only bits */
+#define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | \
+    STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
+
+#endif /* bits/timex.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h b/sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h
new file mode 100644
index 0000000..fa2be06
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h
@@ -0,0 +1,87 @@
+/* bits/typesizes.h -- underlying types for *_t.  X86_64 version.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+/* X32 kernel interface is 64bit.  */
+#if defined __x86_64__ && __WORDSIZE == 32
+#define __INO_T_TYPE		__UQUAD_TYPE
+#define __NLINK_T_TYPE		__UQUAD_TYPE
+#define __OFF_T_TYPE		__SQUAD_TYPE
+#define __RLIM_T_TYPE		__UQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__UQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__UQUAD_TYPE
+#define __TIME_T_TYPE		__SQUAD_TYPE
+#define __BLKSIZE_T_TYPE	__SQUAD_TYPE
+#define __SUSECONDS_T_TYPE	__SQUAD_TYPE
+#define __SNSECONDS_T_TYPE	__SQUAD_TYPE
+#define __SNATIVE_LONG_TYPE	__SQUAD_TYPE
+#define __UNATIVE_LONG_TYPE	__UQUAD_TYPE
+#else
+#define __INO_T_TYPE		__ULONGWORD_TYPE
+#define __NLINK_T_TYPE		__UWORD_TYPE
+#define __OFF_T_TYPE		__SLONGWORD_TYPE
+#define __RLIM_T_TYPE		__ULONGWORD_TYPE
+#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __SNATIVE_LONG_TYPE	__SLONGWORD_TYPE
+#define __UNATIVE_LONG_TYPE	__ULONGWORD_TYPE
+#endif
+
+#define __DEV_T_TYPE		__UQUAD_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U32_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM64_T_TYPE		__UQUAD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
+#define __KEY_T_TYPE		__S32_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		void *
+#define __FSID_T_TYPE		struct { int __val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/utmp.h b/sysdeps/unix/sysv/linux/x86_64/bits/utmp.h
new file mode 100644
index 0000000..3e18f17
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/utmp.h
@@ -0,0 +1,124 @@
+/* The `struct utmp' type, describing entries in the utmp file.  GNU version.
+   Copyright (C) 1993, 1996, 1997, 1998, 1999, 2002, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UTMP_H
+# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
+#endif
+
+#include <paths.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+
+#define UT_LINESIZE	32
+#define UT_NAMESIZE	32
+#define UT_HOSTSIZE	256
+
+
+/* The structure describing an entry in the database of
+   previous logins.  */
+struct lastlog
+  {
+#ifdef __x86_64__
+    int32_t ll_time;
+#else
+    __time_t ll_time;
+#endif
+    char ll_line[UT_LINESIZE];
+    char ll_host[UT_HOSTSIZE];
+  };
+
+
+/* The structure describing the status of a terminated process.  This
+   type is used in `struct utmp' below.  */
+struct exit_status
+  {
+    short int e_termination;	/* Process termination status.  */
+    short int e_exit;		/* Process exit status.  */
+  };
+
+
+/* The structure describing an entry in the user accounting database.  */
+struct utmp
+{
+  short int ut_type;		/* Type of login.  */
+  pid_t ut_pid;			/* Process ID of login process.  */
+  char ut_line[UT_LINESIZE];	/* Devicename.  */
+  char ut_id[4];		/* Inittab ID.  */
+  char ut_user[UT_NAMESIZE];	/* Username.  */
+  char ut_host[UT_HOSTSIZE];	/* Hostname for remote login.  */
+  struct exit_status ut_exit;	/* Exit status of a process marked
+				   as DEAD_PROCESS.  */
+/* The ut_session and ut_tv fields must be the same size when compiled
+   32- and 64-bit.  This allows data files and shared memory to be
+   shared between 32- and 64-bit applications.  */
+#ifdef __x86_64__
+  int32_t ut_session;		/* Session ID, used for windowing.  */
+  struct
+  {
+    int32_t tv_sec;		/* Seconds.  */
+    int32_t tv_usec;		/* Microseconds.  */
+  } ut_tv;			/* Time entry was made.  */
+#else
+  long int ut_session;		/* Session ID, used for windowing.  */
+  struct timeval ut_tv;		/* Time entry was made.  */
+#endif
+
+  int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
+  char __unused[20];		/* Reserved for future use.  */
+};
+
+/* Backwards compatibility hacks.  */
+#define ut_name		ut_user
+#ifndef _NO_UT_TIME
+/* We have a problem here: `ut_time' is also used otherwise.  Define
+   _NO_UT_TIME if the compiler complains.  */
+# define ut_time	ut_tv.tv_sec
+#endif
+#define ut_xtime	ut_tv.tv_sec
+#define ut_addr		ut_addr_v6[0]
+
+
+/* Values for the `ut_type' field of a `struct utmp'.  */
+#define EMPTY		0	/* No valid user accounting information.  */
+
+#define RUN_LVL		1	/* The system's runlevel.  */
+#define BOOT_TIME	2	/* Time of system boot.  */
+#define NEW_TIME	3	/* Time after system clock changed.  */
+#define OLD_TIME	4	/* Time when system clock changed.  */
+
+#define INIT_PROCESS	5	/* Process spawned by the init process.  */
+#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
+#define USER_PROCESS	7	/* Normal process.  */
+#define DEAD_PROCESS	8	/* Terminated process.  */
+
+#define ACCOUNTING	9
+
+/* Old Linux name for the EMPTY type.  */
+#define UT_UNKNOWN	EMPTY
+
+
+/* Tell the user that we have a modern system with UT_HOST, UT_PID,
+   UT_TYPE, UT_ID and UT_TV fields.  */
+#define _HAVE_UT_TYPE	1
+#define _HAVE_UT_PID	1
+#define _HAVE_UT_ID	1
+#define _HAVE_UT_TV	1
+#define _HAVE_UT_HOST	1
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h b/sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h
new file mode 100644
index 0000000..6972b91
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h
@@ -0,0 +1,103 @@
+/* Structures and definitions for the user accounting database.  GNU version.
+   Copyright (C) 1997, 1998, 2000, 2001, 2002, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UTMPX_H
+# error "Never include <bits/utmpx.h> directly; use <utmpx.h> instead."
+#endif
+
+#include <bits/types.h>
+#include <sys/time.h>
+
+
+#ifdef __USE_GNU
+# include <paths.h>
+# define _PATH_UTMPX	_PATH_UTMP
+# define _PATH_WTMPX	_PATH_WTMP
+#endif
+
+
+#define __UT_LINESIZE	32
+#define __UT_NAMESIZE	32
+#define __UT_HOSTSIZE	256
+
+
+/* The structure describing the status of a terminated process.  This
+   type is used in `struct utmpx' below.  */
+struct __exit_status
+  {
+#ifdef __USE_GNU
+    short int e_termination;	/* Process termination status.  */
+    short int e_exit;		/* Process exit status.  */
+#else
+    short int __e_termination;	/* Process termination status.  */
+    short int __e_exit;		/* Process exit status.  */
+#endif
+  };
+
+
+/* The structure describing an entry in the user accounting database.  */
+struct utmpx
+{
+  short int ut_type;		/* Type of login.  */
+  __pid_t ut_pid;		/* Process ID of login process.  */
+  char ut_line[__UT_LINESIZE];	/* Devicename.  */
+  char ut_id[4];		/* Inittab ID. */
+  char ut_user[__UT_NAMESIZE];	/* Username.  */
+  char ut_host[__UT_HOSTSIZE];	/* Hostname for remote login.  */
+  struct __exit_status ut_exit;	/* Exit status of a process marked
+				   as DEAD_PROCESS.  */
+
+/* The fields ut_session and ut_tv must be the same size when compiled
+   32- and 64-bit.  This allows files and shared memory to be shared
+   between 32- and 64-bit applications.  */
+#ifdef __x86_64__
+  __int32_t ut_session;		/* Session ID, used for windowing.  */
+  struct
+  {
+    __int32_t tv_sec;		/* Seconds.  */
+    __int32_t tv_usec;		/* Microseconds.  */
+  } ut_tv;			/* Time entry was made.  */
+#else
+  long int ut_session;		/* Session ID, used for windowing.  */
+  struct timeval ut_tv;		/* Time entry was made.  */
+#endif
+  __int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
+  char __unused[20];		/* Reserved for future use.  */
+};
+
+
+/* Values for the `ut_type' field of a `struct utmpx'.  */
+#define EMPTY		0	/* No valid user accounting information.  */
+
+#ifdef __USE_GNU
+# define RUN_LVL	1	/* The system's runlevel.  */
+#endif
+#define BOOT_TIME	2	/* Time of system boot.  */
+#define NEW_TIME	3	/* Time after system clock changed.  */
+#define OLD_TIME	4	/* Time when system clock changed.  */
+
+#define INIT_PROCESS	5	/* Process spawned by the init process.  */
+#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
+#define USER_PROCESS	7	/* Normal process.  */
+#define DEAD_PROCESS	8	/* Terminated process.  */
+
+#ifdef __USE_GNU
+# define ACCOUNTING	9	/* System accounting.  */
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/clone.S b/sysdeps/unix/sysv/linux/x86_64/clone.S
index db42f20..be8c6c6 100644
--- a/sysdeps/unix/sysv/linux/x86_64/clone.S
+++ b/sysdeps/unix/sysv/linux/x86_64/clone.S
@@ -73,7 +73,7 @@ ENTRY (BP_SYM (__clone))
 	movq	%rdx, %rdi
 	movq	%r8, %rdx
 	movq	%r9, %r8
-	movq	8(%rsp), %r10
+	mov	8(%rsp), %R10_LP
 	movl	$SYS_ify(clone),%eax
 
 	/* End FDE now, because in the child the unwind info will be
diff --git a/sysdeps/unix/sysv/linux/x86_64/dl-cache.h b/sysdeps/unix/sysv/linux/x86_64/dl-cache.h
index cb647ab..1f400eb 100644
--- a/sysdeps/unix/sysv/linux/x86_64/dl-cache.h
+++ b/sysdeps/unix/sysv/linux/x86_64/dl-cache.h
@@ -22,4 +22,31 @@
 #define _dl_cache_check_flags(flags)			\
   ((flags) == _DL_CACHE_DEFAULT_ID)
 
-#include <sysdeps/unix/sysv/linux/sparc/dl-cache.h>
+#define add_system_dir(dir) \
+  do								\
+    {								\
+      size_t len = strlen (dir);				\
+      char path[len + 4];					\
+      memcpy (path, dir, len + 1);				\
+      if (len >= 6 && ! memcmp (path + len - 6, "/lib64", 6))	\
+	{							\
+	  len -= 2;						\
+	  path[len] = '\0';					\
+	}							\
+      else if (len >= 7						\
+	       && ! memcmp (path + len - 7, "/libx32", 7))	\
+	{							\
+	  len -= 3;						\
+	  path[len] = '\0';					\
+	}							\
+      add_dir (path);						\
+      if (len >= 4 && ! memcmp (path + len - 4, "/lib", 4))	\
+	{							\
+	  memcpy (path + len, "64", 3);				\
+	  add_dir (path);					\
+	  memcpy (path + len, "x32", 4);				\
+	  add_dir (path);					\
+	}							\
+    } while (0)
+
+#include <sysdeps/generic/dl-cache.h>
diff --git a/sysdeps/unix/sysv/linux/x86_64/gettimeofday.S b/sysdeps/unix/sysv/linux/x86_64/gettimeofday.S
deleted file mode 100644
index f618e73..0000000
--- a/sysdeps/unix/sysv/linux/x86_64/gettimeofday.S
+++ /dev/null
@@ -1,49 +0,0 @@
-/* Copyright (C) 2002, 2003, 2007 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-
-/* For the calculation see asm/vsyscall.h.  */
-#define VSYSCALL_ADDR_vgettimeofday	0xffffffffff600000
-
-
-ENTRY (__gettimeofday)
-	/* Align stack.  */
-	sub	$0x8, %rsp
-	cfi_adjust_cfa_offset(8)
-#ifdef SHARED
-	movq	__vdso_gettimeofday(%rip), %rax
-	PTR_DEMANGLE (%rax)
-#else
-	movq	$VSYSCALL_ADDR_vgettimeofday, %rax
-#endif
-	callq	*%rax
-	/* Check error return.  */
-	cmpl	$-4095, %eax
-	jae	SYSCALL_ERROR_LABEL
-
-L(pseudo_end):
-	add	$0x8, %rsp
-	cfi_adjust_cfa_offset(-8)
-	ret
-PSEUDO_END(__gettimeofday)
-
-strong_alias (__gettimeofday, __gettimeofday_internal)
-weak_alias (__gettimeofday, gettimeofday)
diff --git a/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c b/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c
new file mode 100644
index 0000000..0b06133
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2002, 2003, 2007, 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <dl-vdso.h>
+
+#ifdef SHARED
+void *gettimeofday_ifunc (void) __asm__ ("__gettimeofday");
+
+void *
+gettimeofday_ifunc (void)
+{
+  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
+
+  /* If the vDSO is not available we fall back on the old vsyscall.  */
+  return (_dl_vdso_vsym ("gettimeofday", &linux26)
+	  ?: (void *) VSYSCALL_ADDR_vgettimeofday);
+}
+__asm (".type __gettimeofday, %gnu_indirect_function");
+#else
+# include <sys/time.h>
+# include <sysdep.h>
+# include <errno.h>
+
+int
+__gettimeofday (struct timeval *tv, struct timezone *tz)
+{
+  return INLINE_SYSCALL (gettimeofday, 2, tv, tz);
+}
+#endif
+
+weak_alias (__gettimeofday, gettimeofday)
+strong_alias (__gettimeofday, __gettimeofday_internal)
diff --git a/sysdeps/unix/sysv/linux/x86_64/init-first.c b/sysdeps/unix/sysv/linux/x86_64/init-first.c
index e676f62..ac977a8 100644
--- a/sysdeps/unix/sysv/linux/x86_64/init-first.c
+++ b/sysdeps/unix/sysv/linux/x86_64/init-first.c
@@ -20,15 +20,11 @@
 # include <dl-vdso.h>
 # include <bits/libc-vdso.h>
 
-long int (*__vdso_gettimeofday) (struct timeval *, void *) attribute_hidden;
-
 long int (*__vdso_clock_gettime) (clockid_t, struct timespec *)
   __attribute__ ((nocommon));
 strong_alias (__vdso_clock_gettime, __GI___vdso_clock_gettime attribute_hidden)
 
-long int (*__vdso_getcpu) (unsigned *, unsigned *, void *);
-
-long int (*__vdso_time) (time_t *) attribute_hidden;
+long int (*__vdso_getcpu) (unsigned *, unsigned *, void *) attribute_hidden;
 
 
 static inline void
@@ -36,33 +32,16 @@ _libc_vdso_platform_setup (void)
 {
   PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
 
-  void *p = _dl_vdso_vsym ("gettimeofday", &linux26);
-  /* If the vDSO is not available we fall back on the old vsyscall.  */
-#define VSYSCALL_ADDR_vgettimeofday	0xffffffffff600000ul
-  if (p == NULL)
-    p = (void *) VSYSCALL_ADDR_vgettimeofday;
-  PTR_MANGLE (p);
-  __vdso_gettimeofday = p;
-
-  p = _dl_vdso_vsym ("clock_gettime", &linux26);
+  void *p = _dl_vdso_vsym ("clock_gettime", &linux26);
   PTR_MANGLE (p);
   __GI___vdso_clock_gettime = p;
 
   p = _dl_vdso_vsym ("getcpu", &linux26);
   /* If the vDSO is not available we fall back on the old vsyscall.  */
-#define VSYSCALL_ADDR_vgetcpu	0xffffffffff600800
   if (p == NULL)
     p = (void *) VSYSCALL_ADDR_vgetcpu;
   PTR_MANGLE (p);
   __vdso_getcpu = p;
-
-  p = _dl_vdso_vsym ("time", &linux26);
-  /* If the vDSO is not available we fall back on the old vsyscall.  */
-#define VSYSCALL_ADDR_vtime	0xffffffffff600400
-  if (p == NULL)
-    p = (void *) VSYSCALL_ADDR_vtime;
-  PTR_MANGLE (p);
-  __vdso_time = p;
 }
 
 # define VDSO_SETUP _libc_vdso_platform_setup
diff --git a/sysdeps/unix/sysv/linux/x86_64/ldconfig.h b/sysdeps/unix/sysv/linux/x86_64/ldconfig.h
index f7f64eb..69f77dd 100644
--- a/sysdeps/unix/sysv/linux/x86_64/ldconfig.h
+++ b/sysdeps/unix/sysv/linux/x86_64/ldconfig.h
@@ -20,6 +20,7 @@
 
 #define SYSDEP_KNOWN_INTERPRETER_NAMES \
   { "/lib/ld-linux.so.2", FLAG_ELF_LIBC6 }, \
+  { "/libx32/ld-linux-x32.so.2", FLAG_ELF_LIBC6 }, \
   { "/lib64/ld-linux-x86-64.so.2", FLAG_ELF_LIBC6 },
 #define SYSDEP_KNOWN_LIBRARY_NAMES \
   { "libc.so.6", FLAG_ELF_LIBC6 },	\
diff --git a/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed b/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
index 3f1530d..44d76e8 100644
--- a/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
+++ b/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
@@ -1,3 +1,3 @@
 /LD_TRACE_LOADED_OBJECTS=1/a\
 add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
-s_^\(RTLDLIST=\)\(.*lib\)\(\|64\)\(/[^/]*\)\(-x86-64\)\(\.so\.[0-9.]*\)[ 	]*$_\1"\2\4\6 \264\4\5\6"_
+s_^\(RTLDLIST=\)\(.*lib\)\(\|64\|x32\)\(/[^/]*\)\(-x86-64\|-x32\)\(\.so\.[0-9.]*\)[ 	]*$_\1"\2\4\6 \264\4-x86-64\6 \2x32\4-x32\6"_
diff --git a/sysdeps/unix/sysv/linux/x86_64/makecontext.c b/sysdeps/unix/sysv/linux/x86_64/makecontext.c
index 615dede..477d22e 100644
--- a/sysdeps/unix/sysv/linux/x86_64/makecontext.c
+++ b/sysdeps/unix/sysv/linux/x86_64/makecontext.c
@@ -53,25 +53,26 @@ void
 __makecontext (ucontext_t *ucp, void (*func) (void), int argc, ...)
 {
   extern void __start_context (void);
-  unsigned long int *sp, idx_uc_link;
+  unsigned long long int *sp;
+  unsigned int idx_uc_link;
   va_list ap;
   int i;
 
   /* Generate room on stack for parameter if needed and uc_link.  */
-  sp = (unsigned long int *) ((uintptr_t) ucp->uc_stack.ss_sp
-			      + ucp->uc_stack.ss_size);
+  sp = (unsigned long long int *) ((uintptr_t) ucp->uc_stack.ss_sp
+				   + ucp->uc_stack.ss_size);
   sp -= (argc > 6 ? argc - 6 : 0) + 1;
   /* Align stack and make space for trampoline address.  */
-  sp = (unsigned long int *) ((((uintptr_t) sp) & -16L) - 8);
+  sp = (unsigned long long int *) ((((uintptr_t) sp) & -16L) - 8);
 
   idx_uc_link = (argc > 6 ? argc - 6 : 0) + 1;
 
   /* Setup context ucp.  */
   /* Address to jump to.  */
-  ucp->uc_mcontext.gregs[REG_RIP] = (long int) func;
+  ucp->uc_mcontext.gregs[REG_RIP] = (unsigned long int) func;
   /* Setup rbx.*/
-  ucp->uc_mcontext.gregs[REG_RBX] = (long int) &sp[idx_uc_link];
-  ucp->uc_mcontext.gregs[REG_RSP] = (long int) sp;
+  ucp->uc_mcontext.gregs[REG_RBX] = (unsigned long int) &sp[idx_uc_link];
+  ucp->uc_mcontext.gregs[REG_RSP] = (unsigned long int) sp;
 
   /* Setup stack.  */
   sp[0] = (unsigned long int) &__start_context;
@@ -91,26 +92,26 @@ __makecontext (ucontext_t *ucp, void (*func) (void), int argc, ...)
     switch (i)
       {
       case 0:
-	ucp->uc_mcontext.gregs[REG_RDI] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_RDI] = va_arg (ap, long long int);
 	break;
       case 1:
-	ucp->uc_mcontext.gregs[REG_RSI] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_RSI] = va_arg (ap, long long int);
 	break;
       case 2:
-	ucp->uc_mcontext.gregs[REG_RDX] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_RDX] = va_arg (ap, long long int);
 	break;
       case 3:
-	ucp->uc_mcontext.gregs[REG_RCX] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_RCX] = va_arg (ap, long long int);
 	break;
       case 4:
-	ucp->uc_mcontext.gregs[REG_R8] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_R8] = va_arg (ap, long long int);
 	break;
       case 5:
-	ucp->uc_mcontext.gregs[REG_R9] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_R9] = va_arg (ap, long long int);
 	break;
       default:
 	/* Put value on stack.  */
-	sp[i - 5] = va_arg (ap, unsigned long int);
+	sp[i - 5] = va_arg (ap, unsigned long long int);
 	break;
       }
   va_end (ap);
diff --git a/sysdeps/unix/sysv/linux/x86_64/readelflib.c b/sysdeps/unix/sysv/linux/x86_64/readelflib.c
index 5a49af3..65d3ed7 100644
--- a/sysdeps/unix/sysv/linux/x86_64/readelflib.c
+++ b/sysdeps/unix/sysv/linux/x86_64/readelflib.c
@@ -36,8 +36,18 @@ process_elf_file (const char *file_name, const char *lib, int *flag,
   int ret;
 
   if (elf_header->e_ident [EI_CLASS] == ELFCLASS32)
-    return process_elf32_file (file_name, lib, flag, osversion, soname,
-			       file_contents, file_length);
+    {
+      ret = process_elf32_file (file_name, lib, flag, osversion, soname,
+				file_contents, file_length);
+      /* X32 libraries are always libc.so.6+.  */
+      if (!ret)
+	switch (elf_header->e_machine)
+	  {
+	  case EM_X86_64:
+	    *flag = FLAG_X8664_LIBX32|FLAG_ELF_LIBC6;
+	    break;
+	  }
+    }
   else
     {
       ret = process_elf64_file (file_name, lib, flag, osversion, soname,
diff --git a/sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S b/sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S
index 8ec7d3f..2053bfd 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S
+++ b/sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S
@@ -20,10 +20,7 @@
 #include <tls.h>
 #define _ERRNO_H	1
 #include <bits/errno.h>
-
-/* For the calculation see asm/vsyscall.h.  */
-#define VSYSCALL_ADDR_vgetcpu	0xffffffffff600800
-
+#include <kernel-features.h>
 
 ENTRY (sched_getcpu)
 	/* Align stack and create local variable for result.  */
@@ -38,10 +35,26 @@ ENTRY (sched_getcpu)
 #ifdef SHARED
 	movq	__vdso_getcpu(%rip), %rax
 	PTR_DEMANGLE (%rax)
+	callq	*%rax
 #else
+# ifdef __NR_getcpu
+	movl	$__NR_getcpu, %eax
+	syscall
+#  ifndef __ASSUME_GETCPU_SYSCALL
+	cmpq	$-ENOSYS, %rax
+	jne	1f
+#  endif
+# endif
+# ifndef __ASSUME_GETCPU_SYSCALL
 	movq	$VSYSCALL_ADDR_vgetcpu, %rax
-#endif
 	callq	*%rax
+1:
+# else
+#  ifndef __NR_getcpu
+#   error "cannot happen"
+#  endif
+# endif
+#endif
 
 	cmpq	$-4095, %rax
 	jae	SYSCALL_ERROR_LABEL
diff --git a/sysdeps/unix/sysv/linux/x86_64/sigaction.c b/sysdeps/unix/sysv/linux/x86_64/sigaction.c
index ab10123..a97e072 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sigaction.c
+++ b/sysdeps/unix/sysv/linux/x86_64/sigaction.c
@@ -147,7 +147,7 @@ asm									\
    ".LSTARTAUGMNT_" #name ":\n"						\
    "	.byte 0x1b\n"	/* DW_EH_PE_pcrel|DW_EH_PE_sdata4. */		\
    ".LENDAUGMNT_" #name ":\n"						\
-   "	.align 8\n"							\
+   "	.align " LP_SIZE "\n"						\
    ".LENDCIE_" #name ":\n"						\
    "	.long .LENDFDE_" #name "-.LSTARTFDE_" #name "\n" /* FDE len */	\
    ".LSTARTFDE_" #name ":\n"						\
@@ -178,7 +178,7 @@ asm									\
    /* do_expr (49 |* rflags *|, oEFL) */				\
    /* `cs'/`ds'/`fs' are unaligned and a different size.  */		\
    /* gas: Error: register save offset not a multiple of 8  */		\
-   "	.align 8\n"							\
+   "	.align " LP_SIZE "\n"						\
    ".LENDFDE_" #name ":\n"						\
    "	.previous\n"							\
    );
diff --git a/sysdeps/unix/sysv/linux/x86_64/sigaltstack.sym b/sysdeps/unix/sysv/linux/x86_64/sigaltstack.sym
new file mode 100644
index 0000000..9fd26fe
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/sigaltstack.sym
@@ -0,0 +1,15 @@
+#ifndef _XOPEN_EXTENDED
+# define _XOPEN_EXTENDED
+#endif
+
+#include <stddef.h>
+#include <signal.h>
+
+--
+
+#define sigaltstack(member)	offsetof (stack_t, member)
+
+sizeSS				sizeof(stack_t)
+oSS_SP				sigaltstack(ss_sp)
+oSS_SIZE			sigaltstack(ss_size)
+oSS_FLAGS			sigaltstack(ss_flags)
diff --git a/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h b/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h
index 11493c5..78c9aa7 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h
@@ -16,11 +16,16 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <stdint.h>
+
 #define SIGCONTEXT siginfo_t *_si, struct ucontext *
 #define SIGCONTEXT_EXTRA_ARGS _si,
-#define GET_PC(ctx)	((void *) (ctx)->uc_mcontext.gregs[REG_RIP])
-#define GET_FRAME(ctx)	((void *) (ctx)->uc_mcontext.gregs[REG_RBP])
-#define GET_STACK(ctx)	((void *) (ctx)->uc_mcontext.gregs[REG_RSP])
+#define GET_PC(ctx)	\
+  ((void *) (uintptr_t) (ctx)->uc_mcontext.gregs[REG_RIP])
+#define GET_FRAME(ctx)	\
+  ((void *) (uintptr_t) (ctx)->uc_mcontext.gregs[REG_RBP])
+#define GET_STACK(ctx)	\
+  ((void *) (uintptr_t) (ctx)->uc_mcontext.gregs[REG_RSP])
 
 #define CALL_SIGHANDLER(handler, signo, ctx) \
   (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h b/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
index 8abbf75..c3adbdf 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
@@ -18,7 +18,6 @@
 
 #ifndef _SYS_DEBUGREG_H
 #define _SYS_DEBUGREG_H	1
-#include <bits/wordsize.h>
 
 /* Indicate the register numbers for a number of the specific
    debug registers.  Registers 0-3 contain the addresses we wish to trap on */
@@ -77,8 +76,8 @@
 
 
 
-#if __WORDSIZE == 64
-# define DR_CONTROL_RESERVED (0xFFFFFFFF0000FC00UL) /* Reserved */
+#ifdef __x86_64__
+# define DR_CONTROL_RESERVED (0xFFFFFFFF0000FC00ULL) /* Reserved */
 #else
 # define DR_CONTROL_RESERVED (0x00FC00U) /* Reserved */
 #endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/msg.h b/sysdeps/unix/sysv/linux/x86_64/sys/msg.h
new file mode 100644
index 0000000..b59b3a0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/msg.h
@@ -0,0 +1,85 @@
+/* Copyright (C) 1995-1997, 1999, 2000, 2003, 2006, 2007, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MSG_H
+#define _SYS_MSG_H
+
+#include <features.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+/* Get common definition of System V style IPC.  */
+#include <sys/ipc.h>
+
+/* Get system dependent definition of `struct msqid_ds' and more.  */
+#include <bits/msq.h>
+
+/* Define types required by the standard.  */
+#define	__need_time_t
+#include <time.h>
+
+#ifndef __pid_t_defined
+typedef __pid_t pid_t;
+# define __pid_t_defined
+#endif
+
+#ifndef __ssize_t_defined
+typedef __ssize_t ssize_t;
+# define __ssize_t_defined
+#endif
+
+/* The following System V style IPC functions implement a message queue
+   system.  The definition is found in XPG2.  */
+
+#ifdef __USE_GNU
+/* Template for struct to be used as argument for `msgsnd' and `msgrcv'.  */
+struct msgbuf
+  {
+    __SNATIVE_LONG_TYPE mtype;	/* type of received/sent message */
+    char mtext[1];		/* text of the message */
+  };
+#endif
+
+
+__BEGIN_DECLS
+
+/* Message queue control operation.  */
+extern int msgctl (int __msqid, int __cmd, struct msqid_ds *__buf) __THROW;
+
+/* Get messages queue.  */
+extern int msgget (key_t __key, int __msgflg) __THROW;
+
+/* Receive message from message queue.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t msgrcv (int __msqid, void *__msgp, size_t __msgsz,
+		       long int __msgtyp, int __msgflg);
+
+/* Send message to message queue.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int msgsnd (int __msqid, __const void *__msgp, size_t __msgsz,
+		   int __msgflg);
+
+__END_DECLS
+
+#endif /* sys/msg.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h b/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h
index 853d7db..80c6cfb 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h
@@ -36,7 +36,11 @@
 __BEGIN_DECLS
 
 /* Type for a general-purpose register.  */
+#ifdef __x86_64__
+typedef unsigned long long elf_greg_t;
+#else
 typedef unsigned long elf_greg_t;
+#endif
 
 /* And the whole bunch of them.  We could have used `struct
    user_regs_struct' directly in the typedef, but tradition says that
@@ -45,7 +49,7 @@ typedef unsigned long elf_greg_t;
 #define ELF_NGREG (sizeof (struct user_regs_struct) / sizeof(elf_greg_t))
 typedef elf_greg_t elf_gregset_t[ELF_NGREG];
 
-#if __WORDSIZE == 32
+#ifndef __x86_64__
 /* Register set for the floating-point registers.  */
 typedef struct user_fpregs_struct elf_fpregset_t;
 
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/reg.h b/sysdeps/unix/sysv/linux/x86_64/sys/reg.h
index acb71a2..0772bc7 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sys/reg.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/reg.h
@@ -18,10 +18,9 @@
 
 #ifndef _SYS_REG_H
 #define _SYS_REG_H	1
-#include <bits/wordsize.h>
 
 
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 /* Index into an array of 8 byte longs returned from ptrace for
    location of the users' stored general purpose registers.  */
 
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h b/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h
index b59cd29..5bc8f0e 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h
@@ -21,16 +21,15 @@
 
 #include <features.h>
 #include <signal.h>
-#include <bits/wordsize.h>
 
 /* We need the signal context definitions even if they are not used
    included in <signal.h>.  */
 #include <bits/sigcontext.h>
 
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 
 /* Type for general register.  */
-typedef long int greg_t;
+typedef long long int greg_t;
 
 /* Number of general registers.  */
 #define NGREG	23
@@ -128,13 +127,13 @@ typedef struct
     gregset_t gregs;
     /* Note that fpregs is a pointer.  */
     fpregset_t fpregs;
-    unsigned long __reserved1 [8];
+    unsigned long long __reserved1 [8];
 } mcontext_t;
 
 /* Userlevel context.  */
 typedef struct ucontext
   {
-    unsigned long int uc_flags;
+    unsigned long long int uc_flags;
     struct ucontext *uc_link;
     stack_t uc_stack;
     mcontext_t uc_mcontext;
@@ -142,7 +141,7 @@ typedef struct ucontext
     struct _libc_fpstate __fpregs_mem;
   } ucontext_t;
 
-#else /* __WORDSIZE == 32 */
+#else /* !__x86_64__ */
 
 /* Type for general register.  */
 typedef int greg_t;
@@ -243,6 +242,6 @@ typedef struct ucontext
     struct _libc_fpstate __fpregs_mem;
   } ucontext_t;
 
-#endif /* __WORDSIZE == 32 */
+#endif /* !__x86_64__ */
 
 #endif /* sys/ucontext.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/user.h b/sysdeps/unix/sysv/linux/x86_64/sys/user.h
index e4423cf..d09a420 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sys/user.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/user.h
@@ -23,9 +23,7 @@
    too much into it.  Don't use it for anything other than GDB unless
    you know what you are doing.  */
 
-#include <bits/wordsize.h>
-
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 
 struct user_fpregs_struct
 {
@@ -33,8 +31,8 @@ struct user_fpregs_struct
   unsigned short int	swd;
   unsigned short int	ftw;
   unsigned short int	fop;
-  unsigned long int	rip;
-  unsigned long int	rdp;
+  unsigned long long int rip;
+  unsigned long long int rdp;
   unsigned int		mxcsr;
   unsigned int		mxcr_mask;
   unsigned int		st_space[32];   /* 8*16 bytes for each FP-reg = 128 bytes */
@@ -44,33 +42,33 @@ struct user_fpregs_struct
 
 struct user_regs_struct
 {
-  unsigned long int r15;
-  unsigned long int r14;
-  unsigned long int r13;
-  unsigned long int r12;
-  unsigned long int rbp;
-  unsigned long int rbx;
-  unsigned long int r11;
-  unsigned long int r10;
-  unsigned long int r9;
-  unsigned long int r8;
-  unsigned long int rax;
-  unsigned long int rcx;
-  unsigned long int rdx;
-  unsigned long int rsi;
-  unsigned long int rdi;
-  unsigned long int orig_rax;
-  unsigned long int rip;
-  unsigned long int cs;
-  unsigned long int eflags;
-  unsigned long int rsp;
-  unsigned long int ss;
-  unsigned long int fs_base;
-  unsigned long int gs_base;
-  unsigned long int ds;
-  unsigned long int es;
-  unsigned long int fs;
-  unsigned long int gs;
+  unsigned long long int r15;
+  unsigned long long int r14;
+  unsigned long long int r13;
+  unsigned long long int r12;
+  unsigned long long int rbp;
+  unsigned long long int rbx;
+  unsigned long long int r11;
+  unsigned long long int r10;
+  unsigned long long int r9;
+  unsigned long long int r8;
+  unsigned long long int rax;
+  unsigned long long int rcx;
+  unsigned long long int rdx;
+  unsigned long long int rsi;
+  unsigned long long int rdi;
+  unsigned long long int orig_rax;
+  unsigned long long int rip;
+  unsigned long long int cs;
+  unsigned long long int eflags;
+  unsigned long long int rsp;
+  unsigned long long int ss;
+  unsigned long long int fs_base;
+  unsigned long long int gs_base;
+  unsigned long long int ds;
+  unsigned long long int es;
+  unsigned long long int fs;
+  unsigned long long int gs;
 };
 
 struct user
@@ -78,18 +76,24 @@ struct user
   struct user_regs_struct	regs;
   int				u_fpvalid;
   struct user_fpregs_struct	i387;
-  unsigned long int		u_tsize;
-  unsigned long int		u_dsize;
-  unsigned long int		u_ssize;
-  unsigned long int		start_code;
-  unsigned long int		start_stack;
-  long int			signal;
+  unsigned long long int	u_tsize;
+  unsigned long long int	u_dsize;
+  unsigned long long int	u_ssize;
+  unsigned long long int	start_code;
+  unsigned long long int	start_stack;
+  long long int			signal;
   int				reserved;
   struct user_regs_struct*	u_ar0;
+#ifndef __LP64__
+  unsigned int			pad0;
+#endif
   struct user_fpregs_struct*	u_fpstate;
-  unsigned long int		magic;
+#ifndef __LP64__
+  unsigned int			pad1;
+#endif
+  unsigned long long int	magic;
   char				u_comm [32];
-  unsigned long int		u_debugreg [8];
+  unsigned long long int	u_debugreg [8];
 };
 
 #else
@@ -162,7 +166,7 @@ struct user
   char				u_comm [32];
   int				u_debugreg [8];
 };
-#endif  /* __WORDSIZE */
+#endif  /* __x86_64__ */
 
 #define PAGE_SHIFT		12
 #define PAGE_SIZE		(1UL << PAGE_SHIFT)
diff --git a/sysdeps/unix/sysv/linux/x86_64/sysdep.h b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
index 2b9ea85..376a98e 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sysdep.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
@@ -218,6 +218,11 @@
 # define DOARGS_5 DOARGS_4
 # define DOARGS_6 DOARGS_5
 
+/* For the calculation see asm/vsyscall.h.  */
+# define VSYSCALL_ADDR_vgettimeofday	0xffffffffff600000
+# define VSYSCALL_ADDR_vtime		0xffffffffff600400
+# define VSYSCALL_ADDR_vgetcpu		0xffffffffff600800
+
 #else	/* !__ASSEMBLER__ */
 /* Define a macro which expands inline into the wrapper code for a system
    call.  */
@@ -366,6 +371,11 @@
   LOAD_REGS_5
 # define ASM_ARGS_6	ASM_ARGS_5, "r" (_a6)
 
+/* For the calculation see asm/vsyscall.h.  */
+# define VSYSCALL_ADDR_vgettimeofday	0xffffffffff600000ul
+# define VSYSCALL_ADDR_vgetcpu		0xffffffffff600800ul
+# define VSYSCALL_ADDR_vtime		0xffffffffff600400ul
+
 #endif	/* __ASSEMBLER__ */
 
 
diff --git a/sysdeps/unix/sysv/linux/x86_64/time.S b/sysdeps/unix/sysv/linux/x86_64/time.S
deleted file mode 100644
index 66d7498..0000000
--- a/sysdeps/unix/sysv/linux/x86_64/time.S
+++ /dev/null
@@ -1,47 +0,0 @@
-/* Copyright (C) 2001,02, 2003, 2011 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#include <sysdep.h>
-#define _ERRNO_H	1
-#include <bits/errno.h>
-
-/* For the calculation see asm/vsyscall.h.  */
-#define VSYSCALL_ADDR_vtime	0xffffffffff600400
-
-
-/* Return the current time as a `time_t' and also put it in *T if T is
-   not NULL.  Time is represented as seconds from Jan 1 00:00:00 1970.  */
-
-ENTRY (time)
-	/* Align stack.  */
-	sub	$0x8, %rsp
-	cfi_adjust_cfa_offset(8)
-
-#ifdef SHARED
-	movq	__vdso_time(%rip), %rax
-	PTR_DEMANGLE (%rax)
-#else
-	movq	$VSYSCALL_ADDR_vtime, %rax
-#endif
-	callq	*%rax
-
-	add	$0x8, %rsp
-	cfi_adjust_cfa_offset(-8)
-	ret
-PSEUDO_END_NOERRNO(time)
-libc_hidden_def (time)
diff --git a/sysdeps/unix/sysv/linux/x86_64/time.c b/sysdeps/unix/sysv/linux/x86_64/time.c
new file mode 100644
index 0000000..7b4a0c8
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/time.c
@@ -0,0 +1,48 @@
+/* Copyright (C) 2001,02,2003,2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef SHARED
+#include <dl-vdso.h>
+
+void *time_ifunc (void) __asm__ ("time");
+
+void *
+time_ifunc (void)
+{
+  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
+
+  /* If the vDSO is not available we fall back on the old vsyscall.  */
+  return _dl_vdso_vsym ("time", &linux26) ?: (void *) VSYSCALL_ADDR_vtime;
+}
+__asm (".type time, %gnu_indirect_function");
+
+#else
+
+# include <time.h>
+# include <sysdep.h>
+
+time_t
+time (time_t *t)
+{
+  INTERNAL_SYSCALL_DECL (err);
+  return INTERNAL_SYSCALL (time, err, 1, t);
+}
+
+#endif
+
+strong_alias (time, __GI_time)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/Implies b/sysdeps/unix/sysv/linux/x86_64/x32/Implies
new file mode 100644
index 0000000..8d91c80
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/Implies
@@ -0,0 +1 @@
+unix/sysv/linux/wordsize-64
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/Makefile b/sysdeps/unix/sysv/linux/x86_64/x32/Makefile
new file mode 100644
index 0000000..5f77df7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(subdir),posix)
+sysdep_routines += getcpu sched_getcpu-static
+endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/alphasort.c b/sysdeps/unix/sysv/linux/x86_64/x32/alphasort.c
new file mode 100644
index 0000000..69ec427
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/alphasort.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/alphasort.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/alphasort64.c b/sysdeps/unix/sysv/linux/x86_64/x32/alphasort64.c
new file mode 100644
index 0000000..6c5b2a1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/alphasort64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/alphasort64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/dl-cache.h b/sysdeps/unix/sysv/linux/x86_64/x32/dl-cache.h
new file mode 100644
index 0000000..22a56d7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/dl-cache.h
@@ -0,0 +1,23 @@
+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
+   Copyright (C) 20011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/unix/sysv/linux/x86_64/dl-cache.h>
+
+#undef _DL_CACHE_DEFAULT_ID
+#define _DL_CACHE_DEFAULT_ID	0x803
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/fallocate.c b/sysdeps/unix/sysv/linux/x86_64/x32/fallocate.c
new file mode 100644
index 0000000..3b849d5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/fallocate.c
@@ -0,0 +1,56 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+#undef LOAD_ARGS_3
+#define LOAD_ARGS_3(a1, a2, a3)				\
+  long long int __arg3 = (long long int) (a3);		\
+  LOAD_ARGS_2 (a1, a2)
+#undef LOAD_REGS_3
+#define LOAD_REGS_3					\
+  register long long int _a3 asm ("rdx") = __arg3;	\
+  LOAD_REGS_2
+
+#undef LOAD_ARGS_4
+#define LOAD_ARGS_4(a1, a2, a3, a4)			\
+  long long int __arg4 = (long long int) (a4);		\
+  LOAD_ARGS_3 (a1, a2, a3)
+#undef LOAD_REGS_4
+#define LOAD_REGS_4					\
+  register long long int _a4 asm ("r10") = __arg4;	\
+  LOAD_REGS_3
+
+/* Reserve storage for the data of the file associated with FD.  */
+int
+fallocate (int fd, int mode, __off_t offset, __off_t len)
+{
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (fallocate, 4, fd, mode, offset, len);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (fallocate, 4, fd, mode, offset, len);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+strong_alias (fallocate, fallocate64)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/fseeko.c b/sysdeps/unix/sysv/linux/x86_64/x32/fseeko.c
new file mode 100644
index 0000000..dc47698
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/fseeko.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/fseeko.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/fseeko64.c b/sysdeps/unix/sysv/linux/x86_64/x32/fseeko64.c
new file mode 100644
index 0000000..3e554ec
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/fseeko64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/fseeko64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/ftello.c b/sysdeps/unix/sysv/linux/x86_64/x32/ftello.c
new file mode 100644
index 0000000..735e3e1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/ftello.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/ftello.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/ftello64.c b/sysdeps/unix/sysv/linux/x86_64/x32/ftello64.c
new file mode 100644
index 0000000..eb155ed
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/ftello64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/ftello64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/ftw.c b/sysdeps/unix/sysv/linux/x86_64/x32/ftw.c
new file mode 100644
index 0000000..a21dfe5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/ftw.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/ftw.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/ftw64.c b/sysdeps/unix/sysv/linux/x86_64/x32/ftw64.c
new file mode 100644
index 0000000..3c025b7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/ftw64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/ftw64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/getcpu.c b/sysdeps/unix/sysv/linux/x86_64/x32/getcpu.c
new file mode 100644
index 0000000..f00cdff
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/getcpu.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef SHARED
+# include <dl-vdso.h>
+
+void *getcpu_ifunc (void) __asm__ ("__getcpu");
+
+void *
+getcpu_ifunc (void)
+{
+  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
+
+  return _dl_vdso_vsym ("getcpu", &linux26);
+}
+__asm (".type __getcpu, %gnu_indirect_function");
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/getdents.c b/sysdeps/unix/sysv/linux/x86_64/x32/getdents.c
new file mode 100644
index 0000000..7634853
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/getdents.c
@@ -0,0 +1,161 @@
+/* Copyright (C) 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <alloca.h>
+#include <errno.h>
+#include <dirent.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <bp-checks.h>
+
+/* For Linux we need a special version of this file since the
+   definition of `struct dirent' is not the same for the kernel and
+   the libc.  There is one additional field which might be introduced
+   in the kernel structure in the future.
+
+   Here is the kernel definition of `struct dirent64' as of 2.1.20:  */
+
+struct kernel_dirent64
+  {
+    uint64_t		d_ino;
+    int64_t		d_off;
+    unsigned short int	d_reclen;
+    unsigned char	d_type;
+    char		d_name[256];
+  };
+
+#ifndef __GETDENTS
+# define __GETDENTS __getdents
+#endif
+#ifndef DIRENT_TYPE
+# define DIRENT_TYPE struct dirent
+#endif
+#ifndef DIRENT_SET_DP_INO
+# define DIRENT_SET_DP_INO(dp, value) (dp)->d_ino = (value)
+#endif
+
+/* The problem here is that we cannot simply read the next NBYTES
+   bytes.  We need to take the additional field into account.  We use
+   some heuristic.  Assuming the directory contains names with 14
+   characters on average we can compute an estimated number of entries
+   which fit in the buffer.  Taking this number allows us to specify a
+   reasonable number of bytes to read.  If we should be wrong, we can
+   reset the file descriptor.  In practice the kernel is limiting the
+   amount of data returned much more then the reduced buffer size.  */
+ssize_t
+internal_function
+__GETDENTS (int fd, char *buf, size_t nbytes)
+{
+  ssize_t retval;
+  off64_t last_offset = -1;
+  union
+    {
+      struct kernel_dirent64 k;
+      DIRENT_TYPE u;
+      char b[1];
+    } *kbuf = (void *) buf, *outp, *inp;
+  size_t kbytes = nbytes;
+  if (offsetof (DIRENT_TYPE, d_name)
+      < offsetof (struct kernel_dirent64, d_name)
+      && nbytes <= sizeof (DIRENT_TYPE))
+    {
+      kbytes = nbytes + offsetof (struct kernel_dirent64, d_name)
+	- offsetof (DIRENT_TYPE, d_name);
+      kbuf = __alloca(kbytes);
+    }
+  retval = INLINE_SYSCALL (getdents64, 3, fd, CHECK_N(kbuf, kbytes),
+			   kbytes);
+  const size_t size_diff = (offsetof (struct kernel_dirent64, d_name)
+			    - offsetof (DIRENT_TYPE, d_name));
+
+  /* Return the error if encountered.  */
+  if (retval == -1)
+    return -1;
+
+  /* If the structure returned by the kernel is identical to what we
+     need, don't do any conversions.  */
+  if (offsetof (DIRENT_TYPE, d_name)
+      == offsetof (struct kernel_dirent64, d_name)
+      && sizeof (outp->u.d_ino) == sizeof (inp->k.d_ino)
+      && sizeof (outp->u.d_off) == sizeof (inp->k.d_off))
+    return retval;
+
+  /* These two pointers might alias the same memory buffer.
+     Standard C requires that we always use the same type for them,
+     so we must use the union type.  */
+  inp = kbuf;
+  outp = (void *) buf;
+
+  while (&inp->b < &kbuf->b + retval)
+    {
+      const size_t alignment = __alignof__ (DIRENT_TYPE);
+      /* Since inp->k.d_reclen is already aligned for the kernel
+	 structure this may compute a value that is bigger
+	 than necessary.  */
+      size_t old_reclen = inp->k.d_reclen;
+      size_t new_reclen = ((old_reclen - size_diff + alignment - 1)
+			   & ~(alignment - 1));
+
+      /* Copy the data out of the old structure into temporary space.
+	 Then copy the name, which may overlap if BUF == KBUF.  */
+      const uint64_t d_ino = inp->k.d_ino;
+      const int64_t d_off = inp->k.d_off;
+      const uint8_t d_type = inp->k.d_type;
+
+      memmove (outp->u.d_name, inp->k.d_name,
+	       old_reclen - offsetof (struct kernel_dirent64, d_name));
+
+      /* Now we have copied the data from INP and access only OUTP.  */
+
+      DIRENT_SET_DP_INO (&outp->u, d_ino);
+      outp->u.d_off = d_off;
+      if ((sizeof (outp->u.d_ino) != sizeof (inp->k.d_ino)
+	   && outp->u.d_ino != d_ino)
+	  || (sizeof (outp->u.d_off) != sizeof (inp->k.d_off)
+	      && outp->u.d_off != d_off))
+	{
+	  /* Overflow.  If there was at least one entry
+	     before this one, return them without error,
+	     otherwise signal overflow.  */
+	  if (last_offset != -1)
+	    {
+	      __lseek64 (fd, last_offset, SEEK_SET);
+	      return outp->b - buf;
+	    }
+	  __set_errno (EOVERFLOW);
+	  return -1;
+	}
+
+      last_offset = d_off;
+      outp->u.d_reclen = new_reclen;
+      outp->u.d_type = d_type;
+
+      inp = (void *) inp + old_reclen;
+      outp = (void *) outp + new_reclen;
+    }
+
+  return outp->b - buf;
+}
+
+#undef __getdents64
+weak_alias (__getdents, __getdents64);
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/gettimeofday.c b/sysdeps/unix/sysv/linux/x86_64/x32/gettimeofday.c
new file mode 100644
index 0000000..3ff95dc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/gettimeofday.c
@@ -0,0 +1,45 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef SHARED
+# include <dl-vdso.h>
+
+void *gettimeofday_ifunc (void) __asm__ ("__gettimeofday");
+
+void *
+gettimeofday_ifunc (void)
+{
+  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
+
+  return _dl_vdso_vsym ("gettimeofday", &linux26);
+}
+__asm (".type __gettimeofday, %gnu_indirect_function");
+#else
+# include <errno.h>
+# include <sysdep.h>
+# include <sys/time.h>
+
+int
+__gettimeofday (struct timeval *tv, struct timezone *tz)
+{
+  return INLINE_SYSCALL (gettimeofday, 2, tv, tz);
+}
+#endif
+
+weak_alias (__gettimeofday, gettimeofday)
+strong_alias (__gettimeofday, __gettimeofday_internal)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/glob.c b/sysdeps/unix/sysv/linux/x86_64/x32/glob.c
new file mode 100644
index 0000000..e542747
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/glob.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/glob.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/init-first.c b/sysdeps/unix/sysv/linux/x86_64/x32/init-first.c
new file mode 100644
index 0000000..6eae5f4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/init-first.c
@@ -0,0 +1,40 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef SHARED
+# include <dl-vdso.h>
+# include <bits/libc-vdso.h>
+
+long int (*__vdso_clock_gettime) (clockid_t, struct timespec *)
+  __attribute__ ((nocommon));
+strong_alias (__vdso_clock_gettime, __GI___vdso_clock_gettime attribute_hidden)
+
+static inline void
+_libc_vdso_platform_setup (void)
+{
+  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
+
+  void *p = _dl_vdso_vsym ("clock_gettime", &linux26);
+  PTR_MANGLE (p);
+  __GI___vdso_clock_gettime = p;
+}
+
+# define VDSO_SETUP _libc_vdso_platform_setup
+#endif
+
+#include "../../init-first.c"
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos.c
new file mode 100644
index 0000000..de2ff01
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofgetpos.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos64.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos64.c
new file mode 100644
index 0000000..34aabfc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofgetpos64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofopen.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofopen.c
new file mode 100644
index 0000000..e39bb55
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofopen.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofopen.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofopen64.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofopen64.c
new file mode 100644
index 0000000..af0c6ae
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofopen64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofopen64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos.c
new file mode 100644
index 0000000..a4c99c9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofsetpos.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos64.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos64.c
new file mode 100644
index 0000000..e83fbba
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofsetpos64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/llseek.S b/sysdeps/unix/sysv/linux/x86_64/x32/llseek.S
new file mode 100644
index 0000000..ca33fd1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/llseek.S
@@ -0,0 +1,33 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define SYSCALL_RETURN_INT64
+#include <sysdep.h>
+
+#define SYSCALL_NAME lseek
+#define SYSCALL_NARGS 3
+#define SYSCALL_SYMBOL __libc_lseek64
+#define SYSCALL_CANCELLABLE 1
+#include <syscall-template.S>
+weak_alias (__libc_lseek64, __lseek64)
+libc_hidden_weak (__lseek64)
+weak_alias (__libc_lseek64, lseek64)
+libc_hidden_weak (lseek64)
+weak_alias (__libc_lseek64, __lseek)
+libc_hidden_weak (__lseek)
+weak_alias (__libc_lseek64, lseek)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/lockf.c b/sysdeps/unix/sysv/linux/x86_64/x32/lockf.c
new file mode 100644
index 0000000..42306a0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/lockf.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/lockf.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/lockf64.c b/sysdeps/unix/sysv/linux/x86_64/x32/lockf64.c
new file mode 100644
index 0000000..3b4b55a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/lockf64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/lockf64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp.c b/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp.c
new file mode 100644
index 0000000..177f68a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/mkostemp.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp64.c b/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp64.c
new file mode 100644
index 0000000..68455a8
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/mkostemp64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp.c b/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp.c
new file mode 100644
index 0000000..4bc129b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/mkstemp.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp64.c b/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp64.c
new file mode 100644
index 0000000..76a8363
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/mkstemp64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/posix_fadvise.c b/sysdeps/unix/sysv/linux/x86_64/x32/posix_fadvise.c
new file mode 100644
index 0000000..b56b1b9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/posix_fadvise.c
@@ -0,0 +1,53 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+#undef LOAD_ARGS_2
+#define LOAD_ARGS_2(a1, a2)				\
+  long long int __arg2 = (long long int) (a2);		\
+  LOAD_ARGS_1 (a1)
+#undef LOAD_REGS_2
+#define LOAD_REGS_2					\
+  register long long int _a2 asm ("rsi") = __arg2;	\
+  LOAD_REGS_1
+
+#undef LOAD_ARGS_3
+#define LOAD_ARGS_3(a1, a2, a3)				\
+  long long int __arg3 = (long long int) (a3);		\
+  LOAD_ARGS_2 (a1, a2)
+#undef LOAD_REGS_3
+#define LOAD_REGS_3					\
+  register long long int _a3 asm ("rdx") = __arg3;	\
+  LOAD_REGS_2
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+posix_fadvise (int fd, off_t offset, off_t len, int advise)
+{
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64, err, 4, fd, offset, len, advise);
+  if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return INTERNAL_SYSCALL_ERRNO (ret, err);
+  return 0;
+}
+strong_alias (posix_fadvise, posix_fadvise64)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/posix_fallocate.c b/sysdeps/unix/sysv/linux/x86_64/x32/posix_fallocate.c
new file mode 100644
index 0000000..80d4de1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/posix_fallocate.c
@@ -0,0 +1,59 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fcntl.h>
+#include <sysdep.h>
+
+#define posix_fallocate static internal_fallocate
+#include <sysdeps/posix/posix_fallocate.c>
+#undef posix_fallocate
+
+#undef LOAD_ARGS_2
+#define LOAD_ARGS_2(a1, a2)				\
+  long long int __arg2 = (long long int) (a2);		\
+  LOAD_ARGS_1 (a1)
+#undef LOAD_REGS_2
+#define LOAD_REGS_2					\
+  register long long int _a2 asm ("rsi") = __arg2;	\
+  LOAD_REGS_1
+
+#undef LOAD_ARGS_3
+#define LOAD_ARGS_3(a1, a2, a3)				\
+  long long int __arg3 = (long long int) (a3);		\
+  LOAD_ARGS_2 (a1, a2)
+#undef LOAD_REGS_3
+#define LOAD_REGS_3					\
+  register long long int _a3 asm ("rdx") = __arg3;	\
+  LOAD_REGS_2
+
+/* Reserve storage for the data of the file associated with FD.  */
+int
+posix_fallocate (int fd, __off_t offset, __off_t len)
+{
+  INTERNAL_SYSCALL_DECL (err);
+  int res = INTERNAL_SYSCALL (fallocate, err, 4, fd, 0, offset, len);
+
+  if (! INTERNAL_SYSCALL_ERROR_P (res, err))
+    return 0;
+
+  if (INTERNAL_SYSCALL_ERRNO (res, err) != EOPNOTSUPP)
+    return INTERNAL_SYSCALL_ERRNO (res, err);
+
+  return internal_fallocate (fd, offset, len);
+}
+strong_alias (posix_fallocate, posix_fallocate64)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/preadv.c b/sysdeps/unix/sysv/linux/x86_64/x32/preadv.c
new file mode 100644
index 0000000..7399dd3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/preadv.c
@@ -0,0 +1,49 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#define preadv64 __redirect_preadv64
+#include <sys/uio.h>
+#include <sysdep-cancel.h>
+
+#undef LOAD_ARGS_4
+#define LOAD_ARGS_4(a1, a2, a3, a4)			\
+  long long int __arg4 = (long long int) (a4);		\
+  LOAD_ARGS_3 (a1, a2, a3)
+#undef LOAD_REGS_4
+#define LOAD_REGS_4					\
+  register long long int _a4 asm ("r10") = __arg4;	\
+  LOAD_REGS_3
+
+ssize_t
+preadv (int fd, const struct iovec *vector, int count, off_t offset)
+{
+  ssize_t result;
+  if (SINGLE_THREAD_P)
+    result = INLINE_SYSCALL (preadv, 4, fd, vector, count, offset);
+  else
+    {
+      int oldtype = LIBC_CANCEL_ASYNC ();
+      result = INLINE_SYSCALL (preadv, 4, fd, vector, count, offset);
+      LIBC_CANCEL_RESET (oldtype);
+    }
+  return result;
+}
+#undef preadv64
+strong_alias (preadv, preadv64)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/pselect.c b/sysdeps/unix/sysv/linux/x86_64/x32/pselect.c
new file mode 100644
index 0000000..01a0a91
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/pselect.c
@@ -0,0 +1,70 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <time.h>
+#include <sys/poll.h>
+#include <sysdep-cancel.h>
+
+
+int
+__pselect (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+	   const struct timespec *timeout, const sigset_t *sigmask)
+{
+  /* The Linux kernel can in some situations update the timeout value.
+     We do not want that so use a local variable.  */
+  struct timespec tval;
+  if (timeout != NULL)
+    {
+      tval = *timeout;
+      timeout = &tval;
+    }
+
+  /* Note: the system call expects 7 values but on most architectures
+     we can only pass in 6 directly.  If there is an architecture with
+     support for more parameters a new version of this file needs to
+     be created.  */
+  struct
+  {
+    const sigset_t *ss;
+    unsigned long long ss_len;
+  } data;
+
+  data.ss = sigmask;
+  data.ss_len = _NSIG / 8;
+
+  int result;
+
+  if (SINGLE_THREAD_P)
+    result = INLINE_SYSCALL (pselect6, 6, nfds, readfds, writefds,
+			     exceptfds, timeout, &data);
+  else
+    {
+      int oldtype = LIBC_CANCEL_ASYNC ();
+
+      result = INLINE_SYSCALL (pselect6, 6, nfds, readfds, writefds,
+			       exceptfds, timeout, &data);
+
+      LIBC_CANCEL_RESET (oldtype);
+    }
+
+  return result;
+}
+weak_alias (__pselect, pselect)
+strong_alias (__pselect, __libc_pselect)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/pwritev.c b/sysdeps/unix/sysv/linux/x86_64/x32/pwritev.c
new file mode 100644
index 0000000..5aaa400
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/pwritev.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sysdep.h>
+/* Hide the pwritev64 declaration.  */
+#define pwritev64 __redirect_pwritev64
+#include <sys/uio.h>
+#include <sysdep-cancel.h>
+
+#undef LOAD_ARGS_4
+#define LOAD_ARGS_4(a1, a2, a3, a4)			\
+  long long int __arg4 = (long long int) (a4);		\
+  LOAD_ARGS_3 (a1, a2, a3)
+#undef LOAD_REGS_4
+#define LOAD_REGS_4					\
+  register long long int _a4 asm ("r10") = __arg4;	\
+  LOAD_REGS_3
+
+ssize_t
+pwritev (int fd, const struct iovec *vector, int count, off_t offset)
+{
+  ssize_t result;
+  if (SINGLE_THREAD_P)
+    result = INLINE_SYSCALL (pwritev, 4, fd, vector, count, offset);
+  else
+    {
+      int oldtype = LIBC_CANCEL_ASYNC ();
+      result = INLINE_SYSCALL (pwritev, 4, fd, vector, count, offset);
+      LIBC_CANCEL_RESET (oldtype);
+    }
+  return result;
+}
+#undef pwritev64
+strong_alias (pwritev, pwritev64)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/scandir.c b/sysdeps/unix/sysv/linux/x86_64/x32/scandir.c
new file mode 100644
index 0000000..9288ca2
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/scandir.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/scandir.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/scandir64.c b/sysdeps/unix/sysv/linux/x86_64/x32/scandir64.c
new file mode 100644
index 0000000..6d22057
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/scandir64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/scandir64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/scandirat.c b/sysdeps/unix/sysv/linux/x86_64/x32/scandirat.c
new file mode 100644
index 0000000..5b88993
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/scandirat.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/scandirat.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/scandirat64.c b/sysdeps/unix/sysv/linux/x86_64/x32/scandirat64.c
new file mode 100644
index 0000000..0d7893d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/scandirat64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/scandirat64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu-static.c b/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu-static.c
new file mode 100644
index 0000000..38bbf9a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu-static.c
@@ -0,0 +1,3 @@
+#ifndef SHARED
+#include "../../sched_getcpu.c"
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu.S b/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu.S
new file mode 100644
index 0000000..a4040ef
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu.S
@@ -0,0 +1,47 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef SHARED
+#include <sysdep.h>
+#include <tls.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+ENTRY (sched_getcpu)
+	/* Align stack and create local variable for result.  */
+	sub	$0x8, %esp
+	cfi_adjust_cfa_offset(8)
+
+	mov	%esp, %edi
+	xor	%esi, %esi
+	mov	$VGETCPU_CACHE_OFFSET, %edx
+	add	%fs:0, %edx
+
+	call	__getcpu@PLT
+
+	cmp	$-4095, %eax
+	jae	SYSCALL_ERROR_LABEL
+
+	mov	(%rsp), %eax
+
+L(pseudo_end):
+	add	$0x8, %esp
+	cfi_adjust_cfa_offset(-8)
+	ret
+PSEUDO_END(sched_getcpu)
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/sendfile64.c b/sysdeps/unix/sysv/linux/x86_64/x32/sendfile64.c
new file mode 100644
index 0000000..4c451bd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/sendfile64.c
@@ -0,0 +1 @@
+/* sendfile64 is alias of sendfile syscall.  */
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/syscalls.list b/sysdeps/unix/sysv/linux/x86_64/x32/syscalls.list
new file mode 100644
index 0000000..a5d4007
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/syscalls.list
@@ -0,0 +1,23 @@
+# Copied from 64bit syscalls.list without llseek, which is implemented in
+# llseek.S to properly handle 64bit parameter and return value.
+
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+lseek		llseek	-
+pread		-	pread		Ci:ibni	__libc_pread	__libc_pread64 __pread pread __pread64 pread64
+pwrite		-	pwrite		Ci:ibni	__libc_pwrite	__libc_pwrite64 __pwrite pwrite __pwrite64 pwrite64
+fstatfs		-	fstatfs		i:ip	__fstatfs	fstatfs fstatfs64 __fstatfs64
+statfs		-	statfs		i:sp	__statfs	statfs statfs64
+mmap		-	mmap		b:aniiii __mmap		mmap __mmap64 mmap64
+ftruncate	-	ftruncate	i:ii	__ftruncate	ftruncate ftruncate64 __ftruncate64
+truncate	-	truncate	i:si	truncate	truncate64
+getrlimit	-	getrlimit	i:ip	__getrlimit	getrlimit getrlimit64
+setrlimit	-	setrlimit	i:ip	__setrlimit	setrlimit setrlimit64
+readahead	-	readahead	i:iii	__readahead	readahead
+sendfile	-	sendfile	i:iipi	sendfile	sendfile64
+sync_file_range	-	sync_file_range	Ci:iiii	sync_file_range
+creat		-	creat		Ci:si	__libc_creat	creat creat64
+open		-	open		Ci:siv	__libc_open	__open open __open64 open64
+prlimit		EXTRA	prlimit64	i:iipp	prlimit		prlimit64
+
+fanotify_mark	EXTRA	fanotify_mark	i:iiiis	fanotify_mark
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/sysctl.c b/sysdeps/unix/sysv/linux/x86_64/x32/sysctl.c
new file mode 100644
index 0000000..634c289
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/sysctl.c
@@ -0,0 +1 @@
+/* X32 doesn't have _sysctl.  */
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/sysdep.h b/sysdeps/unix/sysv/linux/x86_64/x32/sysdep.h
new file mode 100644
index 0000000..486c30d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/sysdep.h
@@ -0,0 +1,132 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_X32_SYSDEP_H
+#define _LINUX_X32_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/sysv/linux/x86_64/sysdep.h>
+#include <sysdeps/x86_64/x32/sysdep.h>
+
+#ifdef __ASSEMBLER__
+
+# ifdef SYSCALL_RETURN_INT64
+#  define SYSCALL_SET_ERROR_RETURN orq $-1, %rax
+# else
+#  define SYSCALL_SET_ERROR_RETURN orl $-1, %eax
+# endif
+
+# ifndef PIC
+/* Nothing here.  */
+# elif RTLD_PRIVATE_ERRNO
+#  undef SYSCALL_ERROR_HANDLER
+#  define SYSCALL_ERROR_HANDLER			\
+0:						\
+  lea rtld_errno(%rip), %ecx;			\
+  xorl %edx, %edx;				\
+  subl %eax, %edx;				\
+  movl %edx, (%rcx);				\
+  SYSCALL_SET_ERROR_RETURN;			\
+  jmp L(pseudo_end);
+# elif USE___THREAD
+#  undef SYSCALL_ERROR_HANDLER
+#  define SYSCALL_ERROR_HANDLER			\
+0:						\
+  movq SYSCALL_ERROR_ERRNO@GOTTPOFF(%rip), %rcx;\
+  xorl %edx, %edx;				\
+  subl %eax, %edx;				\
+  movl %edx, %fs:(%rcx);			\
+  SYSCALL_SET_ERROR_RETURN;			\
+  jmp L(pseudo_end);
+# elif defined _LIBC_REENTRANT
+/* Store (- %eax) into errno through the GOT.
+   Note that errno occupies only 4 bytes.  */
+#  undef SYSCALL_ERROR_HANDLER
+#  define SYSCALL_ERROR_HANDLER			\
+0:						\
+  xorl %edx, %edx;				\
+  subl %eax, %edx;				\
+  pushq %rdx;					\
+  cfi_adjust_cfa_offset(8);			\
+  PUSH_ERRNO_LOCATION_RETURN;			\
+  call BP_SYM (__errno_location)@PLT;		\
+  POP_ERRNO_LOCATION_RETURN;			\
+  popq %rdx;					\
+  cfi_adjust_cfa_offset(-8);			\
+  movl %edx, (%rax);				\
+  SYSCALL_SET_ERROR_RETURN;			\
+  jmp L(pseudo_end);
+
+/* A quick note: it is assumed that the call to `__errno_location' does
+   not modify the stack!  */
+# else /* Not _LIBC_REENTRANT.  */
+#  undef SYSCALL_ERROR_HANDLER
+#  define SYSCALL_ERROR_HANDLER			\
+0:movq errno@GOTPCREL(%rip), %rcx;		\
+  xorl %edx, %edx;				\
+  subl %eax, %edx;				\
+  movl %edx, (%rcx);				\
+  SYSCALL_SET_ERROR_RETURN;			\
+  jmp L(pseudo_end);
+# endif	/* PIC */
+
+#endif	/* __ASSEMBLER__ */
+
+/* Pointer mangling support.  */
+#undef PTR_MANGLE
+#undef PTR_DEMANGLE
+
+#if defined NOT_IN_libc && defined IS_IN_rtld
+/* We cannot use the thread descriptor because in ld.so we use setjmp
+   earlier than the descriptor is initialized.  */
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorl __pointer_chk_guard_local(%rip), reg;    \
+				roll $17, reg
+#  define PTR_DEMANGLE(reg)	rorl $17, reg;				      \
+				xorl __pointer_chk_guard_local(%rip), reg
+# else
+#  define PTR_MANGLE(reg)	asm ("xorl __pointer_chk_guard_local(%%rip), %0\n" \
+				     "roll $17, %0"			      \
+				     : "=r" (reg) : "0" (reg))
+#  define PTR_DEMANGLE(reg)	asm ("rorl $17, %0\n"			      \
+				     "xorl __pointer_chk_guard_local(%%rip), %0" \
+				     : "=r" (reg) : "0" (reg))
+# endif
+#else
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorl %fs:POINTER_GUARD, reg;		      \
+				roll $17, reg
+#  define PTR_DEMANGLE(reg)	rorl $17, reg;				      \
+				xorl %fs:POINTER_GUARD, reg
+# else
+#  define PTR_MANGLE(var)	asm ("xorl %%fs:%c2, %0\n"		      \
+				     "roll $17, %0"			      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+#  define PTR_DEMANGLE(var)	asm ("rorl $17, %0\n"			      \
+				     "xorl %%fs:%c2, %0"		      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+# endif
+#endif
+
+#endif /* linux/x86_64/x32/sysdep.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/time.c b/sysdeps/unix/sysv/linux/x86_64/x32/time.c
new file mode 100644
index 0000000..b7feb93
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/time.c
@@ -0,0 +1,77 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#include <time.h>
+
+# undef INLINE_SYSCALL
+# define INLINE_SYSCALL(name, nr, args...) \
+  ({									      \
+    unsigned long long int resultvar = INTERNAL_SYSCALL (name, , nr, args);   \
+    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))	      \
+      {									      \
+	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \
+	resultvar = (unsigned long long int) -1LL;			      \
+      }									      \
+    (long long int) resultvar; })
+
+# undef INTERNAL_SYSCALL_NCS
+# define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
+  ({									      \
+    unsigned long long int resultvar;					      \
+    LOAD_ARGS_##nr (args)						      \
+    LOAD_REGS_##nr							      \
+    asm volatile (							      \
+    "syscall\n\t"							      \
+    : "=a" (resultvar)							      \
+    : "0" (name) ASM_ARGS_##nr : "memory", "cc", "r11", "cx");		      \
+    (long long int) resultvar; })
+
+# undef INTERNAL_SYSCALL_ERROR_P
+# define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  ((unsigned long long int) (long long int) (val) >= -4095LL)
+
+#ifdef SHARED
+# include <dl-vdso.h>
+
+void *time_ifunc (void) __asm__ ("__GI_time");
+
+static time_t
+time_syscall (time_t *t)
+{
+  return INLINE_SYSCALL (time, 1, t);
+}
+
+void *
+time_ifunc (void)
+{
+  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
+
+  return _dl_vdso_vsym ("time", &linux26) ?: (void *) time_syscall;
+}
+__asm (".type __GI_time, %gnu_indirect_function");
+#else
+time_t
+time (time_t *t)
+{
+  return INLINE_SYSCALL (time, 1, t);
+}
+#endif
+
+libc_hidden_def (time)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile.c b/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile.c
new file mode 100644
index 0000000..f24f361
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/tmpfile.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile64.c b/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile64.c
new file mode 100644
index 0000000..55feef2
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/tmpfile64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/versionsort.c b/sysdeps/unix/sysv/linux/x86_64/x32/versionsort.c
new file mode 100644
index 0000000..af5a668
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/versionsort.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/versionsort.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/versionsort64.c b/sysdeps/unix/sysv/linux/x86_64/x32/versionsort64.c
new file mode 100644
index 0000000..fe220c9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/versionsort64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/versionsort64.c>
diff --git a/sysdeps/x86_64/64/Implies b/sysdeps/x86_64/64/Implies
new file mode 100644
index 0000000..8ec4217
--- /dev/null
+++ b/sysdeps/x86_64/64/Implies
@@ -0,0 +1,6 @@
+x86_64/fpu
+wordsize-64
+ieee754/ldbl-96
+ieee754/dbl-64/wordsize-64
+ieee754/dbl-64
+ieee754/flt-32
diff --git a/sysdeps/x86_64/64/bits/wordsize.h b/sysdeps/x86_64/64/bits/wordsize.h
new file mode 100644
index 0000000..cb59cd2
--- /dev/null
+++ b/sysdeps/x86_64/64/bits/wordsize.h
@@ -0,0 +1,7 @@
+/* Determine the wordsize from the preprocessor defines.  */
+
+#if defined __LP64__
+# define __WORDSIZE	64
+#else
+# define __WORDSIZE	32
+#endif
diff --git a/sysdeps/x86_64/64/shlib-versions b/sysdeps/x86_64/64/shlib-versions
new file mode 100644
index 0000000..f793bda
--- /dev/null
+++ b/sysdeps/x86_64/64/shlib-versions
@@ -0,0 +1,2 @@
+x86_64-.*-linux.*       DEFAULT			GLIBC_2.2.5
+x86_64-.*-linux.*	ld=ld-linux-x86-64.so.2	GLIBC_2.2.5
diff --git a/sysdeps/x86_64/Implies b/sysdeps/x86_64/Implies
deleted file mode 100644
index 2e0a323..0000000
--- a/sysdeps/x86_64/Implies
+++ /dev/null
@@ -1,5 +0,0 @@
-wordsize-64
-ieee754/ldbl-96
-ieee754/dbl-64/wordsize-64
-ieee754/dbl-64
-ieee754/flt-32
diff --git a/sysdeps/x86_64/__longjmp.S b/sysdeps/x86_64/__longjmp.S
index b045c04..fa9e96b 100644
--- a/sysdeps/x86_64/__longjmp.S
+++ b/sysdeps/x86_64/__longjmp.S
@@ -30,9 +30,9 @@ ENTRY(__longjmp)
 	movq (JB_RBP*8)(%rdi),%r9
 	movq (JB_PC*8)(%rdi),%rdx
 #ifdef PTR_DEMANGLE
-	PTR_DEMANGLE (%r8)
-	PTR_DEMANGLE (%r9)
-	PTR_DEMANGLE (%rdx)
+	PTR_DEMANGLE (%R8_LP)
+	PTR_DEMANGLE (%R9_LP)
+	PTR_DEMANGLE (%RDX_LP)
 #endif
 	/* We add unwind information for the target here.  */
 	cfi_def_cfa(%rdi, 0)
diff --git a/sysdeps/x86_64/bits/atomic.h b/sysdeps/x86_64/bits/atomic.h
index 7c138eb..2ded147 100644
--- a/sysdeps/x86_64/bits/atomic.h
+++ b/sysdeps/x86_64/bits/atomic.h
@@ -87,8 +87,8 @@ typedef uintmax_t uatomic_max_t;
   ({ __typeof (*mem) ret;						      \
      __asm __volatile (LOCK_PREFIX "cmpxchgq %q2, %1"			      \
 		       : "=a" (ret), "=m" (*mem)			      \
-		       : "r" ((long int) (newval)), "m" (*mem),		      \
-			 "0" ((long int) (oldval)));			      \
+		       : "r" ((long long int) (newval)), "m" (*mem),	      \
+			 "0" ((long long int) (oldval)));		      \
      ret; })
 #endif
 
@@ -133,8 +133,8 @@ typedef uintmax_t uatomic_max_t;
 		       "lock\n"						      \
 		       "0:\tcmpxchgq %q2, %1"				      \
 		       : "=a" (ret), "=m" (*mem)			      \
-		       : "q" ((long int) (newval)), "m" (*mem),		      \
-			 "0" ((long int)oldval),			      \
+		       : "q" ((long long int) (newval)), "m" (*mem),	      \
+			 "0" ((long long int) (oldval)),		      \
 			 "i" (offsetof (tcbhead_t, multiple_threads)));	      \
      ret; })
 
@@ -157,7 +157,7 @@ typedef uintmax_t uatomic_max_t;
      else								      \
        __asm __volatile ("xchgq %q0, %1"				      \
 			 : "=r" (result), "=m" (*mem)			      \
-			 : "0" ((long) (newvalue)), "m" (*mem));	      \
+			 : "0" ((long long) (newvalue)), "m" (*mem));	      \
      result; })
 
 
@@ -181,7 +181,7 @@ typedef uintmax_t uatomic_max_t;
      else								      \
        __asm __volatile (lock "xaddq %q0, %1"				      \
 			 : "=r" (result), "=m" (*mem)			      \
-			 : "0" ((long) (value)), "m" (*mem),		      \
+			 : "0" ((long long) (value)), "m" (*mem),	      \
 			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
      result; })
 
@@ -224,7 +224,7 @@ typedef uintmax_t uatomic_max_t;
     else								      \
       __asm __volatile (lock "addq %q1, %0"				      \
 			: "=m" (*mem)					      \
-			: "ir" ((long) (value)), "m" (*mem),		      \
+			: "ir" ((long long) (value)), "m" (*mem),	      \
 			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
   } while (0)
 
@@ -255,7 +255,7 @@ typedef uintmax_t uatomic_max_t;
      else								      \
        __asm __volatile (LOCK_PREFIX "addq %q2, %0; sets %1"		      \
 			 : "=m" (*mem), "=qm" (__result)		      \
-			 : "ir" ((long) (value)), "m" (*mem));		      \
+			 : "ir" ((long long) (value)), "m" (*mem));	      \
      __result; })
 
 
@@ -276,7 +276,7 @@ typedef uintmax_t uatomic_max_t;
      else								      \
        __asm __volatile (LOCK_PREFIX "addq %q2, %0; setz %1"		      \
 			 : "=m" (*mem), "=qm" (__result)		      \
-			 : "ir" ((long) (value)), "m" (*mem));		      \
+			 : "ir" ((long long) (value)), "m" (*mem));	      \
      __result; })
 
 
diff --git a/sysdeps/x86_64/bits/byteswap.h b/sysdeps/x86_64/bits/byteswap.h
index e350fb8..fa0e863 100644
--- a/sysdeps/x86_64/bits/byteswap.h
+++ b/sysdeps/x86_64/bits/byteswap.h
@@ -25,8 +25,6 @@
 #ifndef _BITS_BYTESWAP_H
 #define _BITS_BYTESWAP_H 1
 
-#include <bits/wordsize.h>
-
 /* Swap bytes in 16 bit value.  */
 #define __bswap_constant_16(x) \
      ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))
@@ -58,12 +56,11 @@
       (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
 
 #if defined __GNUC__ && __GNUC__ >= 2
-# if __WORDSIZE == 64 || (defined __i486__ || defined __pentium__	      \
-			  || defined __pentiumpro__ || defined __pentium4__   \
-			  || defined __k8__ || defined __athlon__	      \
-			  || defined __k6__ || defined __nocona__	      \
-			  || defined __core2__ || defined __geode__	      \
-			  || defined __amdfam10__)
+# if defined __x86_64__ || defined __i486__ || defined __pentium__	      \
+     || defined __pentiumpro__ || defined __pentium4__  || defined __k8__     \
+     || defined __athlon__ || defined __k6__ || defined __nocona__	      \
+     || defined __core2__ || defined __corei7__ || defined __geode__ 	      \
+     || defined __amdfam10__
 /* To swap the bytes in a word the i486 processors and up provide the
    `bswap' opcode.  On i386 we have to use three instructions.  */
 #  define __bswap_32(x) \
@@ -108,10 +105,10 @@
       | (((x) & 0x000000000000ff00ull) << 40)				      \
       | (((x) & 0x00000000000000ffull) << 56))
 
-# if __WORDSIZE == 64
+# ifdef __x86_64__ 
 #  define __bswap_64(x) \
      (__extension__							      \
-      ({ register unsigned long __v, __x = (x);				      \
+      ({ register unsigned long long int __v, __x = (x);		      \
 	 if (__builtin_constant_p (__x))				      \
 	   __v = __bswap_constant_64 (__x);				      \
 	 else								      \
diff --git a/sysdeps/x86_64/bits/link.h b/sysdeps/x86_64/bits/link.h
index 14cc92b..df32930 100644
--- a/sysdeps/x86_64/bits/link.h
+++ b/sysdeps/x86_64/bits/link.h
@@ -21,7 +21,7 @@
 #endif
 
 
-#if __ELF_NATIVE_CLASS == 32
+#ifndef __x86_64__
 /* Registers for entry into PLT on IA-32.  */
 typedef struct La_i86_regs
 {
@@ -125,6 +125,22 @@ extern unsigned int la_x86_64_gnu_pltexit (Elf64_Sym *__sym,
 					   La_x86_64_retval *__outregs,
 					   const char *__symname);
 
+extern Elf32_Addr la_x32_gnu_pltenter (Elf32_Sym *__sym,
+				       unsigned int __ndx,
+				       uintptr_t *__refcook,
+				       uintptr_t *__defcook,
+				       La_x86_64_regs *__regs,
+				       unsigned int *__flags,
+				       const char *__symname,
+				       long int *__framesizep);
+extern unsigned int la_x32_gnu_pltexit (Elf32_Sym *__sym,
+					unsigned int __ndx,
+					uintptr_t *__refcook,
+					uintptr_t *__defcook,
+					const La_x86_64_regs *__inregs,
+					La_x86_64_retval *__outregs,
+					const char *__symname);
+
 __END_DECLS
 
 #endif
diff --git a/sysdeps/x86_64/bits/mathdef.h b/sysdeps/x86_64/bits/mathdef.h
index 9146392..9e23501 100644
--- a/sysdeps/x86_64/bits/mathdef.h
+++ b/sysdeps/x86_64/bits/mathdef.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2004, 2010 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2004, 2010, 2011 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,9 +23,7 @@
 #if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
 # define _MATH_H_MATHDEF	1
 
-# include <bits/wordsize.h>
-
-# if __WORDSIZE == 64 || (defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0)
+# if defined __x86_64__ || (defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0)
 /* The x86-64 architecture computes values with the precission of the
    used type.  Similarly for -m32 -mfpmath=sse.  */
 typedef float float_t;		/* `float' expressions are evaluated as `float'.  */
diff --git a/sysdeps/x86_64/bits/setjmp.h b/sysdeps/x86_64/bits/setjmp.h
index c9b98b2..72cfd65 100644
--- a/sysdeps/x86_64/bits/setjmp.h
+++ b/sysdeps/x86_64/bits/setjmp.h
@@ -24,12 +24,10 @@
 # error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
 #endif
 
-#include <bits/wordsize.h>
-
 #ifndef _ASM
 
-# if __WORDSIZE == 64
-typedef long int __jmp_buf[8];
+# if __x86_64__
+typedef long long int __jmp_buf[8];
 # else
 typedef int __jmp_buf[6];
 # endif
diff --git a/sysdeps/x86_64/bits/wordsize.h b/sysdeps/x86_64/bits/wordsize.h
deleted file mode 100644
index a40a0d8..0000000
--- a/sysdeps/x86_64/bits/wordsize.h
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Determine the wordsize from the preprocessor defines.  */
-
-#if defined __x86_64__
-# define __WORDSIZE	64
-# define __WORDSIZE_COMPAT32	1
-#else
-# define __WORDSIZE	32
-#endif
diff --git a/sysdeps/x86_64/dl-irel.h b/sysdeps/x86_64/dl-irel.h
index d2d5c06..ac90c94 100644
--- a/sysdeps/x86_64/dl-irel.h
+++ b/sysdeps/x86_64/dl-irel.h
@@ -28,14 +28,14 @@
 
 static inline void
 __attribute ((always_inline))
-elf_irela (const Elf64_Rela *reloc)
+elf_irela (const ElfW(Rela) *reloc)
 {
-  Elf64_Addr *const reloc_addr = (void *) reloc->r_offset;
-  const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);
+  ElfW(Addr) *const reloc_addr = (void *) reloc->r_offset;
+  const unsigned long int r_type = ELF32_R_TYPE (reloc->r_info);
 
   if (__builtin_expect (r_type == R_X86_64_IRELATIVE, 1))
     {
-      Elf64_Addr value = ((Elf64_Addr (*) (void)) reloc->r_addend) ();
+      ElfW(Addr) value = ((ElfW(Addr) (*) (void)) reloc->r_addend) ();
       *reloc_addr = value;
     }
   else
diff --git a/sysdeps/x86_64/dl-machine.h b/sysdeps/x86_64/dl-machine.h
index f615e95..74a8109 100644
--- a/sysdeps/x86_64/dl-machine.h
+++ b/sysdeps/x86_64/dl-machine.h
@@ -30,7 +30,7 @@
 
 /* Return nonzero iff ELF header is compatible with the running host.  */
 static inline int __attribute__ ((unused))
-elf_machine_matches_host (const Elf64_Ehdr *ehdr)
+elf_machine_matches_host (const ElfW(Ehdr) *ehdr)
 {
   return ehdr->e_machine == EM_X86_64;
 }
@@ -39,24 +39,24 @@ elf_machine_matches_host (const Elf64_Ehdr *ehdr)
 /* Return the link-time address of _DYNAMIC.  Conveniently, this is the
    first element of the GOT.  This must be inlined in a function which
    uses global data.  */
-static inline Elf64_Addr __attribute__ ((unused))
+static inline ElfW(Addr) __attribute__ ((unused))
 elf_machine_dynamic (void)
 {
-  Elf64_Addr addr;
+  ElfW(Addr) addr;
 
   /* This works because we have our GOT address available in the small PIC
      model.  */
-  addr = (Elf64_Addr) &_DYNAMIC;
+  addr = (ElfW(Addr)) &_DYNAMIC;
 
   return addr;
 }
 
 
 /* Return the run-time load address of the shared object.  */
-static inline Elf64_Addr __attribute__ ((unused))
+static inline ElfW(Addr) __attribute__ ((unused))
 elf_machine_load_address (void)
 {
-  Elf64_Addr addr;
+  ElfW(Addr) addr;
 
   /* The easy way is just the same as on x86:
        leaq _dl_start, %0
@@ -73,10 +73,10 @@ elf_machine_load_address (void)
      load offset which is zero if the binary was loaded at the address
      it is prelinked for.  */
 
-  asm ("leaq _dl_start(%%rip), %0\n\t"
-       "subq 1f(%%rip), %0\n\t"
+  asm ("lea _dl_start(%%rip), %0\n\t"
+       "sub 1f(%%rip), %0\n\t"
        ".section\t.data.rel.ro\n"
-       "1:\t.quad _dl_start\n\t"
+       "1:\t" ASM_ADDR " _dl_start\n\t"
        ".previous\n\t"
        : "=r" (addr) : : "cc");
 
@@ -90,8 +90,8 @@ static inline int __attribute__ ((unused, always_inline))
 elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
 {
   Elf64_Addr *got;
-  extern void _dl_runtime_resolve (Elf64_Word) attribute_hidden;
-  extern void _dl_runtime_profile (Elf64_Word) attribute_hidden;
+  extern void _dl_runtime_resolve (ElfW(Word)) attribute_hidden;
+  extern void _dl_runtime_profile (ElfW(Word)) attribute_hidden;
 
   if (l->l_info[DT_JMPREL] && lazy)
     {
@@ -106,9 +106,10 @@ elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
       if (got[1])
 	{
 	  l->l_mach.plt = got[1] + l->l_addr;
-	  l->l_mach.gotplt = (Elf64_Addr) &got[3];
+	  l->l_mach.gotplt = (ElfW(Addr)) &got[3];
 	}
-      got[1] = (Elf64_Addr) l;	/* Identify this shared object.  */
+      /* Identify this shared object.  */
+      *(ElfW(Addr) *) (got + 1) = (ElfW(Addr)) l;
 
       /* The got[2] entry contains the address of a function which gets
 	 called to get the address of a so far unresolved function and
@@ -118,7 +119,7 @@ elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
 	 end in this function.  */
       if (__builtin_expect (profile, 0))
 	{
-	  got[2] = (Elf64_Addr) &_dl_runtime_profile;
+	  *(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_profile;
 
 	  if (GLRO(dl_profile) != NULL
 	      && _dl_name_match_p (GLRO(dl_profile), l))
@@ -129,12 +130,12 @@ elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
       else
 	/* This function will get called to fix up the GOT entry indicated by
 	   the offset on the stack, and then jump to the resolved address.  */
-	got[2] = (Elf64_Addr) &_dl_runtime_resolve;
+	*(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_resolve;
     }
 
   if (l->l_info[ADDRIDX (DT_TLSDESC_GOT)] && lazy)
-    *(Elf64_Addr*)(D_PTR (l, l_info[ADDRIDX (DT_TLSDESC_GOT)]) + l->l_addr)
-      = (Elf64_Addr) &_dl_tlsdesc_resolve_rela;
+    *(ElfW(Addr)*)(D_PTR (l, l_info[ADDRIDX (DT_TLSDESC_GOT)]) + l->l_addr)
+      = (ElfW(Addr)) &_dl_tlsdesc_resolve_rela;
 
   return lazy;
 }
@@ -213,7 +214,7 @@ _dl_start_user:\n\
 /* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.  */
 #define ELF_MACHINE_JMP_SLOT	R_X86_64_JUMP_SLOT
 
-/* The x86-64 never uses Elf64_Rel relocations.  */
+/* The x86-64 never uses Elf64_Rel/Elf32_Rel relocations.  */
 #define ELF_MACHINE_NO_REL 1
 
 /* We define an initialization functions.  This is called very early in
@@ -228,19 +229,19 @@ dl_platform_init (void)
     GLRO(dl_platform) = NULL;
 }
 
-static inline Elf64_Addr
+static inline ElfW(Addr)
 elf_machine_fixup_plt (struct link_map *map, lookup_t t,
-		       const Elf64_Rela *reloc,
-		       Elf64_Addr *reloc_addr, Elf64_Addr value)
+		       const ElfW(Rela) *reloc,
+		       ElfW(Addr) *reloc_addr, ElfW(Addr) value)
 {
   return *reloc_addr = value;
 }
 
 /* Return the final value of a plt relocation.  On x86-64 the
    JUMP_SLOT relocation ignores the addend. */
-static inline Elf64_Addr
-elf_machine_plt_value (struct link_map *map, const Elf64_Rela *reloc,
-		       Elf64_Addr value)
+static inline ElfW(Addr)
+elf_machine_plt_value (struct link_map *map, const ElfW(Rela) *reloc,
+		       ElfW(Addr) value)
 {
   return value;
 }
@@ -259,12 +260,12 @@ elf_machine_plt_value (struct link_map *map, const Elf64_Rela *reloc,
 
 auto inline void
 __attribute__ ((always_inline))
-elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
-		  const Elf64_Sym *sym, const struct r_found_version *version,
+elf_machine_rela (struct link_map *map, const ElfW(Rela) *reloc,
+		  const ElfW(Sym) *sym, const struct r_found_version *version,
 		  void *const reloc_addr_arg)
 {
-  Elf64_Addr *const reloc_addr = reloc_addr_arg;
-  const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);
+  ElfW(Addr) *const reloc_addr = reloc_addr_arg;
+  const unsigned long int r_type = ELF32_R_TYPE (reloc->r_info);
 
 # if !defined RTLD_BOOTSTRAP || !defined HAVE_Z_COMBRELOC
   if (__builtin_expect (r_type == R_X86_64_RELATIVE, 0))
@@ -285,22 +286,28 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
     }
   else
 # endif
+# if !defined RTLD_BOOTSTRAP && !defined __LP64__
+  if (__builtin_expect (r_type == R_X86_64_RELATIVE64, 0))
+    *((Elf64_Addr *) (uintptr_t) reloc_addr)
+      = (Elf64_Addr) map->l_addr + reloc->r_addend;
+  else
+# endif
   if (__builtin_expect (r_type == R_X86_64_NONE, 0))
     return;
   else
     {
 # ifndef RTLD_BOOTSTRAP
-      const Elf64_Sym *const refsym = sym;
+      const ElfW(Sym) *const refsym = sym;
 # endif
       struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
-      Elf64_Addr value = (sym == NULL ? 0
-			  : (Elf64_Addr) sym_map->l_addr + sym->st_value);
+      ElfW(Addr) value = (sym == NULL ? 0
+			  : (ElfW(Addr)) sym_map->l_addr + sym->st_value);
 
       if (sym != NULL
 	  && __builtin_expect (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC,
 			       0)
 	  && __builtin_expect (sym->st_shndx != SHN_UNDEF, 1))
-	value = ((Elf64_Addr (*) (void)) value) ();
+	value = ((ElfW(Addr) (*) (void)) value) ();
 
 # if defined RTLD_BOOTSTRAP && !USE___THREAD
       assert (r_type == R_X86_64_GLOB_DAT || r_type == R_X86_64_JUMP_SLOT);
@@ -333,7 +340,13 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
 	  /* During relocation all TLS symbols are defined and used.
 	     Therefore the offset is already correct.  */
 	  if (sym != NULL)
+#   ifdef __LP64__
 	    *reloc_addr = sym->st_value + reloc->r_addend;
+#   else
+	    *(Elf64_Sxword *) reloc_addr
+	      = (Elf64_Sxword)
+		  ((Elf32_Sword) (sym->st_value + reloc->r_addend));
+#   endif
 #  endif
 	  break;
 	case R_X86_64_TLSDESC:
@@ -383,15 +396,27 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
 	      /* We know the offset of the object the symbol is contained in.
 		 It is a negative value which will be added to the
 		 thread pointer.  */
+#  ifdef __LP64__
 	      *reloc_addr = (sym->st_value + reloc->r_addend
 			     - sym_map->l_tls_offset);
+#  else
+	    *(Elf64_Sxword *) reloc_addr
+	      = (Elf64_Sxword)
+		  ((Elf32_Sword) (sym->st_value + reloc->r_addend
+				  - sym_map->l_tls_offset));
+#  endif
 	    }
 	  break;
 # endif
 
 # ifndef RTLD_BOOTSTRAP
 	case R_X86_64_64:
+#  ifdef __LP64__
 	  *reloc_addr = value + reloc->r_addend;
+#  else
+	  *((Elf64_Addr *) (uintptr_t) reloc_addr)
+	    = (Elf64_Addr) value + reloc->r_addend;
+#  endif
 	  break;
 	case R_X86_64_32:
 	  value += reloc->r_addend;
@@ -417,7 +442,7 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
 #  ifndef RESOLVE_CONFLICT_FIND_MAP
 	  /* Not needed for dl-conflict.c.  */
 	case R_X86_64_PC32:
-	  value += reloc->r_addend - (Elf64_Addr) reloc_addr;
+	  value += reloc->r_addend - (ElfW(Addr)) reloc_addr;
 	  *(unsigned int *) reloc_addr = value;
 	  if (__builtin_expect (value != (int) value, 0))
 	    {
@@ -445,7 +470,7 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
 #  endif
 	case R_X86_64_IRELATIVE:
 	  value = map->l_addr + reloc->r_addend;
-	  value = ((Elf64_Addr (*) (void)) value) ();
+	  value = ((ElfW(Addr) (*) (void)) value) ();
 	  *reloc_addr = value;
 	  break;
 	default:
@@ -459,21 +484,21 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
 
 auto inline void
 __attribute ((always_inline))
-elf_machine_rela_relative (Elf64_Addr l_addr, const Elf64_Rela *reloc,
+elf_machine_rela_relative (ElfW(Addr) l_addr, const ElfW(Rela) *reloc,
 			   void *const reloc_addr_arg)
 {
-  Elf64_Addr *const reloc_addr = reloc_addr_arg;
-  assert (ELF64_R_TYPE (reloc->r_info) == R_X86_64_RELATIVE);
+  ElfW(Addr) *const reloc_addr = reloc_addr_arg;
+  assert (ELF32_R_TYPE (reloc->r_info) == R_X86_64_RELATIVE);
   *reloc_addr = l_addr + reloc->r_addend;
 }
 
 auto inline void
 __attribute ((always_inline))
 elf_machine_lazy_rel (struct link_map *map,
-		      Elf64_Addr l_addr, const Elf64_Rela *reloc)
+		      ElfW(Addr) l_addr, const ElfW(Rela) *reloc)
 {
-  Elf64_Addr *const reloc_addr = (void *) (l_addr + reloc->r_offset);
-  const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);
+  ElfW(Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned long int r_type = ELF32_R_TYPE (reloc->r_info);
 
   /* Check for unexpected PLT reloc type.  */
   if (__builtin_expect (r_type == R_X86_64_JUMP_SLOT, 1))
@@ -483,7 +508,7 @@ elf_machine_lazy_rel (struct link_map *map,
       else
 	*reloc_addr =
 	  map->l_mach.plt
-	  + (((Elf64_Addr) reloc_addr) - map->l_mach.gotplt) * 2;
+	  + (((ElfW(Addr)) reloc_addr) - map->l_mach.gotplt) * 2;
     }
   else if (__builtin_expect (r_type == R_X86_64_TLSDESC, 1))
     {
@@ -496,8 +521,8 @@ elf_machine_lazy_rel (struct link_map *map,
     }
   else if (__builtin_expect (r_type == R_X86_64_IRELATIVE, 0))
     {
-      Elf64_Addr value = map->l_addr + reloc->r_addend;
-      value = ((Elf64_Addr (*) (void)) value) ();
+      ElfW(Addr) value = map->l_addr + reloc->r_addend;
+      value = ((ElfW(Addr) (*) (void)) value) ();
       *reloc_addr = value;
     }
   else
diff --git a/sysdeps/x86_64/dl-tls.h b/sysdeps/x86_64/dl-tls.h
index c382cd8..5ddaaef 100644
--- a/sysdeps/x86_64/dl-tls.h
+++ b/sysdeps/x86_64/dl-tls.h
@@ -21,8 +21,8 @@
 /* Type used for the representation of TLS information in the GOT.  */
 typedef struct dl_tls_index
 {
-  unsigned long int ti_module;
-  unsigned long int ti_offset;
+  unsigned long long int ti_module;
+  unsigned long long int ti_offset;
 } tls_index;
 
 
diff --git a/sysdeps/x86_64/dl-tlsdesc.h b/sysdeps/x86_64/dl-tlsdesc.h
index 9e64aab..dcff33e 100644
--- a/sysdeps/x86_64/dl-tlsdesc.h
+++ b/sysdeps/x86_64/dl-tlsdesc.h
@@ -31,13 +31,19 @@
 struct tlsdesc
 {
   ptrdiff_t (*entry)(struct tlsdesc *on_rax);
+#ifndef __LP64__
+  int pad1;
+#endif
   void *arg;
+#ifndef __LP64__
+  int pad2;
+#endif
 };
 
 typedef struct dl_tls_index
 {
-  unsigned long int ti_module;
-  unsigned long int ti_offset;
+  unsigned long long int ti_module;
+  unsigned long long int ti_offset;
 } tls_index;
 
 /* Type used as the argument in a TLS descriptor for a symbol that
diff --git a/sysdeps/x86_64/dl-trampoline.S b/sysdeps/x86_64/dl-trampoline.S
index 258c609..01a41de 100644
--- a/sysdeps/x86_64/dl-trampoline.S
+++ b/sysdeps/x86_64/dl-trampoline.S
@@ -21,6 +21,10 @@
 #include <sysdep.h>
 #include <link-defines.h>
 
+#if (RTLD_SAVESPACE_SSE % 32) != 0
+# error "RTLD_SAVESPACE_SSE must be 32byte aligned"
+#endif
+
 	.text
 	.globl _dl_runtime_resolve
 	.type _dl_runtime_resolve, @function
diff --git a/sysdeps/x86_64/dl-trampoline.h b/sysdeps/x86_64/dl-trampoline.h
index 1c39579..483fda2 100644
--- a/sysdeps/x86_64/dl-trampoline.h
+++ b/sysdeps/x86_64/dl-trampoline.h
@@ -45,7 +45,7 @@
 	movq 48(%rbx), %rdx	# Load return address if needed.
 	movq 40(%rbx), %rsi	# Copy args pushed by PLT in register.
 	movq 32(%rbx), %rdi	# %rdi: link_map, %rsi: reloc_index
-	leaq 16(%rbx), %r8
+	leaq 16(%rbx), %r8	# Address of framesize
 	call _dl_profile_fixup	# Call resolver.
 
 	movq %rax, %r11		# Save return value.
@@ -141,8 +141,8 @@
 
 1:
 #endif
-	movq 16(%rbx), %r10	# Anything in framesize?
-	testq %r10, %r10
+	mov  16(%rbx), %R10_LP	# Anything in framesize?
+	test %R10_LP, %R10_LP
 	jns 3f
 
 	/* There's nothing in the frame size, so there
diff --git a/sysdeps/x86_64/elf/start.S b/sysdeps/x86_64/elf/start.S
index 3c2caf9..6c5af7b 100644
--- a/sysdeps/x86_64/elf/start.S
+++ b/sysdeps/x86_64/elf/start.S
@@ -45,15 +45,16 @@
 		before this code runs.
 
    %rsp		The stack contains the arguments and environment:
-		0(%rsp)			argc
-		8(%rsp)			argv[0]
+		0(%rsp)				argc
+		LP_SIZE(%rsp)			argv[0]
 		...
-		(8*argc)(%rsp)		NULL
-		(8*(argc+1))(%rsp)	envp[0]
+		(LP_SIZE*argc)(%rsp)		NULL
+		(LP_SIZE*(argc+1))(%rsp)	envp[0]
 		...
-					NULL
+						NULL
 */
 
+#include <sysdep.h>
 #include "bp-sym.h"
 
 	.text
@@ -78,12 +79,17 @@ _start:
 	rtld_fini:	%r9
 	stack_end:	stack.	*/
 
-	movq %rdx, %r9		/* Address of the shared library termination
+	mov %RDX_LP, %R9_LP	/* Address of the shared library termination
 				   function.  */
+#ifdef __LP64__
 	popq %rsi		/* Pop the argument count.  */
-	movq %rsp, %rdx		/* argv starts just at the current stack top.  */
+#else
+	mov (%rsp),%esi		/* Simulate popping 4byte argument count.  */
+	addl $4,%esp
+#endif
+	mov %RSP_LP, %RDX_LP	/* argv starts just at the current stack top.  */
 	/* Align the stack to a 16 byte boundary to follow the ABI.  */
-	andq  $~15, %rsp
+	and  $~15, %RSP_LP
 
 	pushq %rax		/* Push garbage because we push 8 more bytes.  */
 
@@ -93,20 +99,20 @@ _start:
 
 #ifdef SHARED
 	/* Pass address of our own entry points to .fini and .init.  */
-	movq __libc_csu_fini@GOTPCREL(%rip), %r8
-	movq __libc_csu_init@GOTPCREL(%rip), %rcx
+	mov __libc_csu_fini@GOTPCREL(%rip), %R8_LP
+	mov __libc_csu_init@GOTPCREL(%rip), %RCX_LP
 
-	movq BP_SYM (main)@GOTPCREL(%rip), %rdi
+	mov BP_SYM (main)@GOTPCREL(%rip), %RDI_LP
 
 	/* Call the user's main function, and exit with its value.
 	   But let the libc call main.	  */
 	call BP_SYM (__libc_start_main)@PLT
 #else
 	/* Pass address of our own entry points to .fini and .init.  */
-	movq $__libc_csu_fini, %r8
-	movq $__libc_csu_init, %rcx
+	mov $__libc_csu_fini, %R8_LP
+	mov $__libc_csu_init, %RCX_LP
 
-	movq $BP_SYM (main), %rdi
+	mov $BP_SYM (main), %RDI_LP
 
 	/* Call the user's main function, and exit with its value.
 	   But let the libc call main.	  */
diff --git a/sysdeps/x86_64/ffsll.c b/sysdeps/x86_64/ffsll.c
index 7213c03..f243cf7 100644
--- a/sysdeps/x86_64/ffsll.c
+++ b/sysdeps/x86_64/ffsll.c
@@ -1,7 +1,8 @@
 /* ffsll -- find first set bit in a word, counted from least significant end.
    For AMD x86-64.
    This file is part of the GNU C Library.
-   Copyright (C) 1991,92,93,94,97,98,2001 Free Software Foundation, Inc.
+   Copyright (C) 1991,92,93,94,97,98,2001,2011
+   Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@cygnus.com>.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -37,5 +38,7 @@ ffsll (long long int x)
   return cnt + 1;
 }
 
+#ifdef __LP64__
 #undef	ffsl
 weak_alias (ffsll, ffsl)
+#endif
diff --git a/sysdeps/x86_64/fpu/bits/fenv.h b/sysdeps/x86_64/fpu/bits/fenv.h
index 11859f0..9027d40 100644
--- a/sysdeps/x86_64/fpu/bits/fenv.h
+++ b/sysdeps/x86_64/fpu/bits/fenv.h
@@ -20,9 +20,6 @@
 # error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
 #endif
 
-#include <bits/wordsize.h>
-
-
 /* Define bits representing the exception.  We use the bit positions
    of the appropriate bits in the FPU control word.  */
 enum
@@ -82,7 +79,7 @@ typedef struct
     unsigned int __data_offset;
     unsigned short int __data_selector;
     unsigned short int __unused5;
-#if __WORDSIZE == 64
+#if __x86_64__
     unsigned int __mxcsr;
 #endif
   }
diff --git a/sysdeps/x86_64/fpu/bits/mathinline.h b/sysdeps/x86_64/fpu/bits/mathinline.h
index dc58f67..5a31052 100644
--- a/sysdeps/x86_64/fpu/bits/mathinline.h
+++ b/sysdeps/x86_64/fpu/bits/mathinline.h
@@ -22,8 +22,6 @@
 # error "Never use <bits/mathinline.h> directly; include <math.h> instead."
 #endif
 
-#include <bits/wordsize.h>
-
 #ifndef __extern_inline
 # define __MATH_INLINE __inline
 #else
@@ -37,7 +35,7 @@
 __MATH_INLINE int
 __NTH (__signbitf (float __x))
 {
-#if __WORDSIZE == 32
+#ifndef __x86_64__
   __extension__ union { float __f; int __i; } __u = { __f: __x };
   return __u.__i < 0;
 #else
@@ -49,7 +47,7 @@ __NTH (__signbitf (float __x))
 __MATH_INLINE int
 __NTH (__signbit (double __x))
 {
-#if __WORDSIZE == 32
+#ifndef __x86_64__
   __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
   return __u.__i[1] < 0;
 #else
diff --git a/sysdeps/x86_64/fpu/math_private.h b/sysdeps/x86_64/fpu/math_private.h
index 4be7536..a85deb4 100644
--- a/sysdeps/x86_64/fpu/math_private.h
+++ b/sysdeps/x86_64/fpu/math_private.h
@@ -25,7 +25,7 @@ while (0)
 #undef EXTRACT_WORDS64
 #define EXTRACT_WORDS64(i,d)					\
 do {								\
-  long int i_;							\
+  long long int i_;						\
   asm ("movd %1, %0" : "=rm" (i_) : "x" (d));			\
   (i) = i_;							\
 } while (0)
@@ -34,7 +34,7 @@ do {								\
 #undef INSERT_WORDS64
 #define INSERT_WORDS64(d,i) \
 do {								\
-  long int i_ = i;						\
+  long long int i_ = i;						\
   asm ("movd %1, %0" : "=x" (d) : "rm" (i_));			\
 } while (0)
 
diff --git a/sysdeps/x86_64/jmpbuf-unwind.h b/sysdeps/x86_64/jmpbuf-unwind.h
index 299a4a8..ce31ea5 100644
--- a/sysdeps/x86_64/jmpbuf-unwind.h
+++ b/sysdeps/x86_64/jmpbuf-unwind.h
@@ -29,7 +29,9 @@
   ((void *) (address) < (void *) demangle ((jmpbuf)[JB_RSP]))
 
 #define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
-  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, \
+		       (void *) (_Unwind_Ptr) _Unwind_GetCFA (_context), \
+		       _adj)
 
 static inline uintptr_t __attribute__ ((unused))
 _jmpbuf_sp (__jmp_buf regs)
diff --git a/sysdeps/x86_64/lib-names.awk b/sysdeps/x86_64/lib-names.awk
new file mode 100644
index 0000000..e402c6e
--- /dev/null
+++ b/sysdeps/x86_64/lib-names.awk
@@ -0,0 +1,114 @@
+# awk script for soversions.i -> gnu/lib-names.h; see Makeconfig.
+
+$1 != "DEFAULT" { multi = 1 }
+
+#
+{
+  lib = $2;
+  version = $3;
+  if ($3 !~ /^[0-9]/) {
+    soname = $3;
+    extra = $3;
+    sub(/\.so.*$/, "", extra);
+  }
+  else {
+    soname = lib ".so." $3;
+    extra = "";
+  }
+  soname = "\"" soname "\"";
+  lib = toupper(lib);
+  extra = toupper(extra);
+  gsub(/-/, "_", lib);
+  gsub(/-/, "_", extra);
+  if (extra) {
+    if (extra == "LD_LINUX_X32") {
+      x32_macros[$1 FS lib "_SO"] = soname;
+      x32_macros[$1 FS extra "_SO"] = soname;
+      x86_64_macros[$1 FS lib "_SO"] = "\"ld-linux-x86-64.so.2\"";
+      x86_64_macros[$1 FS "LD_LINUX_X86_64_SO"] = "\"ld-linux-x86-64.so.2\"";
+    }
+    else if (extra == "LD_LINUX_X86_64") {
+      x86_64_macros[$1 FS lib "_SO"] = soname;
+      x86_64_macros[$1 FS extra "_SO"] = soname;
+      x32_macros[$1 FS lib "_SO"] = "\"ld-linux-x32.so.2\"";
+      x32_macros[$1 FS "LD_LINUX_X32_SO"] = "\"ld-linux-x32.so.2\"";
+    }
+    else {
+      macros[$1 FS lib "_SO"] = soname;
+      macros[$1 FS extra "_SO"] = soname;
+    }
+  }
+  else {
+    macros[$1 FS lib "_SO"] = soname;
+  }
+}
+
+END {
+  print "/* This file is automatically generated.";
+  print "   It defines macros to allow user program to find the shared";
+  print "   library files which come as part of GNU libc.  */";
+  print "#ifndef __GNU_LIB_NAMES_H";
+  print "#define __GNU_LIB_NAMES_H	1";
+  print "";
+
+  pfx = multi ? "# define " : "#define ";
+  for (elt in macros) {
+    split(elt, x);
+    line = sprintf("%-40s%s", pfx x[2], macros[elt]);
+    if (x[1] in lines)
+      lines[x[1]] = lines[x[1]] "\n" line;
+    else
+      lines[x[1]] = line;
+  }
+
+  if (multi) {
+    # Print these in a fixed order so the result is identical
+    # on both sides of the coin.
+    pfx = "#  define ";
+    for (elt in x32_macros) {
+      split(elt, x);
+      line = sprintf("%-40s%s", pfx x[2], x32_macros[elt]);
+      if (x[1] in x32_lines)
+	x32_lines[x[1]] = x32_lines[x[1]] "\n" line;
+      else
+	x32_lines[x[1]] = line;
+    }
+    for (elt in x86_64_macros) {
+      split(elt, x);
+      line = sprintf("%-40s%s", pfx x[2], x86_64_macros[elt]);
+      if (x[1] in x86_64_lines)
+	x86_64_lines[x[1]] = x86_64_lines[x[1]] "\n" line;
+      else
+	x86_64_lines[x[1]] = line;
+    }
+    if (!("WORDSIZE32" in lines))
+      lines["WORDSIZE32"] = lines["DEFAULT"];
+    if (!("WORDSIZE64" in lines))
+      lines["WORDSIZE64"] = lines["DEFAULT"];
+    if (!("WORDSIZE32" in x32_lines))
+      x32_lines["WORDSIZE32"] = x32_lines["DEFAULT"];
+    if (!("WORDSIZE64" in x32_lines))
+      x32_lines["WORDSIZE64"] = x32_lines["DEFAULT"];
+    if (!("WORDSIZE32" in x86_64_lines))
+      x86_64_lines["WORDSIZE32"] = x86_64_lines["DEFAULT"];
+    if (!("WORDSIZE64" in x86_64_lines))
+      x86_64_lines["WORDSIZE64"] = x86_64_lines["DEFAULT"];
+    print "#include <bits/wordsize.h>\n";
+    print "#ifndef __x86_64__";
+    cmd = "LC_ALL=C sort"; print lines["WORDSIZE32"] | cmd; close(cmd);
+    print "#else"
+    print "# if __WORDSIZE == 32"
+    cmd = "LC_ALL=C sort"; print x32_lines["WORDSIZE64"] | cmd; close(cmd);
+    print "# else"
+    cmd = "LC_ALL=C sort"; print x86_64_lines["WORDSIZE64"] | cmd; close(cmd);
+    print "# endif"
+    cmd = "LC_ALL=C sort"; print lines["WORDSIZE64"] | cmd; close(cmd);
+    print "#endif";
+  }
+  else {
+    cmd = "LC_ALL=C sort"; print lines["DEFAULT"] | cmd; close(cmd);
+  }
+
+  print "";
+  print "#endif	/* gnu/lib-names.h */"
+}
diff --git a/sysdeps/x86_64/memcpy.S b/sysdeps/x86_64/memcpy.S
index 724d44e..5511e04 100644
--- a/sysdeps/x86_64/memcpy.S
+++ b/sysdeps/x86_64/memcpy.S
@@ -255,7 +255,7 @@ L(32after):
 
 L(fasttry):				/* first 1/2 L1 */
 #ifndef NOT_IN_libc			/* only up to this algorithm outside of libc.so */
-	movq	__x86_64_data_cache_size_half(%rip), %r11
+	mov	__x86_64_data_cache_size_half(%rip), %R11_LP
 	cmpq	%rdx, %r11		/* calculate the smaller of */
 	cmovaq	%rdx, %r11		/* remaining bytes and 1/2 L1 */
 #endif
@@ -304,7 +304,7 @@ L(fastafter):
 /* Handle large blocks smaller than 1/2 L2. */
 
 L(pretry):				/* first 1/2 L2 */
-	movq	__x86_64_shared_cache_size_half (%rip), %r8
+	mov	__x86_64_shared_cache_size_half (%rip), %R8_LP
 	cmpq	%rdx, %r8		/* calculate the lesser of */
 	cmovaq	%rdx, %r8		/* remaining bytes and 1/2 L2 */
 
diff --git a/sysdeps/x86_64/multiarch/memcmp-sse4.S b/sysdeps/x86_64/multiarch/memcmp-sse4.S
index fc439bb..1b951d6 100644
--- a/sysdeps/x86_64/multiarch/memcmp-sse4.S
+++ b/sysdeps/x86_64/multiarch/memcmp-sse4.S
@@ -309,9 +309,9 @@ L(less32bytesin256):
 	ALIGN (4)
 L(512bytesormore):
 #ifdef DATA_CACHE_SIZE_HALF
-	mov	$DATA_CACHE_SIZE_HALF, %r8
+	mov	$DATA_CACHE_SIZE_HALF, %R8_LP
 #else
-	mov	__x86_64_data_cache_size_half(%rip), %r8
+	mov	__x86_64_data_cache_size_half(%rip), %R8_LP
 #endif
 	mov	%r8, %r9
 	shr	$1, %r8
@@ -625,9 +625,9 @@ L(less32bytesin256in2alinged):
 	ALIGN (4)
 L(512bytesormorein2aligned):
 #ifdef DATA_CACHE_SIZE_HALF
-	mov	$DATA_CACHE_SIZE_HALF, %r8
+	mov	$DATA_CACHE_SIZE_HALF, %R8_LP
 #else
-	mov	__x86_64_data_cache_size_half(%rip), %r8
+	mov	__x86_64_data_cache_size_half(%rip), %R8_LP
 #endif
 	mov	%r8, %r9
 	shr	$1, %r8
diff --git a/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S b/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S
index bdd114a..a4b1fe4 100644
--- a/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S
+++ b/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S
@@ -107,9 +107,9 @@ L(144bytesormore):
 	and	$0xf, %r9
 	jz	L(shl_0)
 #ifdef DATA_CACHE_SIZE
-	mov	$DATA_CACHE_SIZE, %rcx
+	mov	$DATA_CACHE_SIZE, %RCX_LP
 #else
-	mov	__x86_64_data_cache_size(%rip), %rcx
+	mov	__x86_64_data_cache_size(%rip), %RCX_LP
 #endif
 	cmp	%rcx, %rdx
 	jae	L(gobble_mem_fwd)
@@ -123,9 +123,9 @@ L(144bytesormore):
 	ALIGN (4)
 L(copy_backward):
 #ifdef DATA_CACHE_SIZE
-	mov	$DATA_CACHE_SIZE, %rcx
+	mov	$DATA_CACHE_SIZE, %RCX_LP
 #else
-	mov	__x86_64_data_cache_size(%rip), %rcx
+	mov	__x86_64_data_cache_size(%rip), %RCX_LP
 #endif
 	shl	$1, %rcx
 	cmp	%rcx, %rdx
@@ -157,9 +157,9 @@ L(shl_0):
 	shr	$8, %r9
 	add	%rdx, %r9
 #ifdef DATA_CACHE_SIZE
-	cmp	$DATA_CACHE_SIZE_HALF, %r9
+	cmp	$DATA_CACHE_SIZE_HALF, %R9_LP
 #else
-	cmp	__x86_64_data_cache_size_half(%rip), %r9
+	cmp	__x86_64_data_cache_size_half(%rip), %R9_LP
 #endif
 	jae	L(gobble_mem_fwd)
 	sub	$0x80, %rdx
@@ -1479,9 +1479,9 @@ L(gobble_mem_fwd):
 	add	$16, %rdi
 
 #ifdef SHARED_CACHE_SIZE_HALF
-	mov	$SHARED_CACHE_SIZE_HALF, %rcx
+	mov	$SHARED_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_shared_cache_size_half(%rip), %rcx
+	mov	__x86_64_shared_cache_size_half(%rip), %RCX_LP
 #endif
 #ifdef USE_AS_MEMMOVE
 	mov	%rsi, %r9
@@ -1586,9 +1586,9 @@ L(gobble_mem_bwd):
 
 
 #ifdef SHARED_CACHE_SIZE_HALF
-	mov	$SHARED_CACHE_SIZE_HALF, %rcx
+	mov	$SHARED_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_shared_cache_size_half(%rip), %rcx
+	mov	__x86_64_shared_cache_size_half(%rip), %RCX_LP
 #endif
 #ifdef USE_AS_MEMMOVE
 	mov	%rdi, %r9
diff --git a/sysdeps/x86_64/multiarch/memcpy-ssse3.S b/sysdeps/x86_64/multiarch/memcpy-ssse3.S
index cd7e45f..0c5a82b 100644
--- a/sysdeps/x86_64/multiarch/memcpy-ssse3.S
+++ b/sysdeps/x86_64/multiarch/memcpy-ssse3.S
@@ -98,9 +98,9 @@ L(80bytesormore):
 	sub	%rcx, %rsi
 
 #ifdef SHARED_CACHE_SIZE_HALF
-	mov	$SHARED_CACHE_SIZE_HALF, %rcx
+	mov	$SHARED_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_shared_cache_size_half(%rip), %rcx
+	mov	__x86_64_shared_cache_size_half(%rip), %RCX_LP
 #endif
 	cmp	%rcx, %rdx
 	mov	%rsi, %r9
@@ -108,9 +108,9 @@ L(80bytesormore):
 	and	$0xf, %r9
 	jz	L(shl_0)
 #ifdef DATA_CACHE_SIZE_HALF
-	mov	$DATA_CACHE_SIZE_HALF, %rcx
+	mov	$DATA_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_data_cache_size_half(%rip), %rcx
+	mov	__x86_64_data_cache_size_half(%rip), %RCX_LP
 #endif
 	BRANCH_TO_JMPTBL_ENTRY (L(shl_table), %r9, 4)
 
@@ -128,9 +128,9 @@ L(copy_backward):
 	sub	%rcx, %rsi
 
 #ifdef SHARED_CACHE_SIZE_HALF
-	mov	$SHARED_CACHE_SIZE_HALF, %rcx
+	mov	$SHARED_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_shared_cache_size_half(%rip), %rcx
+	mov	__x86_64_shared_cache_size_half(%rip), %RCX_LP
 #endif
 
 	cmp	%rcx, %rdx
@@ -139,9 +139,9 @@ L(copy_backward):
 	and	$0xf, %r9
 	jz	L(shl_0_bwd)
 #ifdef DATA_CACHE_SIZE_HALF
-	mov	$DATA_CACHE_SIZE_HALF, %rcx
+	mov	$DATA_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_data_cache_size_half(%rip), %rcx
+	mov	__x86_64_data_cache_size_half(%rip), %RCX_LP
 #endif
 	BRANCH_TO_JMPTBL_ENTRY (L(shl_table_bwd), %r9, 4)
 
@@ -176,9 +176,9 @@ L(shl_0_less_64bytes):
 	ALIGN (4)
 L(shl_0_gobble):
 #ifdef DATA_CACHE_SIZE_HALF
-	cmp	$DATA_CACHE_SIZE_HALF, %rdx
+	cmp	$DATA_CACHE_SIZE_HALF, %RDX_LP
 #else
-	cmp	__x86_64_data_cache_size_half(%rip), %rdx
+	cmp	__x86_64_data_cache_size_half(%rip), %RDX_LP
 #endif
 	lea	-128(%rdx), %rdx
 	jae	L(shl_0_gobble_mem_loop)
@@ -317,9 +317,9 @@ L(shl_0_less_64bytes_bwd):
 	ALIGN (4)
 L(shl_0_gobble_bwd):
 #ifdef DATA_CACHE_SIZE_HALF
-	cmp	$DATA_CACHE_SIZE_HALF, %rdx
+	cmp	$DATA_CACHE_SIZE_HALF, %RDX_LP
 #else
-	cmp	__x86_64_data_cache_size_half(%rip), %rdx
+	cmp	__x86_64_data_cache_size_half(%rip), %RDX_LP
 #endif
 	lea	-128(%rdx), %rdx
 	jae	L(shl_0_gobble_mem_bwd_loop)
diff --git a/sysdeps/x86_64/multiarch/strcmp.S b/sysdeps/x86_64/multiarch/strcmp.S
index 8879855..9049b07 100644
--- a/sysdeps/x86_64/multiarch/strcmp.S
+++ b/sysdeps/x86_64/multiarch/strcmp.S
@@ -170,7 +170,7 @@ weak_alias (__strncasecmp, strncasecmp)
 # ifdef USE_AS_STRCASECMP_L
 ENTRY (__strcasecmp_sse42)
 	movq	__libc_tsd_LOCALE@gottpoff(%rip),%rax
-	movq	%fs:(%rax),%rdx
+	mov	%fs:(%rax),%RDX_LP
 
 	// XXX 5 byte should be before the function
 	/* 5-byte NOP.  */
@@ -181,7 +181,7 @@ END (__strcasecmp_sse42)
 # ifdef USE_AS_STRNCASECMP_L
 ENTRY (__strncasecmp_sse42)
 	movq	__libc_tsd_LOCALE@gottpoff(%rip),%rax
-	movq	%fs:(%rax),%rcx
+	mov	%fs:(%rax),%RCX_LP
 
 	// XXX 5 byte should be before the function
 	/* 5-byte NOP.  */
@@ -201,9 +201,9 @@ STRCMP_SSE42:
 	/* We have to fall back on the C implementation for locales
 	   with encodings not matching ASCII for single bytes.  */
 #  if LOCALE_T___LOCALES != 0 || LC_CTYPE != 0
-	movq	LOCALE_T___LOCALES+LC_CTYPE*8(%rdx), %rax
+	mov	LOCALE_T___LOCALES+LC_CTYPE*LP_SIZE(%rdx), %RAX_LP
 #  else
-	movq	(%rdx), %rax
+	mov	(%rdx), %RAX_LP
 #  endif
 	testl	$0, LOCALE_DATA_VALUES+_NL_CTYPE_NONASCII_CASE*SIZEOF_VALUES(%rax)
 	jne	__strcasecmp_l_nonascii
@@ -212,9 +212,9 @@ STRCMP_SSE42:
 	/* We have to fall back on the C implementation for locales
 	   with encodings not matching ASCII for single bytes.  */
 #  if LOCALE_T___LOCALES != 0 || LC_CTYPE != 0
-	movq	LOCALE_T___LOCALES+LC_CTYPE*8(%rcx), %rax
+	mov	LOCALE_T___LOCALES+LC_CTYPE*LP_SIZE(%rcx), %RAX_LP
 #  else
-	movq	(%rcx), %rax
+	mov	(%rcx), %RAX_LP
 #  endif
 	testl	$0, LOCALE_DATA_VALUES+_NL_CTYPE_NONASCII_CASE*SIZEOF_VALUES(%rax)
 	jne	__strncasecmp_l_nonascii
diff --git a/sysdeps/x86_64/preconfigure b/sysdeps/x86_64/preconfigure
new file mode 100644
index 0000000..c54eeab
--- /dev/null
+++ b/sysdeps/x86_64/preconfigure
@@ -0,0 +1,18 @@
+case "$base_machine" in
+x86_64)
+  stubs_biarch_h=sysdeps/x86_64/stubs-biarch.h
+  lib_names_awk=sysdeps/x86_64/lib-names.awk
+  use_default_syscall_macros=no
+  if echo __LP64__ | ${CC-cc} $CFLAGS $CPPFLAGS -E - | grep __LP64__ > /dev/null; then
+    machine=x86_64/x32
+    data_machine=x32
+    libc_cv_slibdir="/libx32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/libx32';
+      # Locale data can be shared.
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+  else
+    machine=x86_64/64
+  fi
+esac
diff --git a/sysdeps/x86_64/setjmp.S b/sysdeps/x86_64/setjmp.S
index a66b0e6..68340f1 100644
--- a/sysdeps/x86_64/setjmp.S
+++ b/sysdeps/x86_64/setjmp.S
@@ -26,7 +26,7 @@ ENTRY (__sigsetjmp)
 	movq %rbx, (JB_RBX*8)(%rdi)
 #ifdef PTR_MANGLE
 	movq %rbp, %rax
-	PTR_MANGLE (%rax)
+	PTR_MANGLE (%RAX_LP)
 	movq %rax, (JB_RBP*8)(%rdi)
 #else
 	movq %rbp, (JB_RBP*8)(%rdi)
@@ -37,12 +37,12 @@ ENTRY (__sigsetjmp)
 	movq %r15, (JB_R15*8)(%rdi)
 	leaq 8(%rsp), %rdx	/* Save SP as it will be after we return.  */
 #ifdef PTR_MANGLE
-	PTR_MANGLE (%rdx)
+	PTR_MANGLE (%RDX_LP)
 #endif
 	movq %rdx, (JB_RSP*8)(%rdi)
 	movq (%rsp), %rax	/* Save PC we are returning to now.  */
 #ifdef PTR_MANGLE
-	PTR_MANGLE (%rax)
+	PTR_MANGLE (%RAX_LP)
 #endif
 	movq %rax, (JB_PC*8)(%rdi)
 
diff --git a/sysdeps/x86_64/stackinfo.h b/sysdeps/x86_64/stackinfo.h
index d4fc25f..179e421 100644
--- a/sysdeps/x86_64/stackinfo.h
+++ b/sysdeps/x86_64/stackinfo.h
@@ -35,10 +35,10 @@
    for which they need to act as barriers as well, hence the additional
    (unnecessary) parameters.  */
 #define stackinfo_get_sp() \
-  ({ void *p__; asm volatile ("mov %%rsp, %0" : "=r" (p__)); p__; })
+  ({ void *p__; asm volatile ("mov %%" RSP_LP ", %0" : "=r" (p__)); p__; })
 #define stackinfo_sub_sp(ptr) \
   ({ ptrdiff_t d__;						\
-     asm volatile ("sub %%rsp, %0" : "=r" (d__) : "0" (ptr));	\
+     asm volatile ("sub %%" RSP_LP " , %0" : "=r" (d__) : "0" (ptr));	\
      d__; })
 
 #endif	/* stackinfo.h */
diff --git a/sysdeps/x86_64/strcmp.S b/sysdeps/x86_64/strcmp.S
index 165073e..9849fb6 100644
--- a/sysdeps/x86_64/strcmp.S
+++ b/sysdeps/x86_64/strcmp.S
@@ -97,7 +97,7 @@
 
 ENTRY2 (__strcasecmp)
 	movq	__libc_tsd_LOCALE@gottpoff(%rip),%rax
-	movq	%fs:(%rax),%rdx
+	mov	%fs:(%rax),%RDX_LP
 
 	// XXX 5 byte should be before the function
 	/* 5-byte NOP.  */
@@ -116,7 +116,7 @@ libc_hidden_def (__strcasecmp)
 
 ENTRY2 (__strncasecmp)
 	movq	__libc_tsd_LOCALE@gottpoff(%rip),%rax
-	movq	%fs:(%rax),%rcx
+	mov	%fs:(%rax),%RCX_LP
 
 	// XXX 5 byte should be before the function
 	/* 5-byte NOP.  */
@@ -153,9 +153,9 @@ END (BP_SYM (STRCMP))
 	/* We have to fall back on the C implementation for locales
 	   with encodings not matching ASCII for single bytes.  */
 #  if LOCALE_T___LOCALES != 0 || LC_CTYPE != 0
-	movq	LOCALE_T___LOCALES+LC_CTYPE*8(%rdx), %rax
+	mov	LOCALE_T___LOCALES+LC_CTYPE*LP_SIZE(%rdx), %RAX_LP
 #  else
-	movq	(%rdx), %rax
+	mov	(%rdx), %RAX_LP
 #  endif
 	testl	$0, LOCALE_DATA_VALUES+_NL_CTYPE_NONASCII_CASE*SIZEOF_VALUES(%rax)
 	jne	__strcasecmp_l_nonascii
@@ -163,9 +163,9 @@ END (BP_SYM (STRCMP))
 	/* We have to fall back on the C implementation for locales
 	   with encodings not matching ASCII for single bytes.  */
 #  if LOCALE_T___LOCALES != 0 || LC_CTYPE != 0
-	movq	LOCALE_T___LOCALES+LC_CTYPE*8(%rcx), %rax
+	mov	LOCALE_T___LOCALES+LC_CTYPE*LP_SIZE(%rcx), %RAX_LP
 #  else
-	movq	(%rcx), %rax
+	mov	(%rcx), %RAX_LP
 #  endif
 	testl	$0, LOCALE_DATA_VALUES+_NL_CTYPE_NONASCII_CASE*SIZEOF_VALUES(%rax)
 	jne	__strncasecmp_l_nonascii
diff --git a/sysdeps/x86_64/stubs-biarch.h b/sysdeps/x86_64/stubs-biarch.h
new file mode 100644
index 0000000..2579ec6
--- /dev/null
+++ b/sysdeps/x86_64/stubs-biarch.h
@@ -0,0 +1,8 @@
+/* This file selects the right generated file of `__stub_FUNCTION' macros
+   based on the architecture being compiled for.  */
+
+#ifdef __x86_64__
+# include <gnu/stubs-64.h>
+#else
+# include <gnu/stubs-32.h>
+#endif
diff --git a/sysdeps/x86_64/sysdep.h b/sysdeps/x86_64/sysdep.h
index 1d35f8f..d02ad9a 100644
--- a/sysdeps/x86_64/sysdep.h
+++ b/sysdeps/x86_64/sysdep.h
@@ -114,4 +114,66 @@ lose:									      \
 # endif
 #endif
 
+/* Long and pointer size in bytes.  */
+#define LP_SIZE	8
+
+/* Instruction to move long and pointer.  */
+#define MOVE_LP movq
+
+/* Instruction to add long and pointer.  */
+#define ADD_LP addq
+
+/* Instruction to substract long and pointer.  */
+#define SUB_LP subq
+
+/* Instruction to compare against long and pointer.  */
+#define CMP_LP cmpq
+
+/* Assembler address directive. */
+#define ASM_ADDR .quad
+
+/* Registers to hold long and pointer.  */
+#define RAX_LP	rax
+#define RBP_LP	rbp
+#define RBX_LP	rbx
+#define RCX_LP	rcx
+#define RDI_LP	rdi
+#define RDX_LP	rdx
+#define RSI_LP	rsi
+#define RSP_LP	rsp
+#define R8_LP	r8
+#define R9_LP	r9
+#define R10_LP	r10
+#define R11_LP	r11
+#define R12_LP	r12
+#define R13_LP	r13
+#define R14_LP	r14
+#define R15_LP	r15
+
+#else	/* __ASSEMBLER__ */
+
+/* Long and pointer size in bytes.  */
+#define LP_SIZE "8"
+
+/* Assembler address directive. */
+#define ASM_ADDR ".quad"
+
+/* Registers to hold long and pointer.  */
+#define RAX_LP	"rax"
+#define RBP_LP	"rbp"
+#define RBX_LP	"rbx"
+#define RCX_LP	"rcx"
+#define RDI_LP	"rdi"
+#define RDX_LP	"rdx"
+#define RSI_LP	"rsi"
+#define RSP_LP	"rsp"
+#define R8_LP	"r8"
+#define R9_LP	"r9"
+#define R10_LP	"r10"
+#define R11_LP	"r11"
+#define R12_LP	"r12"
+#define R13_LP	"r13"
+#define R14_LP	"r14"
+#define R15_LP	"r15"
+
 #endif	/* __ASSEMBLER__ */
diff --git a/sysdeps/x86_64/x32/Implies b/sysdeps/x86_64/x32/Implies
new file mode 100644
index 0000000..6d48462
--- /dev/null
+++ b/sysdeps/x86_64/x32/Implies
@@ -0,0 +1,6 @@
+x86_64/fpu
+wordsize-32
+ieee754/ldbl-96
+ieee754/dbl-64/wordsize-64
+ieee754/dbl-64
+ieee754/flt-32
diff --git a/sysdeps/x86_64/x32/Makefile b/sysdeps/x86_64/x32/Makefile
new file mode 100644
index 0000000..5b3ac54
--- /dev/null
+++ b/sysdeps/x86_64/x32/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(subdir),malloc)
+CFLAGS-malloc.c += -DMALLOC_ALIGNMENT=16
+endif
diff --git a/sysdeps/x86_64/x32/bits/wordsize.h b/sysdeps/x86_64/x32/bits/wordsize.h
new file mode 100644
index 0000000..cb59cd2
--- /dev/null
+++ b/sysdeps/x86_64/x32/bits/wordsize.h
@@ -0,0 +1,7 @@
+/* Determine the wordsize from the preprocessor defines.  */
+
+#if defined __LP64__
+# define __WORDSIZE	64
+#else
+# define __WORDSIZE	32
+#endif
diff --git a/sysdeps/x86_64/x32/divdi3.c b/sysdeps/x86_64/x32/divdi3.c
new file mode 100644
index 0000000..bc7b4c4
--- /dev/null
+++ b/sysdeps/x86_64/x32/divdi3.c
@@ -0,0 +1 @@
+/* Fortunately nothing to do.  */
diff --git a/sysdeps/x86_64/x32/dl-machine.h b/sysdeps/x86_64/x32/dl-machine.h
new file mode 100644
index 0000000..2364910
--- /dev/null
+++ b/sysdeps/x86_64/x32/dl-machine.h
@@ -0,0 +1,86 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  x32 version.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/x86_64/dl-machine.h>
+
+#ifndef x32_dl_machine_h
+#define x32_dl_machine_h
+
+#undef ARCH_LA_PLTENTER
+#undef ARCH_LA_PLTEXIT
+#undef RTLD_START
+
+/* Names of the architecture-specific auditing callback functions.  */
+#define ARCH_LA_PLTENTER x32_gnu_pltenter
+#define ARCH_LA_PLTEXIT x32_gnu_pltexit
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+#define RTLD_START asm ("\n\
+.text\n\
+	.align 16\n\
+.globl _start\n\
+.globl _dl_start_user\n\
+_start:\n\
+	movl %esp, %edi\n\
+	call _dl_start\n\
+_dl_start_user:\n\
+	# Save the user entry point address in %r12.\n\
+	movl %eax, %r12d\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	movl _dl_skip_args(%rip), %eax\n\
+	# Pop the original argument count.\n\
+	movl (%rsp), %edx\n\
+	addl $4,%esp\n\
+	# Adjust the stack pointer to skip _dl_skip_args words.\n\
+	lea (%rsp,%rax,4), %esp\n\
+	# Subtract _dl_skip_args from argc.\n\
+	subl %eax, %edx\n\
+	# Push argc back on the stack.\n\
+	subl $4,%esp\n\
+	movl %edx, (%rsp)\n\
+	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env)\n\
+	# argc -> rsi\n\
+	movl %edx, %esi\n\
+	# Save %rsp value in %r13.\n\
+	movl %esp, %r13d\n\
+	# And align stack for the _dl_init_internal call. \n\
+	and $-16, %esp\n\
+	# _dl_loaded -> rdi\n\
+	movl _rtld_local(%rip), %edi\n\
+	# env -> rcx\n\
+	lea 8(%r13,%rdx,4), %ecx\n\
+	# argv -> rdx\n\
+	lea 4(%r13), %edx\n\
+	# Clear %rbp to mark outermost frame obviously even for constructors.\n\
+	xorl %ebp, %ebp\n\
+	# Call the function to run the initializers.\n\
+	call _dl_init_internal@PLT\n\
+	# Pass our finalizer function to the user in %rdx, as per ELF ABI.\n\
+	lea _dl_fini(%rip), %edx\n\
+	# And make sure %rsp points to argc stored on the stack.\n\
+	movl %r13d, %esp\n\
+	# Jump to the user's entry point.\n\
+	jmp *%r12\n\
+.previous\n\
+");
+
+#endif /* !x32_dl_machine_h */
diff --git a/sysdeps/x86_64/x32/ffs.c b/sysdeps/x86_64/x32/ffs.c
new file mode 100644
index 0000000..393f501
--- /dev/null
+++ b/sysdeps/x86_64/x32/ffs.c
@@ -0,0 +1 @@
+#include <sysdeps/i386/i686/ffs.c>
diff --git a/sysdeps/x86_64/x32/gmp-mparam.h b/sysdeps/x86_64/x32/gmp-mparam.h
new file mode 100644
index 0000000..33cb36e
--- /dev/null
+++ b/sysdeps/x86_64/x32/gmp-mparam.h
@@ -0,0 +1,33 @@
+/* gmp-mparam.h -- Compiler/machine parameter header file.
+
+Copyright (C) 2011 Free Software Foundation, Inc.
+
+This file is part of the GNU MP Library.
+
+The GNU MP Library is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or (at your
+option) any later version.
+
+The GNU MP Library is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to
+the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if defined __GMP_H__ && ! defined _LONG_LONG_LIMB
+#error "Included too late for _LONG_LONG_LIMB to take effect"
+#endif
+
+#define _LONG_LONG_LIMB
+#define BITS_PER_MP_LIMB 64
+#define BYTES_PER_MP_LIMB 8
+#define BITS_PER_LONGINT __WORDSIZE
+#define BITS_PER_INT 32
+#define BITS_PER_SHORTINT 16
+#define BITS_PER_CHAR 8
+/* Prefer long long.  */
+#define PREFER_LONG_LONG
diff --git a/sysdeps/x86_64/x32/shlib-versions b/sysdeps/x86_64/x32/shlib-versions
new file mode 100644
index 0000000..a0d353d
--- /dev/null
+++ b/sysdeps/x86_64/x32/shlib-versions
@@ -0,0 +1,2 @@
+x86_64-.*-linux.*       DEFAULT			GLIBC_2.11
+x86_64-.*-linux.*	ld=ld-linux-x32.so.2	GLIBC_2.11
diff --git a/sysdeps/x86_64/x32/symbol-hacks.h b/sysdeps/x86_64/x32/symbol-hacks.h
new file mode 100644
index 0000000..bc7b4c4
--- /dev/null
+++ b/sysdeps/x86_64/x32/symbol-hacks.h
@@ -0,0 +1 @@
+/* Fortunately nothing to do.  */
diff --git a/sysdeps/x86_64/x32/sysdep.h b/sysdeps/x86_64/x32/sysdep.h
new file mode 100644
index 0000000..0bb21f8
--- /dev/null
+++ b/sysdeps/x86_64/x32/sysdep.h
@@ -0,0 +1,98 @@
+/* Assembler macros for x32.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#undef ASM_ADDR
+#undef LP_SIZE
+
+#undef RAX_LP
+#undef RBP_LP
+#undef RBX_LP
+#undef RCX_LP
+#undef RDI_LP
+#undef RDX_LP
+#undef RSP_LP
+#undef RSI_LP
+#undef R8_LP
+#undef R9_LP
+#undef R10_LP
+#undef R11_LP
+#undef R12_LP
+#undef R13_LP
+#undef R14_LP
+#undef R15_LP
+
+#ifdef	__ASSEMBLER__
+
+# define LP_SIZE 4
+
+# undef MOVE_LP
+# define MOVE_LP movl
+
+# undef ADD_LP
+# define ADD_LP addl
+
+# undef SUB_LP
+# define SUB_LP subl
+
+# undef CMP_LP
+# define CMP_LP cmpl
+
+# define ASM_ADDR .long
+
+# define RAX_LP	eax
+# define RBP_LP	ebp
+# define RBX_LP	ebx
+# define RCX_LP	ecx
+# define RDI_LP	edi
+# define RDX_LP	edx
+# define RSI_LP	esi
+# define RSP_LP	esp
+# define R8_LP	r8d
+# define R9_LP	r9d
+# define R10_LP	r10d
+# define R11_LP	r11d
+# define R12_LP	r12d
+# define R13_LP	r13d
+# define R14_LP	r14d
+# define R15_LP	r15d
+
+#else	/* __ASSEMBLER__ */
+
+# define LP_SIZE "4"
+
+# define ASM_ADDR ".long"
+
+# define RAX_LP	"eax"
+# define RBP_LP	"ebp"
+# define RBX_LP	"ebx"
+# define RCX_LP	"ecx"
+# define RDI_LP	"edi"
+# define RDX_LP	"edx"
+# define RSI_LP	"esi"
+# define RSP_LP	"esp"
+# define R8_LP	"r8d"
+# define R9_LP	"r9d"
+# define R10_LP	"r10d"
+# define R11_LP	"r11d"
+# define R12_LP	"r12d"
+# define R13_LP	"r13d"
+# define R14_LP	"r14d"
+# define R15_LP	"r15d"
+
+#endif	/* __ASSEMBLER__ */
diff --git a/time/mktime.c b/time/mktime.c
index e47d696..af0457f 100644
--- a/time/mktime.c
+++ b/time/mktime.c
@@ -169,7 +169,7 @@ ydhms_diff (long int year1, long int yday1, int hour1, int min1, int sec1,
 {
   verify (C99_integer_division, -1 / 2 == 0);
   verify (long_int_year_and_yday_are_wide_enough,
-	  INT_MAX <= LONG_MAX / 2 || TIME_T_MAX <= UINT_MAX);
+	  INT_MAX <= TIME_T_MAX / 2 || TIME_T_MAX <= UINT_MAX);
 
   /* Compute intervening leap days correctly even if year is negative.
      Take care to avoid integer overflow here.  */
diff --git a/time/offtime.c b/time/offtime.c
index c0b1db5..312ad42 100644
--- a/time/offtime.c
+++ b/time/offtime.c
@@ -36,6 +36,8 @@ __offtime (t, offset, tp)
   const unsigned short int *ip;
 
   days = *t / SECS_PER_DAY;
+  if (days != *t / SECS_PER_DAY)
+    goto overflow;
   rem = *t % SECS_PER_DAY;
   rem += offset;
   while (rem < 0)
@@ -66,6 +68,9 @@ __offtime (t, offset, tp)
       /* Guess a corrected year, assuming 365 days per year.  */
       long int yg = y + days / 365 - (days % 365 < 0);
 
+      if (yg < 0)
+	goto overflow;
+
       /* Adjust DAYS and Y to match the guessed year.  */
       days -= ((yg - y) * 365
 	       + LEAPS_THRU_END_OF (yg - 1)
@@ -75,6 +80,7 @@ __offtime (t, offset, tp)
   tp->tm_year = y - 1900;
   if (tp->tm_year != y - 1900)
     {
+overflow:
       /* The year cannot be represented due to overflow.  */
       __set_errno (EOVERFLOW);
       return 0;
diff --git a/time/time.h b/time/time.h
index fee8d27..c448ee2 100644
--- a/time/time.h
+++ b/time/time.h
@@ -120,7 +120,7 @@ typedef __timer_t timer_t;
 struct timespec
   {
     __time_t tv_sec;		/* Seconds.  */
-    long int tv_nsec;		/* Nanoseconds.  */
+    __snseconds_t tv_nsec;	/* Nanoseconds.  */
   };
 
 #endif /* timespec not defined and <time.h> or need timespec.  */
