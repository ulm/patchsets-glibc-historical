--- libc-orig/linuxthreads/sysdeps/unix/sysv/linux/hppa/sysdep-cancel.h	2003-10-10 21:28:08.000000000 -0400
+++ libc/linuxthreads/sysdeps/unix/sysv/linux/hppa/sysdep-cancel.h	2004-09-22 20:05:32.000000000 -0400
@@ -29,61 +29,109 @@
 #  define NO_ERROR -0x1000
 # endif
 
+/* The syscall cancellation mechanism requires userspace
+   assistance, the following code does roughly this:
+
+   	do arguments (read arg5 and arg6 to registers)
+	setup frame
+	
+	check if there are threads, yes jump to pseudo_cancel
+	
+	unthreaded:
+		syscall
+		check syscall return (jump to pre_end)
+		set errno
+		set return to -1
+		(jump to pre_end)
+		
+	pseudo_cancel:
+		cenable
+		syscall
+		cdisable
+		check syscall return (jump to pre_end)
+		set errno
+		set return to -1
+		
+	pre_end
+		restore stack
+	
+	It is expected that 'ret' and 'END' macros will
+	append an 'undo arguments' and 'return' to the 
+	this PSEUDO macro. */
+   
 # undef PSEUDO
 # define PSEUDO(name, syscall_name, args)				\
-  ENTRY (name)								\
-    SINGLE_THREAD_P					ASM_LINE_SEP	\
-    cmpib,<> 0,%ret0,Lpseudo_cancel			ASM_LINE_SEP	\
-    nop							ASM_LINE_SEP	\
-    DO_CALL(syscall_name, args)				ASM_LINE_SEP	\
-    /* DONE! */						ASM_LINE_SEP	\
-    bv 0(2)						ASM_LINE_SEP	\
-    nop							ASM_LINE_SEP	\
-  Lpseudo_cancel:					ASM_LINE_SEP	\
-    /* store return ptr */				ASM_LINE_SEP	\
-    stw %rp, -20(%sr0,%sp)				ASM_LINE_SEP	\
-    /* save syscall args */				ASM_LINE_SEP	\
-    PUSHARGS_##args /* MACRO */				ASM_LINE_SEP	\
-    STW_PIC						ASM_LINE_SEP	\
-    CENABLE /* FUNC CALL */				ASM_LINE_SEP	\
-    ldo 64(%sp), %sp					ASM_LINE_SEP	\
-    ldo -64(%sp), %sp					ASM_LINE_SEP	\
-    LDW_PIC						ASM_LINE_SEP	\
-    /* restore syscall args */				ASM_LINE_SEP	\
-    POPARGS_##args					ASM_LINE_SEP	\
-    /* save r4 in arg0 stack slot */			ASM_LINE_SEP	\
-    stw %r4, -36(%sr0,%sp)				ASM_LINE_SEP	\
-    /* save mask from cenable */			ASM_LINE_SEP	\
-    copy %ret0, %r4					ASM_LINE_SEP	\
-    ble 0x100(%sr2,%r0)					ASM_LINE_SEP    \
-    ldi SYS_ify (syscall_name), %r20			ASM_LINE_SEP	\
-    LDW_PIC						ASM_LINE_SEP	\
-    /* pass mask as arg0 to cdisable */			ASM_LINE_SEP	\
-    copy %r4, %r26					ASM_LINE_SEP	\
-    copy %ret0, %r4					ASM_LINE_SEP	\
-    CDISABLE						ASM_LINE_SEP	\
-    ldo 64(%sp), %sp					ASM_LINE_SEP	\
-    ldo -64(%sp), %sp					ASM_LINE_SEP	\
-    LDW_PIC						ASM_LINE_SEP	\
-    /* compare error */					ASM_LINE_SEP	\
-    ldi NO_ERROR,%r1					ASM_LINE_SEP	\
-    /* branch if no error */				ASM_LINE_SEP	\
-    cmpb,>>=,n %r1,%r4,Lpre_end				ASM_LINE_SEP	\
-    nop							ASM_LINE_SEP	\
-    SYSCALL_ERROR_HANDLER				ASM_LINE_SEP	\
-    ldo 64(%sp), %sp					ASM_LINE_SEP	\
-    ldo -64(%sp), %sp					ASM_LINE_SEP	\
-    /* No need to LDW_PIC */				ASM_LINE_SEP	\
-    /* make syscall res value positive */		ASM_LINE_SEP	\
-    sub %r0, %r4, %r4					ASM_LINE_SEP	\
-    /* store into errno location */			ASM_LINE_SEP	\
-    stw %r4, 0(%sr0,%ret0)				ASM_LINE_SEP	\
-    /* return -1 */					ASM_LINE_SEP	\
-    ldo -1(%r0), %ret0					ASM_LINE_SEP	\
-  Lpre_end:						ASM_LINE_SEP	\
-    ldw -20(%sr0,%sp), %rp             			ASM_LINE_SEP	\
-    /* No need to LDW_PIC */				ASM_LINE_SEP	\
-    ldw -36(%sr0,%sp), %r4				ASM_LINE_SEP
+	ENTRY (name)							\
+	DOARGS_##args					ASM_LINE_SEP	\
+	copy TREG, %r1					ASM_LINE_SEP	\
+	copy %sp, TREG					ASM_LINE_SEP	\
+	stwm %r1, 64(%sp)				ASM_LINE_SEP	\
+	stw %rp, -20(%sp)				ASM_LINE_SEP	\
+	stw TREG, -4(%sp)				ASM_LINE_SEP	\
+	/* Done setting up frame, continue... */	ASM_LINE_SEP	\
+	SINGLE_THREAD_P					ASM_LINE_SEP	\
+	cmpib,<>,n 0,%ret0,L(pseudo_cancel)		ASM_LINE_SEP	\
+L(unthreaded):						ASM_LINE_SEP	\
+	/* Save r19 */					ASM_LINE_SEP	\
+	SAVE_PIC(TREG)					ASM_LINE_SEP	\
+	/* Do syscall, delay loads # */			ASM_LINE_SEP	\
+	ble  0x100(%sr2,%r0)				ASM_LINE_SEP	\
+	ldi SYS_ify (syscall_name), %r20 /* delay */	ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1				ASM_LINE_SEP	\
+	cmpb,>>=,n %r1,%ret0,L(pre_end)			ASM_LINE_SEP	\
+	/* Restore r19 from TREG */			ASM_LINE_SEP	\
+	LOAD_PIC(TREG) /* delay */			ASM_LINE_SEP	\
+	SYSCALL_ERROR_HANDLER				ASM_LINE_SEP	\
+	/* Use TREG for temp storage */			ASM_LINE_SEP	\
+	copy %ret0, TREG /* delay */			ASM_LINE_SEP	\
+	/* OPTIMIZE: Don't reload r19 */		ASM_LINE_SEP	\
+	/* do a -1*syscall_ret0 */			ASM_LINE_SEP	\
+	sub %r0, TREG, TREG				ASM_LINE_SEP	\
+	/* Store into errno location */			ASM_LINE_SEP	\
+	stw TREG, 0(%sr0,%ret0)				ASM_LINE_SEP	\
+	b L(pre_end)					ASM_LINE_SEP	\
+	/* return -1 as error */			ASM_LINE_SEP	\
+	ldo -1(%r0), %ret0 /* delay */			ASM_LINE_SEP	\
+L(pseudo_cancel):					ASM_LINE_SEP	\
+	PUSHARGS_##args /* Save args */			ASM_LINE_SEP	\
+	/* Save r19 into TREG */			ASM_LINE_SEP	\
+	CENABLE /* FUNC CALL */				ASM_LINE_SEP	\
+	SAVE_PIC(TREG) /* delay */			ASM_LINE_SEP	\
+	/* restore syscall args */			ASM_LINE_SEP	\
+	POPARGS_##args					ASM_LINE_SEP	\
+	/* save mask from cenable (use stub rp slot) */	ASM_LINE_SEP	\
+	stw %ret0, -24(%sp)				ASM_LINE_SEP	\
+	/* ... SYSCALL ... */				ASM_LINE_SEP	\
+	ble 0x100(%sr2,%r0)				ASM_LINE_SEP    \
+	ldi SYS_ify (syscall_name), %r20 /* delay */	ASM_LINE_SEP	\
+	/* ............... */				ASM_LINE_SEP	\
+	LOAD_PIC(TREG)					ASM_LINE_SEP	\
+	/* pass mask as arg0 to cdisable */		ASM_LINE_SEP	\
+	ldw -24(%sp), %r26				ASM_LINE_SEP	\
+	CDISABLE					ASM_LINE_SEP	\
+	stw %ret0, -24(%sp) /* delay */			ASM_LINE_SEP	\
+	/* Restore syscall return (use arg regs) */	ASM_LINE_SEP	\
+	ldw -24(%sp), %r26				ASM_LINE_SEP	\
+	/* compare error */				ASM_LINE_SEP	\
+	ldi NO_ERROR,%r1				ASM_LINE_SEP	\
+	/* branch if no error */			ASM_LINE_SEP	\
+	cmpb,>>=,n %r1,%r26,L(pre_end)			ASM_LINE_SEP	\
+	LOAD_PIC(TREG)	/* cond. nullify */		ASM_LINE_SEP	\
+	copy %r26, TREG	/* save syscall return */	ASM_LINE_SEP	\
+	SYSCALL_ERROR_HANDLER				ASM_LINE_SEP	\
+	/* make syscall res value positive */		ASM_LINE_SEP	\
+	sub %r0, TREG, TREG	/* delay */		ASM_LINE_SEP	\
+	/* No need to LOAD_PIC */			ASM_LINE_SEP	\
+	/* store into errno location */			ASM_LINE_SEP	\
+	stw TREG, 0(%sr0,%ret0)				ASM_LINE_SEP	\
+	/* return -1 */					ASM_LINE_SEP	\
+	ldo -1(%r0), %ret0				ASM_LINE_SEP	\
+L(pre_end):						ASM_LINE_SEP	\
+	/* Restore rp before exit */			ASM_LINE_SEP	\
+	ldw -84(%sr0,%sp), %rp				ASM_LINE_SEP	\
+	/* Undo frame */				ASM_LINE_SEP	\
+	ldwm -64(%sp),TREG				ASM_LINE_SEP	\
+	/* No need to LOAD_PIC */			ASM_LINE_SEP
 
 /* Save arguments into our frame */
 # define PUSHARGS_0	/* nothing to do */
@@ -91,8 +139,8 @@
 # define PUSHARGS_2	PUSHARGS_1 stw %r25, -40(%sr0,%sp)	ASM_LINE_SEP
 # define PUSHARGS_3	PUSHARGS_2 stw %r24, -44(%sr0,%sp)	ASM_LINE_SEP
 # define PUSHARGS_4	PUSHARGS_3 stw %r23, -48(%sr0,%sp)	ASM_LINE_SEP
-# define PUSHARGS_5	PUSHARGS_4 /* Args are on the stack... */
-# define PUSHARGS_6	PUSHARGS_5
+# define PUSHARGS_5	PUSHARGS_4 stw %r22, -52(%sr0,%sp)	ASM_LINE_SEP 
+# define PUSHARGS_6	PUSHARGS_5 stw %r21, -56(%sr0,%sp)	ASM_LINE_SEP
 
 /* Bring them back from the stack */
 # define POPARGS_0	/* nothing to do */
@@ -101,7 +149,7 @@
 # define POPARGS_3	POPARGS_2 ldw -44(%sr0,%sp), %r24	ASM_LINE_SEP
 # define POPARGS_4	POPARGS_3 ldw -48(%sr0,%sp), %r23	ASM_LINE_SEP
 # define POPARGS_5	POPARGS_4 ldw -52(%sr0,%sp), %r22	ASM_LINE_SEP
-# define POPARGS_6	POPARGS_5 ldw -54(%sr0,%sp), %r21	ASM_LINE_SEP
+# define POPARGS_6	POPARGS_5 ldw -56(%sr0,%sp), %r21	ASM_LINE_SEP
 
 # ifdef IS_IN_libpthread
 #  ifdef PIC
@@ -163,10 +211,10 @@
 /* This ALT version requires newer kernel support */
 #  define SINGLE_THREAD_P_MFCTL						\
 	mfctl %cr27, %ret0					ASM_LINE_SEP	\
-	cmpib,= NO_THREAD_CR27,%ret0,Lstp			ASM_LINE_SEP	\
+	cmpib,= NO_THREAD_CR27,%ret0,L(stp)			ASM_LINE_SEP	\
 	nop							ASM_LINE_SEP	\
 	ldw MULTIPLE_THREADS_OFFSET(%sr0,%ret0),%ret0		ASM_LINE_SEP	\
- Lstp:								ASM_LINE_SEP
+L(stp):								ASM_LINE_SEP
 #  ifdef PIC
 /* Slower version uses GOT to get value of __local_multiple_threads */
 #   define SINGLE_THREAD_P							\
@@ -174,7 +222,7 @@
 	ldw RT%__local_multiple_threads(%sr0,%r1), %ret0	ASM_LINE_SEP	\
 	ldw 0(%sr0,%ret0), %ret0 				ASM_LINE_SEP
 #  else
-  /* Slow non-pic version using DP */
+/* Slow non-pic version using DP */
 #   define SINGLE_THREAD_P								\
 	addil LR%__local_multiple_threads-$global$,%r27  		ASM_LINE_SEP	\
 	ldw RR%__local_multiple_threads-$global$(%sr0,%r1),%ret0	ASM_LINE_SEP
