g d remotes/origin/release/2.15/master...remotes/origin/hjl/x32/release/2.15

diff --git a/ChangeLog.x32 b/ChangeLog.x32
new file mode 100644
index 0000000..e088046
--- /dev/null
+++ b/ChangeLog.x32
@@ -0,0 +1,813 @@
+2012-05-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S: Use R*_LP
+	to operate on SP, PC and pointers.  Don't use PTR_DEMANGLE on
+	rbp.
+	* sysdeps/x86_64/__longjmp.S: Don't use PTR_DEMANGLE on rbp.
+	Use R*_LP on SP.
+	* sysdeps/x86_64/setjmp.S: Don't use PTR_MANGLE on rbp. Use
+	R*_LP on SP and PC.
+
+2012-05-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/64/bits/wordsize.h: Check __ILP32__ instead
+	of __LP64__.
+	* sysdeps/x86_64/x32/bits/wordsize.h: Likewise.
+
+2012-05-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-machine.h (elf_machine_rela_relative): Handle
+	R_X86_64_RELATIVE64 if RTLD_BOOTSTRAP isn't defined.
+
+2012-05-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/llseek.S: Renamed to ...
+	* sysdeps/unix/sysv/linux/x86_64/x32/lseek.S: This.
+	* sysdeps/unix/sysv/linux/x86_64/x32/llseek.S: New dummy file.
+
+2012-05-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/fallocate.c: Removed.
+	* sysdeps/unix/sysv/linux/x86_64/x32/posix_fadvise.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/preadv.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/pwritev.c: Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/syscalls.list: New file.
+
+2012-05-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/x32/shlib-versions: Replace GLIBC_2.11 with
+	GLIBC_2.16.
+
+2012-05-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/ipctypes.h: Don't
+	include <bits/types.h>.
+	(__ipc_pid_t): Properly define.
+
+2012-05-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/Makefile (sysdep_routines):
+	Add arch_prctl.
+	* sysdeps/unix/sysv/linux/x86_64/x32/arch_prctl.c: New file.
+
+2012-03-20  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/bits/setjmp.h: Include <bits/wordsize.h>.
+	(__jmp_buf): Use long long int for x32.
+
+2012-03-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/i386/bits/byteswap.h: Include <features.h>.
+	(__bswap_32): Use __builtin_bswap32 if GCC >= 4.2.
+	(__bswap_64): Use __builtin_bswap64 if GCC >= 4.2.
+
+	* sysdeps/x86_64/bits/byteswap.h: Include <features.h>.
+	(__bswap_32): Use __builtin_bswap32 if GCC >= 4.2.
+	(__bswap_64): Use __builtin_bswap64 if GCC >= 4.2.
+
+2012-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/64/bits/wordsize.h (__GNUC_PREREQ): Removed.
+	(__WORDSIZE): Check __GNUC__ directly.
+	* sysdeps/x86_64/x32/bits/wordsize.h: Likewise.
+
+2012-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/sysdep.h (MOVE_LP): Removed.
+	(ADD_LP): Likewise.
+	(SUB_LP): Likewise.
+	(CMP_LP): Likewise.
+	(LP_OP): New.
+
+	* sysdeps/x86_64/x32/sysdep.h (MOVE_LP): Removed.
+	(ADD_LP): Likewise.
+	(SUB_LP): Likewise.
+	(CMP_LP): Likewise.
+	(LP_OP): New.
+
+2012-03-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sysdep.h (PTR_MANGLE): Use
+	$2*LP_SIZE+1 instead of $17.
+	(PTR_DEMANGLE): Likewise.
+
+2012-03-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* bits/types.h (__syscall_slong_t): New type.
+	(__syscall_ulong_t): Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/ipc.h: Replace
+	__USYSCALL_LONG_TYPE/__USYSCALL_LONG_TYPE with
+	__syscall_slong_t/__syscall_ulong_t.
+	* sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/msq.: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/sem.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/shm.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/stat.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/statfs.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/timex.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/sys/msg.h: Likewise.
+
+	* bits/typesizes.h (__SYSCALL_SLONG_TYPE): New macro.
+	(__SYSCALL_ULONG_TYPE): Likewise.
+	* sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h
+	(__SYSCALL_SLONG_TYPE): Likewise.
+	(__SYSCALL_ULONG_TYPE): Likewise.
+	* sysdeps/unix/sysv/linux/s390/bits/typesizes.h
+	(__SYSCALL_SLONG_TYPE): Likewise.
+	(__SYSCALL_ULONG_TYPE): Likewise.
+	* sysdeps/unix/sysv/linux/sparc/bits/typesizes.h
+	(__SYSCALL_SLONG_TYPE): Likewise.
+	(__SYSCALL_ULONG_TYPE): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h
+	(__SSYSCALL_LONG_TYPE): Renamed to ...
+	(__SYSCALL_SLONG_TYPE): This.
+	(__SSYSCALL_LONG_TYPE): Renamed to ...
+	(__SYSCALL_ULONG_TYPE): This.
+
+2012-03-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/i386/readelflib.c (process_elf_file):
+	Move e_machine check before EI_CLASS check.  Check EM_IA_64 only
+	if SKIP_EM_IA_64 isn't defined.
+	* sysdeps/unix/sysv/linux/x86_64/readelflib.c: Just define
+	SKIP_EM_IA_64 and include <sysdeps/unix/sysv/linux/i386/readelflib.c>.
+
+2012-03-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/makecontext.c (__makecontext):
+	Use greg_t instead of unsigned long long int and long long int.
+
+2012-03-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sysdep.h
+	(VSYSCALL_ADDR_vgettimeofday): Removed.
+	(VSYSCALL_ADDR_vtime): Likewise.
+	(VSYSCALL_ADDR_vgetcpu): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/gettimeofday.c
+	(VSYSCALL_ADDR_vgettimeofday): Restored.
+	* sysdeps/unix/sysv/linux/x86_64/init-first.c
+	(VSYSCALL_ADDR_vgetcpu): Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S
+	(VSYSCALL_ADDR_vgetcpu): Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/time.c (VSYSCALL_ADDR_vtime):
+	Likewise.
+
+2012-03-16  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h: Include
+	<bits/wordsize.h>.
+	(sigcontext): Check __WORDSIZE instead of __LP64__.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/user.h: Include
+	<bits/wordsize.h>.
+	(user): Check __WORDSIZE instead of __LP64__.
+
+2012-03-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* time/offtime.c (__offtime): Use time_t on days, rem, y and yg.
+
+2012-03-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* time/mktime.c: Sync with gnulib mktime.c at commit
+	a7967a2cf0998b6c157c7cf8e1d8d9d11dab30b0.
+
+2012-03-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/getcpu.c (getcpu_ifunc):
+	Replace getcpu with __vdso_getcpu.
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/gettimeofday.c
+	(gettimeofday_ifunc): Replace gettimeofday with
+	__vdso_gettimeofday.
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/init-first.c
+	(_libc_vdso_platform_setup): Replace clock_gettime with
+	__vdso_clock_gettime.
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/time.c (time_ifunc): Replace
+	time with __vdso_time.
+
+2012-03-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/msg.h (msgbuf): Replace
+	__SNATIVE_LONG_TYPE with __SSYSCALL_LONG_TYPE.
+
+2012-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/siginfo.h: New.
+
+2012-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h: Replace
+	__SNATIVE_LONG_TYPE and __UNATIVE_LONG_TYPE with
+	__SSYSCALL_LONG_TYPE and __USYSCALL_LONG_TYPE.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/ipc.h: Updated.
+	* sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/msq.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/sem.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/shm.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/stat.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/statfs.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/timex.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h: Likewise.
+
+2012-03-13  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* scripts/data/c++-types-x32-linux-gnu.data: Update clock_t.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h (__CLOCK_T_TYPE):
+	Set to __SQUAD_TYPE for x32.
+
+2012-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h (ucontext): Restore
+	unsigned long int on uc_flags.
+
+2012-02-25  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sysdep.h (PTR_MANGLE): Remove
+	the `q' suffix from xor/rol instructions.
+	(PTR_DEMANGLE): Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/sysdep.h (PTR_MANGLE): Removed.
+	(PTR_DEMANGLE): Likewise.
+
+2012-01-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* malloc/malloc.c (sYSMALLOc): Free the old top chunk with a
+	multiple of MALLOC_ALIGNMENT in size.
+	(_int_free): Check chunk size is a multiple of MALLOC_ALIGNMENT.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR libc/12495
+	* malloc/malloc.c (sYSMALLOc): Don't update correction with
+	front_misalign.
+
+2007-11-30  Daniel Jacobowitz  <dan@codesourcery.com>
+
+	PR libc/12495
+	* malloc/malloc.c (MALLOC_ALIGNMENT): Use __alignof__ (long double).
+	(SMALLBIN_CORRECTION): New.
+	(MIN_LARGE_SIZE, smallbin_index): Use it to handle 16-byte alignment.
+	(largebin_index_32_big): New.
+	(largebin_index): Use it for 16-byte alignment.
+	(sYSMALLOc): Handle MALLOC_ALIGNMENT > 2 * SIZE_SZ.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* stdio-common/_itoa.c (_itoa_base_table): Don't define if
+	PREFER_LONG_LONG is defined.
+	(_itoa): Use long long if PREFER_LONG_LONG is defined.
+	* stdio-common/_itowa.c (_itowa): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/x32/dl-machine.h: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/x32/Makefile: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/x32/divdi3.c: New.
+	* sysdeps/x86_64/x32/ffs.c: Likewise.
+	* sysdeps/x86_64/x32/gmp-mparam.h: Likewise.
+	* sysdeps/x86_64/x32/symbol-hacks.h: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/stackinfo.h (stackinfo_get_sp): Use RSP_LP.
+	(stackinfo_sub_sp): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf/tst-auditmod1.c: Support la_x32_gnu_pltenter and
+	la_x32_gnu_pltexit.
+	(pltexit): Cast int_retval to ptrdiff_t.
+	* elf/tst-auditmod3b.c: Likewise.
+	* elf/tst-auditmod4b.c: Likewise.
+	* elf/tst-auditmod5b.c: Likewise.
+	* elf/tst-auditmod6b.c: Likewise.
+	* elf/tst-auditmod6c.c: Likewise.
+	* elf/tst-auditmod7b.c: Likewise.
+
+	* sysdeps/generic/ldsodefs.h (audit_ifaces): Add x32_gnu_pltenter
+	and x32_gnu_pltexit.
+
+	* sysdeps/x86_64/bits/link.h: Check __x86_64__ instead of
+	__ELF_NATIVE_CLASS.
+	(la_x32_gnu_pltenter): New.
+	(la_x32_gnu_pltexit): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-machine.h: Replace Elf64_XXX with ElfW(XXX).
+	Replace ELF64_R_TYPE with ELF32_R_TYPE.
+	(elf_machine_load_address): Use ASM_ADDR.
+	(elf_machine_rela): Handle R_X86_64_RELATIVE64 for x32.  For x32,
+	sign extend relocation result to 64bit for R_X86_64_DTPOFF64
+	and R_X86_64_TPOFF64, and don't process R_X86_64_64.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-irel.h: Replace Elf64_XXX with ElfW(XXX).
+	Replace ELF64_R_TYPE with ELF32_R_TYPE.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-tls.h (dl_tls_index): Replace long with
+	long long.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-tlsdesc.h (tlsdesc): Pad for x32.
+	(dl_tls_index): Replace long with long long.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/dl-trampoline.S: Check if RTLD_SAVESPACE_SSE
+	is 32byte aligned.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/fpu/bits/mathinline.h: Don't include
+	<bits/wordsize.h>.
+	(__signbitf): Check __x86_64__ instead of __WORDSIZE.
+	(__signbit): Likwise.
+	(lrintf): Likwise.
+	(lrint): Likwise.
+	(llrintf): Likwise.
+	(llrint): Likwise.
+	(fmaxf): Likwise.
+	(fmax): Likwise.
+	(fminf): Likwise.
+	(fmin): Likwise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/fpu/math_private.h (EXTRACT_WORDS64): Use
+	long long int instead of long int.
+	(INSERT_WORDS64): Likwise.
+	(__isnan): Likwise.
+	(__isinf_ns): Likewise.
+	(__finite): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/jmpbuf-unwind.h (_JMPBUF_CFA_UNWINDS_ADJ): Cast
+	_Unwind_GetCFA return to _Unwind_Ptr first.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/bits/mathdef.h: Don't include <bits/wordsize.h>.
+	Check __x86_64__ instead of __WORDSIZE.
+	* sysdeps/x86_64/bits/setjmp.h: Likewise.
+	* sysdeps/x86_64/fpu/bits/fenv.h: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/bits/byteswap.h: Don't include
+	<bits/wordsize.h>.
+	(__bswap_32): Check __x86_64__ instead of __WORDSIZE.  Also
+	check __corei7__.
+	(__bswap_64): Check __x86_64__ instead of __WORDSIZE.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/bits/atomic.h (__arch_compare_and_exchange_val_64_acq):
+	Use long long on 64bit integer.
+	(__arch_c_compare_and_exchange_val_64_acq): Likewise.
+	(atomic_exchange_acq): Likewise.
+	(__arch_exchange_and_add_body): Likewise.
+	(__arch_add_body): Likewise.
+	(atomic_add_negative): Likewise.
+	(atomic_add_zero): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/multiarch/strcmp-sse42.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/multiarch/memcpy-ssse3.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/multiarch/memcpy-ssse3-back.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/multiarch/memcmp-sse4.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* x86_64/dl-trampoline.h: Use R10_LP to load frame size.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/strcmp.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/memcpy.S: Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/elf/start.S: Include <sysdep.h>.  Simulate
+	popping 4byte argument count for x32.  Use RXX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/__longjmp.S: Use RXX_LP.
+	* sysdeps/x86_64/setjmp.S: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/sysctl.c: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/sendfile64.c: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/pselect.c: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/syscalls.list: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/init-first.c: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/getdents.c: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/llseek.S: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/gettimeofday.c: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/time.c: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/preadv.c: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/pwritev.c: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/Makefile: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/getcpu.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu-static.c:
+	Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu.S: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/fallocate.c: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/posix_fadvise.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/posix_fallocate.c: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/alphasort.c: New.
+	* sysdeps/unix/sysv/linux/x86_64/x32/alphasort64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/fseeko.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/fseeko64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/ftello.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/ftello64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/ftw.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/ftw64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/glob.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofopen.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofopen64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/lockf.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/lockf64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/mkostemp.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/mkostemp64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/mkstemp.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/mkstemp64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/scandir.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/scandir64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/scandirat.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/scandirat64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/tmpfile.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/tmpfile64.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/versionsort.c: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/x32/versionsort64.c: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/dl-cache.h: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sigaction.c (RESTORE2): Replace
+	8byte data alignment with LP_SIZE alignment.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/clone.S: Load pointer to TID
+	into R10_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/Makefile (gen-as-const-headers):
+	Add sigaltstack.sym.
+
+	* sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S: Include
+	"sigaltstack.h".
+	(____longjmp_chk): Use RXX_LP, sizeSS, oSS_FLAGS, oSS_SP and
+	oSS_SIZE for alternate signal stack.
+
+	* sysdeps/unix/sysv/linux/x86_64/sigaltstack.sym: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/makecontext.c (__makecontext):
+	Use "unsigned long long int" instead of "unsigned long int".
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h: Include
+	<stdint.h>.
+	(GET_PC): Cast to uintptr_t first.
+	(GET_FRAME): Likewise.
+	(GET_STACK): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h: Don't include
+	<bits/wordsize.h>.  Check __x86_64__ instead of __WORDSIZE.
+	(DR_CONTROL_RESERVED): Use ULL instead of UL suffix.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/procfs.h (elf_greg_t): Use
+	"unsigned long long int" if __x86_64__ is defined.
+	Check __x86_64__ instead of __WORDSIZE.
+	(elf_prstatus): Use "unsigned long long int" instead of
+	"unsigned long int" if __x86_64__ is defined.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/reg.h: Don't
+	include <bits/wordsize.h>.  Check __x86_64__ instead of
+	__WORDSIZE.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h: Don't
+	include <bits/wordsize.h>.  Check __x86_64__ instead of
+	__WORDSIZE.
+	(greg_t): Use "long long int" if __x86_64__ is defined.
+	(mcontext_t): Replace "unsigned long" with "unsigned long long".
+	(ucontext_t): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/user.h: Don't
+	include <bits/wordsize.h>.  Check __x86_64__ instead of
+	__WORDSIZE.
+	(user_regs_struct): Use "unsigned long long" instead of
+	"unsigned long" if __x86_64__ is defined.
+	(user): Likewise.  Pad if __LP64__ isn't defined.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sys/msg.h: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed: Support x32.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/bits/wordsize.h: Moved to ...
+	* sysdeps/x86_64/64/bits/wordsize.h: Here.
+	(__WORDSIZE_COMPAT32): Removed.
+
+	* sysdeps/x86_64/x32/bits/wordsize.h: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/Implies: Moved to ...
+	* sysdeps/unix/sysv/linux/x86_64/64/Implies: Here.
+
+	* sysdeps/x86_64/Implies: Moved to ...
+	* sysdeps/x86_64/64/Implies: Here.  Prepend x86_64/fpu.
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/Implies: New.
+	* sysdeps/x86_64/x32/Implies: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/a.out.h: Don't include
+	<bits/wordsize.h>.  Check __x86_64__ instead of __WORDSIZE.
+	* sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h: Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/msq.h: Don't include
+	<bits/wordsize.h>.
+	(msgqnum_t): Use __UNATIVE_LONG_TYPE.
+	(msglen_t): Likewise.
+	(msqid_ds): Check __x86_64__ instead of __WORDSIZE.  Use
+	__UNATIVE_LONG_TYPE.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/sem.h (semid_ds): Use
+	__UNATIVE_LONG_TYPE.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/shm.h (shmatt_t): Use
+	__UNATIVE_LONG_TYPE.
+	(shmid_ds): Add __unused1 and __unused2 only if __x86_64__ isn't
+	defined.  Use __UNATIVE_LONG_TYPE.
+	(shminfo): Use __UNATIVE_LONG_TYPE.
+	(shm_info): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h: Don't
+	include <bits/wordsize.h>.  Check __x86_64__ instead of
+	__WORDSIZE.
+	(sigcontext): Use "unsigned long long int" instead of
+	"unsigned long int" if __x86_64__ is defined.  Pad if __LP64__
+	isn't defined.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/stat.h (_STAT_VER_SVR4):
+	Check __x86_64__ instead of __WORDSIZE.
+	(_STAT_VER_LINUX): Likewise.
+	(stat): Check __x86_64__ instead of __WORDSIZE.  Use
+	__UNATIVE_LONG_TYPE.
+	(stat64): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/ipc.h: New.
+	* sysdeps/unix/sysv/linux/x86_64/bits/ipctypes.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/resource.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/statfs.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/statvfs.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/timex.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/utmp.h: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h: Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf/tls-macros.h (TLS_LE): Use mov instead of movq to load
+	thread pointer.
+	(TLS_IE): Use mov/add instead of movq/addq to load thread
+	pointer.
+	(TLS_GD_PREFIX): New.
+	(TLS_GD): Use it.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf/stackguard-macros.h (STACK_CHK_GUARD): Add x32 version.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf/cache.c (print_entry): Handle FLAG_X8664_LIBX32.
+
+	* sysdeps/generic/ldconfig.h (FLAG_X8664_LIBX32): New.
+
+	* sysdeps/unix/sysv/linux/i386/readelflib.c (process_elf_file):
+	Handle x32 libraries.
+	* sysdeps/unix/sysv/linux/x86_64/readelflib.c (process_elf_file):
+	Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/dl-cache.h (add_system_dir): New
+	Don't include <sysdeps/unix/sysv/linux/sparc/dl-cache.h>.
+
+	* sysdeps/unix/sysv/linux/x86_64/ldconfig.h
+	(SYSDEP_KNOWN_INTERPRETER_NAMES): Add /libx32/ld-linux-x32.so.2.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* stdlib/longlong.h (count_leading_zeros): Use long long builtin
+	for x86-64.
+	(count_trailing_zeros): Likewise.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* elf/elf.h (R_X86_64_RELATIVE64): New.
+	(R_X86_64_NUM): Updated.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/ffsll.c: Add ffsl alias only if __LP64__ is
+	defined.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c: Moved to ...
+	* sysdeps/ieee754/dbl-64/wordsize-64/s_llround.c: This.  Updated.
+
+	* sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c: Empty file.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* time/mktime.c (ydhms_diff): Check TIME_T_MAX instead of
+	LONG_MAX.
+
+	* time/offtime.c (__offtime): Add more overflow check.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* bits/types.h (__snseconds_t): New.
+	* bits/typesizes.h (__SNSECONDS_T_TYPE): Likewise.
+	* sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h (__SNSECONDS_T_TYPE):
+	Likewise.
+	* sysdeps/unix/sysv/linux/s390/bits/typesizes.h (__SNSECONDS_T_TYPE):
+	Likewise.
+	* sysdeps/unix/sysv/linux/sparc/bits/typesizes.h (__SNSECONDS_T_TYPE):
+	Likewise.
+
+	* time/time.h (timespec): Use __snseconds_t on tv_nsec.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/sysdep.h
+	(VSYSCALL_ADDR_vgettimeofday): New.
+	(VSYSCALL_ADDR_vtime): Likewise.
+	(VSYSCALL_ADDR_vgetcpu): Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/gettimeofday.c
+	(VSYSCALL_ADDR_vgettimeofday): Removed.
+	* sysdeps/unix/sysv/linux/x86_64/init-first.c
+	(VSYSCALL_ADDR_vgetcpu): Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/sched_getcpu.S
+	(VSYSCALL_ADDR_vgetcpu): Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/time.c (VSYSCALL_ADDR_vtime):
+	Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/x32/sysdep.h: New.
+	* sysdeps/x86_64/x32/sysdep.h: Likewise.
+
+	* sysdeps/x86_64/sysdep.h (LP_SIZE): New.
+	(MOVE_LP): Likewise.
+	(ADD_LP): Likewise.
+	(SUB_LP): Likewise.
+	(CMP_LP): Likewise.
+	(ASM_ADDR): Likewise.
+	(RAX_LP): New.
+	(RBP_LP): Likewise.
+	(RBX_LP): Likewise.
+	(RCX_LP): Likewise.
+	(RDI_LP): Likewise.
+	(RSI_LP): Likewise.
+	(RSP_LP): Likewise.
+	(R8_LP): Likewise.
+	(R9_LP): Likewise.
+	(R10_LP): Likewise.
+	(R10_LP): Likewise.
+	(R11_LP): Likewise.
+	(R12_LP): Likewise.
+	(R13_LP): Likewise.
+	(R14_LP): Likewise.
+	(R15_LP): Likewise.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* shlib-versions: Move ld name for x86_64-.*-linux.* to ...
+	* sysdeps/x86_64/64/shlib-versions: Here.  New.
+
+	* sysdeps/x86_64/x32/shlib-versions: New.
+
+2011-11-18  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* Makeconfig ($(common-objpfx)gnu/lib-names.stmp): Depend on
+	$(lib-names_awk) instead of scripts/lib-names.awk.
+
+	* Makefile ($(inst_includedir)/gnu/stubs.h): Depend on
+	$(stubs-biarch_h) instead of include/stubs-biarch.h.
+	(data-machine): New.
+	(check-data): Use it.
+
+	* config.make.in (data-machine): New.
+	(stubs-biarch_h): Likewise.
+	(lib-names_awk): Likewise.
+
+	* configure.in: Add sysdeps preconfigure fragment support.
+	(data_machine): Substitute.
+	(stubs_biarch_h): Set to include/stubs-biarch.h if not set.
+	Substitute.
+	(lib_names_awk): Set to scripts/lib-names.awk if not set.
+	Substitute.
+	* configure: Regenerated.
+
+	* scripts/data/c++-types-x32-linux-gnu.data: New.
+	* sysdeps/unix/sysv/linux/x86_64/stubs-triarch.h: Likewise.
+	* sysdeps/x86_64/lib-names.awk: Likewise.
+	* sysdeps/x86_64/preconfigure: Likewise.
+	* sysdeps/x86_64/stubs-biarch.h: Likewise.
+
+	* sysdeps/unix/sysv/linux/configure.in: Require kernel 2.6.35
+	or above for x32.  Check x86_64/x64 instead of x86_64.
+	* sysdeps/unix/sysv/linux/configure: Regenerated.
+
+	* sysdeps/x86_64/preconfigure (stubs_biarch_h): Set to
+	sysdeps/x86_64/stubs-biarch.h.
+
+	* sysdeps/unix/sysv/linux/x86_64/Makefile
+	(syscall-list-32bit-condition): Check __x86_64__ instead of
+	__WORDSIZE.
+	(syscall-list-64bit-condition): Likewise.
+	(syscall-list-64bit-options): Add __LP64__.
diff --git a/Makeconfig b/Makeconfig
index 8195245..609a514 100644
--- a/Makeconfig
+++ b/Makeconfig
@@ -897,7 +897,7 @@ postclean-generated += soversions.mk soversions.i \
 before-compile += $(common-objpfx)gnu/lib-names.h
 ifeq ($(soversions.mk-done),t)
 $(common-objpfx)gnu/lib-names.h: $(common-objpfx)gnu/lib-names.stmp; @:
-$(common-objpfx)gnu/lib-names.stmp: $(..)scripts/lib-names.awk \
+$(common-objpfx)gnu/lib-names.stmp: $(..)$(lib-names_awk) \
 				    $(common-objpfx)soversions.i
 	$(make-target-directory)
 	@rm -f ${@:stmp=T} $@
diff --git a/Makefile b/Makefile
index 08134e9..cd4c1c7 100644
--- a/Makefile
+++ b/Makefile
@@ -177,7 +177,7 @@ installed-stubs = $(inst_includedir)/gnu/stubs.h
 else
 installed-stubs = $(inst_includedir)/gnu/stubs-$(biarch).h
 
-$(inst_includedir)/gnu/stubs.h: include/stubs-biarch.h $(+force)
+$(inst_includedir)/gnu/stubs.h: $(stubs-biarch_h) $(+force)
 	$(make-target-directory)
 	$(INSTALL_DATA) $< $@
 
@@ -259,13 +259,15 @@ tests-clean:
 
 tests: $(objpfx)c++-types-check.out $(objpfx)check-local-headers.out
 ifneq ($(CXX),no)
+ifeq ($(data-machine),)
+data-machine = $(config-machine) $(base-machine)
+endif
 check-data := $(firstword $(wildcard \
 		$(foreach D,$(add-ons) scripts,\
 			  $(patsubst %,$D/data/c++-types-%.data,\
 				     $(abi-name) \
 				     $(addsuffix -$(config-os),\
-						 $(config-machine) \
-						 $(base-machine))))))
+						 $(data-machine))))))
 ifneq (,$(check-data))
 $(objpfx)c++-types-check.out: $(check-data) scripts/check-c++-types.sh
 	scripts/check-c++-types.sh $< $(CXX) $(filter-out -std=gnu99 -Wstrict-prototypes,$(CFLAGS)) $(CPPFLAGS) > $@
diff --git a/bits/types.h b/bits/types.h
index 3ebe82f..542a61e 100644
--- a/bits/types.h
+++ b/bits/types.h
@@ -149,6 +149,7 @@ __STD_TYPE __ID_T_TYPE __id_t;		/* General type for IDs.  */
 __STD_TYPE __TIME_T_TYPE __time_t;	/* Seconds since the Epoch.  */
 __STD_TYPE __USECONDS_T_TYPE __useconds_t; /* Count of microseconds.  */
 __STD_TYPE __SUSECONDS_T_TYPE __suseconds_t; /* Signed count of microseconds.  */
+__STD_TYPE __SNSECONDS_T_TYPE __snseconds_t; /* Signed count of nanoseconds.  */
 
 __STD_TYPE __DADDR_T_TYPE __daddr_t;	/* The type of a disk address.  */
 __STD_TYPE __SWBLK_T_TYPE __swblk_t;	/* Type of a swap block maybe?  */
@@ -179,6 +180,11 @@ __STD_TYPE __FSFILCNT64_T_TYPE __fsfilcnt64_t;
 
 __STD_TYPE __SSIZE_T_TYPE __ssize_t; /* Type of a byte count, or error.  */
 
+/* Signed long type used in system calls.  */
+__STD_TYPE __SYSCALL_SLONG_TYPE __syscall_slong_t;
+/* Unsigned long type used in system calls.  */
+__STD_TYPE __SYSCALL_ULONG_TYPE __syscall_ulong_t;
+
 /* These few don't really vary by system, they always correspond
    to one of the other defined types.  */
 typedef __off64_t __loff_t;	/* Type of file sizes and offsets (LFS).  */
diff --git a/bits/typesizes.h b/bits/typesizes.h
index e9226c4..17ff797 100644
--- a/bits/typesizes.h
+++ b/bits/typesizes.h
@@ -1,5 +1,6 @@
 /* bits/typesizes.h -- underlying types for *_t.  Generic version.
-   Copyright (C) 2002, 2003 Free Software Foundation, Inc.
+   Copyright (C) 2002, 2003, 2011
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -58,6 +59,9 @@
 #define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
 #define __FSID_T_TYPE		struct { int __val[2]; }
 #define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
 
 /* Number of descriptors that can fit in an `fd_set'.  */
 #define	__FD_SETSIZE		1024
diff --git a/config.make.in b/config.make.in
index d2baf6d..cd0d1c8 100644
--- a/config.make.in
+++ b/config.make.in
@@ -28,6 +28,7 @@ ldd-rewrite-script = @ldd_rewrite_script@
 # System configuration.
 config-machine = @host_cpu@
 base-machine = @base_machine@
+data-machine = @data_machine@
 config-vendor = @host_vendor@
 config-os = @host_os@
 config-sysdirs = @sysnames@
@@ -79,6 +80,9 @@ oldest-abi = @oldest_abi@
 exceptions = @exceptions@
 multi-arch = @multi_arch@
 
+stubs-biarch_h = @stubs_biarch_h@
+lib-names_awk = @lib_names_awk@
+
 mach-interface-list = @mach_interface_list@
 
 have-bash2 = @libc_cv_have_bash2@
diff --git a/configure b/configure
index c22ed38..de5a157 100755
--- a/configure
+++ b/configure
@@ -607,6 +607,8 @@ ac_subst_vars='LTLIBOBJS
 LIBOBJS
 RELEASE
 VERSION
+lib_names_awk
+stubs_biarch_h
 mach_interface_list
 DEFINES
 nopic_initfini
@@ -690,6 +692,7 @@ sysdeps_add_ons
 sysnames
 submachine
 multi_arch
+data_machine
 base_machine
 add_on_subdirs
 add_ons
@@ -4087,6 +4090,17 @@ if test "$base_machine" = "i386"; then
 
 fi
 
+# Now run sysdeps preconfigure fragment.
+preconfigure=$srcdir/sysdeps/$base_machine/preconfigure
+if test -r $preconfigure; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: running preconfigure fragment for $base_machine" >&5
+$as_echo "running preconfigure fragment for $base_machine" >&6; }
+  . $preconfigure
+fi
+
+# sysdeps preconfigure fragment may set data_machine.
+
+
 # For the multi-arch option we need support in the assembler.
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for assembler gnu_indirect_function symbol type support" >&5
 $as_echo_n "checking for assembler gnu_indirect_function symbol type support... " >&6; }
@@ -7990,6 +8004,16 @@ $as_echo "$libc_cv_pic_default" >&6; }
 
 
 
+if test -z "${stubs_biarch_h}"; then
+  stubs_biarch_h=include/stubs-biarch.h
+fi
+
+
+if test -z "${lib_names_awk}"; then
+  lib_names_awk=scripts/lib-names.awk
+fi
+
+
 if test "`(cd $srcdir; pwd)`" = "`pwd`"; then
   config_makefile=
 else
diff --git a/configure.in b/configure.in
index 2c4fc97..a9f4045 100644
--- a/configure.in
+++ b/configure.in
@@ -574,6 +574,16 @@ if test "$base_machine" = "i386"; then
   AC_DEFINE(USE_REGPARMS)
 fi
 
+# Now run sysdeps preconfigure fragment.
+preconfigure=$srcdir/sysdeps/$base_machine/preconfigure
+if test -r $preconfigure; then
+  AC_MSG_RESULT(running preconfigure fragment for $base_machine)
+  . $preconfigure
+fi
+
+# sysdeps preconfigure fragment may set data_machine.
+AC_SUBST(data_machine)
+
 # For the multi-arch option we need support in the assembler.
 AC_CACHE_CHECK([for assembler gnu_indirect_function symbol type support],
 	       libc_cv_asm_gnu_indirect_function, [dnl
@@ -2382,6 +2392,16 @@ AC_SUBST(DEFINES)
 dnl See sysdeps/mach/configure.in for this variable.
 AC_SUBST(mach_interface_list)
 
+if test -z "${stubs_biarch_h}"; then
+  stubs_biarch_h=include/stubs-biarch.h
+fi
+AC_SUBST(stubs_biarch_h)
+
+if test -z "${lib_names_awk}"; then
+  lib_names_awk=scripts/lib-names.awk
+fi
+AC_SUBST(lib_names_awk)
+
 if test "`(cd $srcdir; pwd)`" = "`pwd`"; then
   config_makefile=
 else
diff --git a/elf/cache.c b/elf/cache.c
index 393b4e5..3d02c2d 100644
--- a/elf/cache.c
+++ b/elf/cache.c
@@ -91,6 +91,10 @@ print_entry (const char *lib, int flag, unsigned int osversion,
       break;
     case FLAG_MIPS64_LIBN64:
       fputs (",64bit", stdout);
+      break;
+    case FLAG_X8664_LIBX32:
+      fputs (",x32", stdout);
+      break;
     case 0:
       break;
     default:
diff --git a/elf/elf.h b/elf/elf.h
index 7c64120..dc899d0 100644
--- a/elf/elf.h
+++ b/elf/elf.h
@@ -2702,8 +2702,9 @@ typedef Elf32_Addr Elf32_Conflict;
 					   descriptor.  */
 #define R_X86_64_TLSDESC        36	/* TLS descriptor.  */
 #define R_X86_64_IRELATIVE	37	/* Adjust indirectly by program base */
+#define R_X86_64_RELATIVE64	38	/* 64bit adjust by program base */
 
-#define R_X86_64_NUM		38
+#define R_X86_64_NUM		39
 
 
 /* AM33 relocations.  */
diff --git a/elf/stackguard-macros.h b/elf/stackguard-macros.h
index 97db8bc..8b85425 100644
--- a/elf/stackguard-macros.h
+++ b/elf/stackguard-macros.h
@@ -4,8 +4,13 @@
 # define STACK_CHK_GUARD \
   ({ uintptr_t x; asm ("movl %%gs:0x14, %0" : "=r" (x)); x; })
 #elif defined __x86_64__
-# define STACK_CHK_GUARD \
+# ifdef __LP64__
+#  define STACK_CHK_GUARD \
   ({ uintptr_t x; asm ("movq %%fs:0x28, %0" : "=r" (x)); x; })
+# else
+#  define STACK_CHK_GUARD \
+  ({ uintptr_t x; asm ("movl %%fs:0x18, %0" : "=r" (x)); x; })
+# endif
 #elif defined __powerpc64__
 # define STACK_CHK_GUARD \
   ({ uintptr_t x; asm ("ld %0,-28688(13)" : "=r" (x)); x; })
diff --git a/elf/tls-macros.h b/elf/tls-macros.h
index 781256d..947e2bb 100644
--- a/elf/tls-macros.h
+++ b/elf/tls-macros.h
@@ -101,15 +101,15 @@
 
 # define TLS_LE(x) \
   ({ int *__l;								      \
-     asm ("movq %%fs:0,%0\n\t"						      \
-	  "leaq " #x "@tpoff(%0), %0"					      \
+     asm ("mov %%fs:0,%0\n\t"						      \
+	  "lea " #x "@tpoff(%0), %0"					      \
 	  : "=r" (__l));						      \
      __l; })
 
 # define TLS_IE(x) \
   ({ int *__l;								      \
-     asm ("movq %%fs:0,%0\n\t"						      \
-	  "addq " #x "@gottpoff(%%rip),%0"				      \
+     asm ("mov %%fs:0,%0\n\t"						      \
+	  "add " #x "@gottpoff(%%rip),%0"				      \
 	  : "=r" (__l));						      \
      __l; })
 
@@ -122,9 +122,15 @@
 	  : : "rdi", "rsi", "r8", "r9", "r10", "r11"); 			      \
      __l; })
 
+# ifdef __LP64__
+#  define TLS_GD_PREFIX	".byte 0x66\n\t"
+# else
+#  define TLS_GD_PREFIX
+# endif
+
 # define TLS_GD(x) \
   ({ int *__l, __c, __d;						      \
-     asm (".byte 0x66\n\t"						      \
+     asm (TLS_GD_PREFIX							      \
 	  "leaq " #x "@tlsgd(%%rip),%%rdi\n\t"				      \
 	  ".word 0x6666\n\t"						      \
 	  "rex64\n\t"							      \
diff --git a/elf/tst-auditmod1.c b/elf/tst-auditmod1.c
index 2d39df2..15a8e34 100644
--- a/elf/tst-auditmod1.c
+++ b/elf/tst-auditmod1.c
@@ -109,8 +109,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
 # define La_retval La_i86_retval
 # define int_retval lrv_eax
 #elif defined __x86_64__
-# define pltenter la_x86_64_gnu_pltenter
-# define pltexit la_x86_64_gnu_pltexit
+# ifdef __LP64__
+#  define pltenter la_x86_64_gnu_pltenter
+#  define pltexit la_x86_64_gnu_pltexit
+# else
+#  define pltenter la_x32_gnu_pltenter
+#  define pltexit la_x32_gnu_pltexit
+# endif
 # define La_regs La_x86_64_regs
 # define La_retval La_x86_64_retval
 # define int_retval lrv_rax
@@ -194,7 +199,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
   return 0;
 }
diff --git a/elf/tst-auditmod3b.c b/elf/tst-auditmod3b.c
index 388ed6e..d1bb9b0 100644
--- a/elf/tst-auditmod3b.c
+++ b/elf/tst-auditmod3b.c
@@ -105,8 +105,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -140,7 +145,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
   __m128i xmm = _mm_set1_epi32 (-1);
   asm volatile ("movdqa %0, %%xmm0" : : "x" (xmm) : "xmm0" );
diff --git a/elf/tst-auditmod4b.c b/elf/tst-auditmod4b.c
index 761d97c..222f3b7 100644
--- a/elf/tst-auditmod4b.c
+++ b/elf/tst-auditmod4b.c
@@ -94,8 +94,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -177,7 +182,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
 #ifdef __AVX__
   if (check_avx () && strcmp (symname, "audit_test") == 0)
diff --git a/elf/tst-auditmod5b.c b/elf/tst-auditmod5b.c
index 7e1e941..78fe838 100644
--- a/elf/tst-auditmod5b.c
+++ b/elf/tst-auditmod5b.c
@@ -95,8 +95,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -150,7 +155,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
   __m128i xmm;
 
diff --git a/elf/tst-auditmod6b.c b/elf/tst-auditmod6b.c
index a7a60b9..016b07b 100644
--- a/elf/tst-auditmod6b.c
+++ b/elf/tst-auditmod6b.c
@@ -94,8 +94,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -179,7 +184,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
 #ifdef __AVX__
   if (check_avx () && strcmp (symname, "audit_test") == 0)
diff --git a/elf/tst-auditmod6c.c b/elf/tst-auditmod6c.c
index e0b5ac2..015be08 100644
--- a/elf/tst-auditmod6c.c
+++ b/elf/tst-auditmod6c.c
@@ -94,8 +94,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -185,7 +190,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
 #ifdef __AVX__
   if (check_avx () && strcmp (symname, "audit_test") == 0)
diff --git a/elf/tst-auditmod7b.c b/elf/tst-auditmod7b.c
index a27d385..48b6626 100644
--- a/elf/tst-auditmod7b.c
+++ b/elf/tst-auditmod7b.c
@@ -94,8 +94,13 @@ la_symbind64 (Elf64_Sym *sym, unsigned int ndx, uintptr_t *refcook,
   return sym->st_value;
 }
 
-#define pltenter la_x86_64_gnu_pltenter
-#define pltexit la_x86_64_gnu_pltexit
+#ifdef __LP64__
+# define pltenter la_x86_64_gnu_pltenter
+# define pltexit la_x86_64_gnu_pltexit
+#else
+# define pltenter la_x32_gnu_pltenter
+# define pltexit la_x32_gnu_pltexit
+#endif
 #define La_regs La_x86_64_regs
 #define La_retval La_x86_64_retval
 #define int_retval lrv_rax
@@ -177,7 +182,8 @@ pltexit (ElfW(Sym) *sym, unsigned int ndx, uintptr_t *refcook,
 	 const char *symname)
 {
   printf ("pltexit: symname=%s, st_value=%#lx, ndx=%u, retval=%tu\n",
-	  symname, (long int) sym->st_value, ndx, outregs->int_retval);
+	  symname, (long int) sym->st_value, ndx,
+	  (ptrdiff_t) outregs->int_retval);
 
 #ifdef __AVX__
   if (check_avx () && strcmp (symname, "audit_test") == 0)
diff --git a/malloc/malloc.c b/malloc/malloc.c
index 8608083..a9a2cff 100644
--- a/malloc/malloc.c
+++ b/malloc/malloc.c
@@ -1589,18 +1589,23 @@ typedef struct malloc_chunk* mbinptr;
 
     The bins top out around 1MB because we expect to service large
     requests via mmap.
+
+    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be
+    a valid chunk size the small bins are bumped up one.
 */
 
 #define NBINS             128
 #define NSMALLBINS         64
 #define SMALLBIN_WIDTH    MALLOC_ALIGNMENT
-#define MIN_LARGE_SIZE    (NSMALLBINS * SMALLBIN_WIDTH)
+#define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT > 2 * SIZE_SZ)
+#define MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)
 
 #define in_smallbin_range(sz)  \
   ((unsigned long)(sz) < (unsigned long)MIN_LARGE_SIZE)
 
 #define smallbin_index(sz) \
-  (SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) >> 4) : (((unsigned)(sz)) >> 3))
+  ((SMALLBIN_WIDTH == 16 ? (((unsigned)(sz)) >> 4) : (((unsigned)(sz)) >> 3)) \
+   + SMALLBIN_CORRECTION)
 
 #define largebin_index_32(sz)                                                \
 (((((unsigned long)(sz)) >>  6) <= 38)?  56 + (((unsigned long)(sz)) >>  6): \
@@ -1610,6 +1615,14 @@ typedef struct malloc_chunk* mbinptr;
  ((((unsigned long)(sz)) >> 18) <=  2)? 124 + (((unsigned long)(sz)) >> 18): \
 					126)
 
+#define largebin_index_32_big(sz)                                            \
+(((((unsigned long)(sz)) >>  6) <= 45)?  49 + (((unsigned long)(sz)) >>  6): \
+ ((((unsigned long)(sz)) >>  9) <= 20)?  91 + (((unsigned long)(sz)) >>  9): \
+ ((((unsigned long)(sz)) >> 12) <= 10)? 110 + (((unsigned long)(sz)) >> 12): \
+ ((((unsigned long)(sz)) >> 15) <=  4)? 119 + (((unsigned long)(sz)) >> 15): \
+ ((((unsigned long)(sz)) >> 18) <=  2)? 124 + (((unsigned long)(sz)) >> 18): \
+                                        126)
+
 // XXX It remains to be seen whether it is good to keep the widths of
 // XXX the buckets the same or whether it should be scaled by a factor
 // XXX of two as well.
@@ -1622,7 +1635,9 @@ typedef struct malloc_chunk* mbinptr;
 					126)
 
 #define largebin_index(sz) \
-  (SIZE_SZ == 8 ? largebin_index_64 (sz) : largebin_index_32 (sz))
+  (SIZE_SZ == 8 ? largebin_index_64 (sz)                                     \
+   : MALLOC_ALIGNMENT == 16 ? largebin_index_32_big (sz)                     \
+   : largebin_index_32 (sz))
 
 #define bin_index(sz) \
  ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))
@@ -2390,8 +2405,12 @@ static void* sYSMALLOc(INTERNAL_SIZE_T nb, mstate av)
       is no following chunk whose prev_size field could be used.
 
       See the front_misalign handling below, for glibc there is no
-      need for further alignments.  */
-    size = (nb + SIZE_SZ + pagemask) & ~pagemask;
+      need for further alignments unless we have have high alignment.
+    */
+    if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
+      size = (nb + SIZE_SZ + pagemask) & ~pagemask;
+    else
+      size = (nb + SIZE_SZ + MALLOC_ALIGN_MASK + pagemask) & ~pagemask;
     tried_mmap = true;
 
     /* Don't try if size wraps around 0 */
@@ -2407,14 +2426,29 @@ static void* sYSMALLOc(INTERNAL_SIZE_T nb, mstate av)
 	  returned start address to meet alignment requirements here
 	  and in memalign(), and still be able to compute proper
 	  address argument for later munmap in free() and realloc().
+	*/
 
-	  For glibc, chunk2mem increases the address by 2*SIZE_SZ and
-	  MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap'ed area is page
-	  aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */
-	assert (((INTERNAL_SIZE_T)chunk2mem(mm) & MALLOC_ALIGN_MASK) == 0);
-
-	p = (mchunkptr)mm;
-	set_head(p, size|IS_MMAPPED);
+	if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
+	  {
+	    /* For glibc, chunk2mem increases the address by 2*SIZE_SZ and
+	       MALLOC_ALIGN_MASK is 2*SIZE_SZ-1.  Each mmap'ed area is page
+	       aligned and therefore definitely MALLOC_ALIGN_MASK-aligned.  */
+	    assert (((INTERNAL_SIZE_T)chunk2mem(mm) & MALLOC_ALIGN_MASK) == 0);
+	    front_misalign = 0;
+	  }
+	else
+	  front_misalign = (INTERNAL_SIZE_T)chunk2mem(mm) & MALLOC_ALIGN_MASK;
+	if (front_misalign > 0) {
+	  correction = MALLOC_ALIGNMENT - front_misalign;
+	  p = (mchunkptr)(mm + correction);
+	  p->prev_size = correction;
+	  set_head(p, (size - correction) |IS_MMAPPED);
+	}
+	else
+	  {
+	    p = (mchunkptr)mm;
+	    set_head(p, size|IS_MMAPPED);
+	  }
 
 	/* update statistics */
 
@@ -2479,11 +2513,12 @@ static void* sYSMALLOc(INTERNAL_SIZE_T nb, mstate av)
       top(av) = chunk_at_offset(heap, sizeof(*heap));
       set_head(top(av), (heap->size - sizeof(*heap)) | PREV_INUSE);
 
-      /* Setup fencepost and free the old top chunk. */
+      /* Setup fencepost and free the old top chunk with a multiple of
+	 MALLOC_ALIGNMENT in size. */
       /* The fencepost takes at least MINSIZE bytes, because it might
 	 become the top chunk again later.  Note that a footer is set
 	 up, too, although the chunk is marked in use. */
-      old_size -= MINSIZE;
+      old_size = (old_size - MINSIZE) & ~MALLOC_ALIGN_MASK;
       set_head(chunk_at_offset(old_top, old_size + 2*SIZE_SZ), 0|PREV_INUSE);
       if (old_size >= MINSIZE) {
 	set_head(chunk_at_offset(old_top, old_size), (2*SIZE_SZ)|PREV_INUSE);
@@ -2682,8 +2717,24 @@ static void* sYSMALLOc(INTERNAL_SIZE_T nb, mstate av)
 
       /* handle non-contiguous cases */
       else {
-	/* MORECORE/mmap must correctly align */
-	assert(((unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK) == 0);
+	if (MALLOC_ALIGNMENT == 2 * SIZE_SZ)
+	  /* MORECORE/mmap must correctly align */
+	  assert(((unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK) == 0);
+	else {
+	  front_misalign = (INTERNAL_SIZE_T)chunk2mem(brk) & MALLOC_ALIGN_MASK;
+	  if (front_misalign > 0) {
+
+	    /*
+	      Skip over some bytes to arrive at an aligned position.
+	      We don't need to specially mark these wasted front bytes.
+	      They will never be accessed anyway because
+	      prev_inuse of av->top (and any chunk created from its start)
+	      is always true after initialization.
+	    */
+
+	    aligned_brk += MALLOC_ALIGNMENT - front_misalign;
+	  }
+	}
 
 	/* Find out current end of memory */
 	if (snd_brk == (char*)(MORECORE_FAILURE)) {
@@ -3932,8 +3983,10 @@ _int_free(mstate av, mchunkptr p, int have_lock)
       malloc_printerr (check_action, errstr, chunk2mem(p));
       return;
     }
-  /* We know that each chunk is at least MINSIZE bytes in size.  */
-  if (__builtin_expect (size < MINSIZE, 0))
+  /* We know that each chunk is at least MINSIZE bytes in size of a
+     multiple of MALLOC_ALIGNMENT.  */
+  if (__builtin_expect (size < MINSIZE
+			|| (size & MALLOC_ALIGN_MASK) != 0, 0))
     {
       errstr = "free(): invalid size";
       goto errout;
diff --git a/nptl/ChangeLog.x32 b/nptl/ChangeLog.x32
new file mode 100644
index 0000000..d3f48cf
--- /dev/null
+++ b/nptl/ChangeLog.x32
@@ -0,0 +1,95 @@
+2012-05-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/x32/shlib-versions: Replace GLIBC_2.11 with
+	GLIBC_2.16.
+
+2012-03-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/cancellation.S: Replace ADD_LP,
+	CMP_LP, MOVE_LP, SUB_LP with LP_OP(add), LP_OP(cmp), LP_OP(mov),
+	LP_OP(sub).
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/sem_post.S: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S: Likewise.
+	* sysdeps/unix/sysv/linux/x86_64/sem_wait.S: Likewise.
+
+2012-03-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S: Use CMP_LP
+	and R8_LP on dep_mutex.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* pthread_create.c (start_thread): Check __PTHREAD_MUTEX_HAVE_PREV
+	instead of __WORDSIZE.
+
+	* sysdeps/pthread/pthread.h (PTHREAD_MUTEX_INITIALIZER): Check
+	__PTHREAD_MUTEX_HAVE_PREV instead of __WORDSIZE.
+	(PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP): Likewise.
+	(PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP): Likewise.
+	(PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP): Likewise.
+	(__PTHREAD_RWLOCK_INT_FLAGS_SHARED): New.
+	(PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP): Check
+	__PTHREAD_RWLOCK_INT_FLAGS_SHARED instead of __WORDSIZE.
+
+	* sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h: Define x32
+	__SIZEOF_PTHREAD_XXX_T.
+	(__pthread_internal_list): Check __x86_64__ instead of __WORDSIZE.
+	(pthread_mutex_t): Likewise.
+	(pthread_rwlock_t): Likewise.
+	(__PTHREAD_RWLOCK_INT_FLAGS_SHARED): New.  Defined if __x86_64__
+	is defined.
+
+	* sysdeps/x86_64/tls.h: Don't include <bits/wordsize.h>.
+	Check __x86_64__ instead of __WORDSIZE.
+	(tcbhead_t): Pad rtld_savespace_sse to 32byte aligned.
+	(THREAD_SETMEM): Use long long on 64bit integer.
+	(THREAD_SETMEM_NC): Likewise.
+
+	* sysdeps/x86_64/x32/tls.h: New.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/x86_64/pthreaddef.h (CURRENT_STACK_FRAME): Use
+	RSP_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/lowlevellock.h (__NR_futex): New.
+	(SYS_futex): Use it.
+	(LLL_STUB_UNWIND_INFO_START): Align label to LP_SIZE instead
+	of 8.
+	(LLL_STUB_UNWIND_INFO_END): Likewise.  Use RDX_LP.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* unwind.c (unwind_stop): Cast _Unwind_GetCFA return to
+	_Unwind_Ptr first.
+
+2011-11-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* sysdeps/unix/sysv/linux/x86_64/cancellation.S: Use MOVE_LP
+	and RDI_LP.
+
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S: Use
+	RXX_LP and CMP_LP.
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S: Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S: Use
+	 RXX_LP and CMP_LP.  Use LP_SIZE and ASM_ADDR on
+	 __gcc_personality_v0.
+	* sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S: Likewise.
+
+	* sysdeps/unix/sysv/linux/x86_64/pthread_once.S: Use LP_SIZE
+	and ASM_ADDR.
+
+	* sysdeps/unix/sysv/linux/x86_64/sem_post.S: Use CMP_LP on
+	NWAITERS.
+
+	* sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S: Use ADD_LP
+	and SUB_LP on NWAITERS.  Use LP_SIZE and ASM_ADDR on
+	__gcc_personality_v0.
+	* sysdeps/unix/sysv/linux/x86_64/sem_wait.S: Likewise.
diff --git a/nptl/pthread_create.c b/nptl/pthread_create.c
index 6250d03..232048d 100644
--- a/nptl/pthread_create.c
+++ b/nptl/pthread_create.c
@@ -356,7 +356,7 @@ start_thread (void *arg)
 
 #ifndef __ASSUME_SET_ROBUST_LIST
   /* If this thread has any robust mutexes locked, handle them now.  */
-# if __WORDSIZE == 64
+# ifdef __PTHREAD_MUTEX_HAVE_PREV
   void *robust = pd->robust_head.list;
 # else
   __pthread_slist_t *robust = pd->robust_list.__next;
diff --git a/nptl/sysdeps/pthread/pthread.h b/nptl/sysdeps/pthread/pthread.h
index a924281..1e645f0 100644
--- a/nptl/sysdeps/pthread/pthread.h
+++ b/nptl/sysdeps/pthread/pthread.h
@@ -85,7 +85,7 @@ enum
 
 
 /* Mutex initializers.  */
-#if __WORDSIZE == 64
+#ifdef __PTHREAD_MUTEX_HAVE_PREV
 # define PTHREAD_MUTEX_INITIALIZER \
   { { 0, 0, 0, 0, 0, 0, { 0, 0 } } }
 # ifdef __USE_GNU
@@ -120,11 +120,17 @@ enum
   PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
 };
 
+#ifndef __PTHREAD_RWLOCK_INT_FLAGS_SHARED
+# if __WORDSIZE == 64
+#  define __PTHREAD_RWLOCK_INT_FLAGS_SHARED 1
+# endif
+#endif
+
 /* Read-write lock initializers.  */
 # define PTHREAD_RWLOCK_INITIALIZER \
   { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }
 # ifdef __USE_GNU
-#  if __WORDSIZE == 64
+#  ifdef __PTHREAD_RWLOCK_INT_FLAGS_SHARED
 #   define PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP \
   { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,					      \
 	PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP } }
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h b/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h
index 7a09c81..43e5119 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/bits/pthreadtypes.h
@@ -22,16 +22,28 @@
 
 #include <bits/wordsize.h>
 
-#if __WORDSIZE == 64
-# define __SIZEOF_PTHREAD_ATTR_T 56
-# define __SIZEOF_PTHREAD_MUTEX_T 40
-# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
-# define __SIZEOF_PTHREAD_COND_T 48
-# define __SIZEOF_PTHREAD_CONDATTR_T 4
-# define __SIZEOF_PTHREAD_RWLOCK_T 56
-# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
-# define __SIZEOF_PTHREAD_BARRIER_T 32
-# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#ifdef __x86_64__
+# if __WORDSIZE == 64
+#  define __SIZEOF_PTHREAD_ATTR_T 56
+#  define __SIZEOF_PTHREAD_MUTEX_T 40
+#  define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#  define __SIZEOF_PTHREAD_COND_T 48
+#  define __SIZEOF_PTHREAD_CONDATTR_T 4
+#  define __SIZEOF_PTHREAD_RWLOCK_T 56
+#  define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#  define __SIZEOF_PTHREAD_BARRIER_T 32
+#  define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+# else
+#  define __SIZEOF_PTHREAD_ATTR_T 32
+#  define __SIZEOF_PTHREAD_MUTEX_T 32
+#  define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#  define __SIZEOF_PTHREAD_COND_T 48
+#  define __SIZEOF_PTHREAD_CONDATTR_T 4
+#  define __SIZEOF_PTHREAD_RWLOCK_T 44
+#  define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#  define __SIZEOF_PTHREAD_BARRIER_T 20
+#  define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+# endif
 #else
 # define __SIZEOF_PTHREAD_ATTR_T 36
 # define __SIZEOF_PTHREAD_MUTEX_T 24
@@ -57,7 +69,7 @@ typedef union
 } pthread_attr_t;
 
 
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 typedef struct __pthread_internal_list
 {
   struct __pthread_internal_list *__prev;
@@ -80,13 +92,13 @@ typedef union
     int __lock;
     unsigned int __count;
     int __owner;
-#if __WORDSIZE == 64
+#ifdef __x86_64__
     unsigned int __nusers;
 #endif
     /* KIND must stay at this position in the structure to maintain
        binary compatibility.  */
     int __kind;
-#if __WORDSIZE == 64
+#ifdef __x86_64__
     int __spins;
     __pthread_list_t __list;
 # define __PTHREAD_MUTEX_HAVE_PREV	1
@@ -149,7 +161,7 @@ typedef int pthread_once_t;
    structure of the attribute type is not exposed on purpose.  */
 typedef union
 {
-# if __WORDSIZE == 64
+# ifdef __x86_64__
   struct
   {
     int __lock;
@@ -165,6 +177,7 @@ typedef union
     /* FLAGS must stay at this position in the structure to maintain
        binary compatibility.  */
     unsigned int __flags;
+# define __PTHREAD_RWLOCK_INT_FLAGS_SHARED	1
   } __data;
 # else
   struct
@@ -217,7 +230,7 @@ typedef union
 #endif
 
 
-#if __WORDSIZE == 32
+#ifndef __x86_64__
 /* Extra attributes for the cleanup functions.  */
 # define __cleanup_fct_attribute __attribute__ ((__regparm__ (1)))
 #endif
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S b/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S
index a06cd9b..a0dce33 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/cancellation.S
@@ -73,10 +73,10 @@ ENTRY(__pthread_enable_asynccancel)
 
 3:	subq	$8, %rsp
 	cfi_adjust_cfa_offset(8)
-	movq	$TCB_PTHREAD_CANCELED, %fs:RESULT
+	LP_OP(mov) $TCB_PTHREAD_CANCELED, %fs:RESULT
 	lock
 	orl	$TCB_EXITING_BITMASK, %fs:CANCELHANDLING
-	movq	%fs:CLEANUP_JMP_BUF, %rdi
+	mov	%fs:CLEANUP_JMP_BUF, %RDI_LP
 #ifdef SHARED
 	call	__pthread_unwind@PLT
 #else
@@ -107,7 +107,7 @@ ENTRY(__pthread_disable_asynccancel)
 	/* Performance doesn't matter in this loop.  We will
 	   delay until the thread is canceled.  And we will unlikely
 	   enter the loop twice.  */
-4:	movq	%fs:0, %rdi
+4:	mov	%fs:0, %RDI_LP
 	movl	$__NR_futex, %eax
 	xorq	%r10, %r10
 	addq	$CANCELHANDLING, %rdi
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
index 9b15bfb..023a675 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/lowlevellock.h
@@ -44,7 +44,11 @@
 # endif
 #endif
 
-#define SYS_futex		202
+#ifndef __NR_futex
+# define __NR_futex		202
+#endif
+
+#define SYS_futex		__NR_futex
 #define FUTEX_WAIT		0
 #define FUTEX_WAKE		1
 #define FUTEX_CMP_REQUEUE	4
@@ -120,7 +124,7 @@
 	".byte	0x12	# DW_CFA_def_cfa_sf\n\t" 		\
 	".uleb128 0x7\n\t" 					\
 	".sleb128 16\n\t" 					\
-	".align 8\n" 						\
+	".align " LP_SIZE "\n" 					\
 "9:\t"	".long	23f-10f	# FDE Length\n" 			\
 "10:\t"	".long	10b-7b	# FDE CIE offset\n\t" 			\
 	".long	1b-.	# FDE initial location\n\t" 		\
@@ -167,7 +171,7 @@
 	".uleb128 22f-21f\n" 					\
 "21:\t"	".byte	0x80	# DW_OP_breg16\n\t" 			\
 	".sleb128 4b-5b\n" 					\
-"22:\t"	".align 8\n" 						\
+"22:\t"	".align " LP_SIZE "\n" 					\
 "23:\t"	".previous\n"
 
 /* Unwind info for
@@ -408,7 +412,7 @@ LLL_STUB_UNWIND_INFO_END
 		       ".type _L_timedlock_%=, @function\n"		      \
 		       "_L_timedlock_%=:\n"				      \
 		       "1:\tleaq %4, %%rdi\n"				      \
-		       "0:\tmovq %8, %%rdx\n"				      \
+		       "0:\tmov %8, %%" RDX_LP "\n"			      \
 		       "2:\tsubq $128, %%rsp\n"				      \
 		       "3:\tcallq __lll_timedlock_wait\n"		      \
 		       "4:\taddq $128, %%rsp\n"				      \
@@ -432,7 +436,7 @@ LLL_STUB_UNWIND_INFO_END
 		       ".type _L_robust_timedlock_%=, @function\n"	      \
 		       "_L_robust_timedlock_%=:\n"			      \
 		       "1:\tleaq %4, %%rdi\n"				      \
-		       "0:\tmovq %8, %%rdx\n"				      \
+		       "0:\tmov %8, %%" RDX_LP "\n"			      \
 		       "2:\tsubq $128, %%rsp\n"				      \
 		       "3:\tcallq __lll_robust_timedlock_wait\n"	      \
 		       "4:\taddq $128, %%rsp\n"				      \
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S
index 224a560..61d450f 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_broadcast.S
@@ -60,14 +60,14 @@ __pthread_cond_broadcast:
 	incl	broadcast_seq-cond_futex(%rdi)
 
 	/* Get the address of the mutex used.  */
-	movq	dep_mutex-cond_futex(%rdi), %r8
+	mov	dep_mutex-cond_futex(%rdi), %R8_LP
 
 	/* Unlock.  */
 	LOCK
 	decl	cond_lock-cond_futex(%rdi)
 	jne	7f
 
-8:	cmpq	$-1, %r8
+8:	cmp	$-1, %R8_LP
 	je	9f
 
 	/* Do not use requeue for pshared condvars.  */
@@ -129,7 +129,7 @@ __pthread_cond_broadcast:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -141,7 +141,7 @@ __pthread_cond_broadcast:
 
 	/* Unlock in loop requires wakeup.  */
 5:	addq	$cond_lock-cond_futex, %rdi
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -150,7 +150,7 @@ __pthread_cond_broadcast:
 
 	/* Unlock in loop requires wakeup.  */
 7:	addq	$cond_lock-cond_futex, %rdi
-	cmpq	$-1, %r8
+	cmp	$-1, %R8_LP
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -159,7 +159,7 @@ __pthread_cond_broadcast:
 	jmp	8b
 
 9:	/* The futex requeue functionality is not available.  */
-	cmpq	$-1, %r8
+	cmp	$-1, %R8_LP
 	movl	$0x7fffffff, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAKE, %eax
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
index d1d83a8..c750115 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_signal.S
@@ -56,14 +56,14 @@ __pthread_cond_signal:
 	addl	$1, (%rdi)
 
 	/* Wake up one thread.  */
-	cmpq	$-1, dep_mutex(%r8)
+	LP_OP(cmp) $-1, dep_mutex(%r8)
 	movl	$FUTEX_WAKE_OP, %esi
 	movl	$1, %edx
 	movl	$SYS_futex, %eax
 	je	8f
 
 	/* Get the address of the mutex used.  */
-	movq    dep_mutex(%r8), %rcx
+	mov     dep_mutex(%r8), %RCX_LP
 	movl	MUTEX_KIND(%rcx), %r11d
 	andl	$(ROBUST_BIT|PI_BIT), %r11d
 	cmpl	$PI_BIT, %r11d
@@ -135,7 +135,7 @@ __pthread_cond_signal:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -151,7 +151,7 @@ __pthread_cond_signal:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
index acbd3fa..b50576b 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_timedwait.S
@@ -90,7 +90,7 @@ __pthread_cond_timedwait:
 		    +--------------------------+
 	*/
 
-	cmpq	$-1, dep_mutex(%rdi)
+	LP_OP(cmp) $-1, dep_mutex(%rdi)
 
 	/* Prepare structure passed to cancellation handler.  */
 	movq	%rdi, 8(%rsp)
@@ -98,7 +98,7 @@ __pthread_cond_timedwait:
 	movq	%rdx, %r13
 
 	je	22f
-	movq	%rsi, dep_mutex(%rdi)
+	mov	%RSI_LP, dep_mutex(%rdi)
 
 22:
 	xorl	%r15d, %r15d
@@ -164,10 +164,10 @@ __pthread_cond_timedwait:
 
 	movq	%r13, %r10
 	movl	$FUTEX_WAIT_BITSET, %esi
-	cmpq	$-1, dep_mutex(%rdi)
+	LP_OP(cmp) $-1, dep_mutex(%rdi)
 	je	60f
 
-	movq	dep_mutex(%rdi), %r8
+	mov	dep_mutex(%rdi), %R8_LP
 	/* Requeue to a non-robust PI mutex if the PI bit is set and
 	the robust bit is not set.  */
 	movl	MUTEX_KIND(%r8), %eax
@@ -269,7 +269,7 @@ __pthread_cond_timedwait:
 	jne	55f
 
 	addq	$cond_nwaiters, %rdi
-	cmpq	$-1, dep_mutex-cond_nwaiters(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_nwaiters(%rdi)
 	movl	$1, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAKE, %eax
@@ -332,7 +332,7 @@ __pthread_cond_timedwait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -344,7 +344,7 @@ __pthread_cond_timedwait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -356,7 +356,7 @@ __pthread_cond_timedwait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -371,7 +371,7 @@ __pthread_cond_timedwait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -392,7 +392,7 @@ __pthread_cond_timedwait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -447,9 +447,9 @@ __pthread_cond_timedwait:
 	   kernel.  */
 	leaq	32(%rsp), %rsi
 #  ifdef SHARED
-	movq	__vdso_clock_gettime@GOTPCREL(%rip), %rax
-	movq	(%rax), %rax
-	PTR_DEMANGLE (%rax)
+	mov	__vdso_clock_gettime@GOTPCREL(%rip), %RAX_LP
+	mov	(%rax), %RAX_LP
+	PTR_DEMANGLE (%RAX_LP)
 	call	*%rax
 #  else
 	movl	$__NR_clock_gettime, %eax
@@ -509,7 +509,7 @@ __pthread_cond_timedwait:
 	movl	%eax, (%rsp)
 
 	leaq	32(%rsp), %r10
-	cmpq	$-1, dep_mutex(%rdi)
+	LP_OP(cmp) $-1, dep_mutex(%rdi)
 	movq	%r12, %rdx
 # ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAIT, %eax
@@ -569,7 +569,7 @@ __pthread_cond_timedwait:
 # if cond_lock != 0
 	addq	$cond_lock, %rdi
 # endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -581,7 +581,7 @@ __pthread_cond_timedwait:
 # if cond_lock != 0
 	addq	$cond_lock, %rdi
 # endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -593,7 +593,7 @@ __pthread_cond_timedwait:
 # if cond_lock != 0
 	addq	$cond_lock, %rdi
 # endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -676,7 +676,7 @@ __condvar_cleanup2:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -709,7 +709,7 @@ __condvar_cleanup2:
 	andl	$~((1 << nwaiters_shift) - 1), %eax
 	jne	4f
 
-	cmpq	$-1, dep_mutex(%rdi)
+	LP_OP(cmp) $-1, dep_mutex(%rdi)
 	leaq	cond_nwaiters(%rdi), %rdi
 	movl	$1, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
@@ -737,7 +737,7 @@ __condvar_cleanup2:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -747,7 +747,7 @@ __condvar_cleanup2:
 2:	testq	%r12, %r12
 	jnz	5f
 	addq	$cond_futex, %rdi
-	cmpq	$-1, dep_mutex-cond_futex(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_futex(%rdi)
 	movl	$0x7fffffff, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAKE, %eax
@@ -806,9 +806,9 @@ __condvar_cleanup2:
 	.hidden	DW.ref.__gcc_personality_v0
 	.weak	DW.ref.__gcc_personality_v0
 	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	8
+	.align	LP_SIZE
 	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, 8
+	.size	DW.ref.__gcc_personality_v0, LP_SIZE
 DW.ref.__gcc_personality_v0:
-	.quad	__gcc_personality_v0
+	ASM_ADDR __gcc_personality_v0
 #endif
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
index d837d15..e28a0a7 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_cond_wait.S
@@ -66,14 +66,14 @@ __pthread_cond_wait:
 	            +--------------------------+
 	*/
 
-	cmpq	$-1, dep_mutex(%rdi)
+	LP_OP(cmp) $-1, dep_mutex(%rdi)
 
 		/* Prepare structure passed to cancellation handler.  */
 	movq	%rdi, 8(%rsp)
 	movq	%rsi, 16(%rsp)
 
 	je	15f
-	movq	%rsi, dep_mutex(%rdi)
+	mov	%RSI_LP, dep_mutex(%rdi)
 
 	/* Get internal lock.  */
 15:	movl	$1, %esi
@@ -121,12 +121,12 @@ __pthread_cond_wait:
 	movl	%eax, (%rsp)
 
 	xorq	%r10, %r10
-	cmpq	$-1, dep_mutex(%rdi)
+	LP_OP(cmp) $-1, dep_mutex(%rdi)
 	leaq	cond_futex(%rdi), %rdi
 	movl	$FUTEX_WAIT, %esi
 	je	60f
 
-	movq	dep_mutex-cond_futex(%rdi), %r8
+	mov	dep_mutex-cond_futex(%rdi), %R8_LP
 	/* Requeue to a non-robust PI mutex if the PI bit is set and
 	the robust bit is not set.  */
 	movl	MUTEX_KIND(%r8), %eax
@@ -207,7 +207,7 @@ __pthread_cond_wait:
 	jne	17f
 
 	addq	$cond_nwaiters, %rdi
-	cmpq	$-1, dep_mutex-cond_nwaiters(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_nwaiters(%rdi)
 	movl	$1, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAKE, %eax
@@ -256,7 +256,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -268,7 +268,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -284,7 +284,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -299,7 +299,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -320,7 +320,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -349,7 +349,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -375,7 +375,7 @@ __pthread_cond_wait:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -387,7 +387,7 @@ __pthread_cond_wait:
 93:
 	/* Set the rest of SYS_futex args for FUTEX_WAIT_REQUEUE_PI. */
 	xorq	%r10, %r10
-	movq	dep_mutex(%rdi), %r8
+	mov	dep_mutex(%rdi), %R8_LP
 	leaq	cond_futex(%rdi), %rdi
 	jmp	90b
 .LcleanupEND2:
@@ -435,7 +435,7 @@ __condvar_cleanup1:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -468,7 +468,7 @@ __condvar_cleanup1:
 	andl	$~((1 << nwaiters_shift) - 1), %eax
 	jne	4f
 
-	cmpq	$-1, dep_mutex(%rdi)
+	LP_OP(cmp) $-1, dep_mutex(%rdi)
 	leaq	cond_nwaiters(%rdi), %rdi
 	movl	$1, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
@@ -496,7 +496,7 @@ __condvar_cleanup1:
 #if cond_lock != 0
 	addq	$cond_lock, %rdi
 #endif
-	cmpq	$-1, dep_mutex-cond_lock(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_lock(%rdi)
 	movl	$LLL_PRIVATE, %eax
 	movl	$LLL_SHARED, %esi
 	cmovne	%eax, %esi
@@ -507,7 +507,7 @@ __condvar_cleanup1:
 2:	testl	%ecx, %ecx
 	jnz	5f
 	addq	$cond_futex, %rdi
-	cmpq	$-1, dep_mutex-cond_futex(%rdi)
+	LP_OP(cmp) $-1, dep_mutex-cond_futex(%rdi)
 	movl	$0x7fffffff, %edx
 #ifdef __ASSUME_PRIVATE_FUTEX
 	movl	$FUTEX_WAKE, %eax
@@ -560,9 +560,9 @@ __condvar_cleanup1:
 	.hidden	DW.ref.__gcc_personality_v0
 	.weak	DW.ref.__gcc_personality_v0
 	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	8
+	.align	LP_SIZE
 	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, 8
+	.size	DW.ref.__gcc_personality_v0, LP_SIZE
 DW.ref.__gcc_personality_v0:
-	.quad	__gcc_personality_v0
+	ASM_ADDR __gcc_personality_v0
 #endif
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
index ccc1849..4b28743 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/pthread_once.S
@@ -189,9 +189,9 @@ clear_once_control:
 	.hidden	DW.ref.__gcc_personality_v0
 	.weak	DW.ref.__gcc_personality_v0
 	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	8
+	.align	LP_SIZE
 	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, 8
+	.size	DW.ref.__gcc_personality_v0, LP_SIZE
 DW.ref.__gcc_personality_v0:
-	.quad	__gcc_personality_v0
+	ASM_ADDR __gcc_personality_v0
 #endif
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S
index 4691e4d..df68319 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_post.S
@@ -46,7 +46,7 @@ sem_post:
 #endif
 	jnz	0b
 
-	cmpq	$0, NWAITERS(%rdi)
+	LP_OP(cmp) $0, NWAITERS(%rdi)
 	je	2f
 
 	movl	$SYS_futex, %eax
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S
index 576a494..80d44c3 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_timedwait.S
@@ -84,7 +84,7 @@ sem_timedwait:
 	movq	%rsi, %r10
 
 	LOCK
-	addq	$1, NWAITERS(%rdi)
+	LP_OP(add) $1, NWAITERS(%rdi)
 
 .LcleanupSTART:
 13:	call	__pthread_enable_asynccancel
@@ -135,7 +135,7 @@ sem_timedwait:
 	xorl	%eax, %eax
 
 15:	LOCK
-	subq	$1, NWAITERS(%rdi)
+	LP_OP(sub) $1, NWAITERS(%rdi)
 
 	leaq	8(%rsp), %rsp
 	cfi_adjust_cfa_offset(-8)
@@ -190,7 +190,7 @@ sem_timedwait:
 	movq	%rsi, %r13
 
 	LOCK
-	addq	$1, NWAITERS(%r12)
+	LP_OP(add) $1, NWAITERS(%r12)
 
 7:	xorl	%esi, %esi
 	movq	%rsp,%rdi
@@ -267,7 +267,7 @@ sem_timedwait:
 	xorl	%eax, %eax
 
 45:	LOCK
-	subq	$1, NWAITERS(%r12)
+	LP_OP(sub) $1, NWAITERS(%r12)
 
 	addq	$STACKFRAME, %rsp
 	cfi_adjust_cfa_offset(-STACKFRAME)
@@ -305,7 +305,7 @@ sem_timedwait_cleanup:
 
 	movq	(%rsp), %rdi
 	LOCK
-	subq	$1, NWAITERS(%rdi)
+	LP_OP(sub) $1, NWAITERS(%rdi)
 	movq	%rax, %rdi
 .LcallUR:
 	call	_Unwind_Resume@PLT
@@ -325,7 +325,7 @@ sem_timedwait_cleanup2:
 	cfi_rel_offset(%r14, STACKFRAME)
 
 	LOCK
-	subq	$1, NWAITERS(%r12)
+	LP_OP(sub) $1, NWAITERS(%r12)
 	movq	%rax, %rdi
 	movq	STACKFRAME(%rsp), %r14
 	movq	STACKFRAME+8(%rsp), %r13
@@ -373,9 +373,9 @@ sem_timedwait_cleanup2:
 	.hidden	DW.ref.__gcc_personality_v0
 	.weak	DW.ref.__gcc_personality_v0
 	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	8
+	.align	LP_SIZE
 	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, 8
+	.size	DW.ref.__gcc_personality_v0, LP_SIZE
 DW.ref.__gcc_personality_v0:
-	.quad	__gcc_personality_v0
+	ASM_ADDR __gcc_personality_v0
 #endif
diff --git a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S
index 3ea714a..9d12b42 100644
--- a/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S
+++ b/nptl/sysdeps/unix/sysv/linux/x86_64/sem_wait.S
@@ -67,7 +67,7 @@ sem_wait:
 	cfi_adjust_cfa_offset(8)
 
 	LOCK
-	addq	$1, NWAITERS(%rdi)
+	LP_OP(add) $1, NWAITERS(%rdi)
 
 .LcleanupSTART:
 6:	call	__pthread_enable_asynccancel
@@ -116,7 +116,7 @@ sem_wait:
 	xorl	%eax, %eax
 
 9:	LOCK
-	subq	$1, NWAITERS(%rdi)
+	LP_OP(sub) $1, NWAITERS(%rdi)
 
 	leaq	8(%rsp), %rsp
 	cfi_adjust_cfa_offset(-8)
@@ -137,7 +137,7 @@ sem_wait:
 sem_wait_cleanup:
 	movq	(%rsp), %rdi
 	LOCK
-	subq	$1, NWAITERS(%rdi)
+	LP_OP(sub) $1, NWAITERS(%rdi)
 	movq	%rax, %rdi
 .LcallUR:
 	call	_Unwind_Resume@PLT
@@ -169,9 +169,9 @@ sem_wait_cleanup:
 	.hidden	DW.ref.__gcc_personality_v0
 	.weak	DW.ref.__gcc_personality_v0
 	.section .gnu.linkonce.d.DW.ref.__gcc_personality_v0,"aw",@progbits
-	.align	8
+	.align	LP_SIZE
 	.type	DW.ref.__gcc_personality_v0, @object
-	.size	DW.ref.__gcc_personality_v0, 8
+	.size	DW.ref.__gcc_personality_v0, LP_SIZE
 DW.ref.__gcc_personality_v0:
-	.quad	__gcc_personality_v0
+	ASM_ADDR __gcc_personality_v0
 #endif
diff --git a/nptl/sysdeps/x86_64/pthreaddef.h b/nptl/sysdeps/x86_64/pthreaddef.h
index 9de4af2..23da637 100644
--- a/nptl/sysdeps/x86_64/pthreaddef.h
+++ b/nptl/sysdeps/x86_64/pthreaddef.h
@@ -42,7 +42,7 @@
 
 /* Location of current stack frame.  The frame pointer is not usable.  */
 #define CURRENT_STACK_FRAME \
-  ({ char *frame; asm ("movq %%rsp, %0" : "=r" (frame)); frame; })
+  ({ register char *frame __asm__("rsp"); frame; })
 
 
 /* XXX Until we have a better place keep the definitions here.  */
diff --git a/nptl/sysdeps/x86_64/tls.h b/nptl/sysdeps/x86_64/tls.h
index 95e022b..d818da5 100644
--- a/nptl/sysdeps/x86_64/tls.h
+++ b/nptl/sysdeps/x86_64/tls.h
@@ -28,7 +28,6 @@
 # include <stdlib.h>
 # include <sysdep.h>
 # include <kernel-features.h>
-# include <bits/wordsize.h>
 # include <xmmintrin.h>
 
 
@@ -61,17 +60,22 @@ typedef struct
 # else
   int __unused1;
 # endif
-# if __WORDSIZE == 64
+# ifdef __x86_64__
   int rtld_must_xmm_save;
 # endif
   /* Reservation of some values for the TM ABI.  */
   void *__private_tm[5];
-# if __WORDSIZE == 64
+# ifdef __x86_64__
+#  ifdef __LP64__
   long int __unused2;
+#  else
+  /* Pad rtld_savespace_sse to 32byte aligned.  */
+  void *__padding1[5];
+#  endif
   /* Have space for the post-AVX register size.  */
   __m128 rtld_savespace_sse[8][4];
 
-  void *__padding[8];
+  void *__padding2[8];
 # endif
 } tcbhead_t;
 
@@ -269,7 +273,7 @@ typedef struct
 	   abort ();							      \
 									      \
 	 asm volatile ("movq %q0,%%fs:%P1" :				      \
-		       : IMM_MODE ((unsigned long int) value),		      \
+		       : IMM_MODE ((unsigned long long int) value),	      \
 			 "i" (offsetof (struct pthread, member)));	      \
        }})
 
@@ -294,7 +298,7 @@ typedef struct
 	   abort ();							      \
 									      \
 	 asm volatile ("movq %q0,%%fs:%P1(,%q2,8)" :			      \
-		       : IMM_MODE ((unsigned long int) value),		      \
+		       : IMM_MODE ((unsigned long long int) value),	      \
 			 "i" (offsetof (struct pthread, member[0])),	      \
 			 "r" (idx));					      \
        }})
diff --git a/nptl/sysdeps/x86_64/x32/shlib-versions b/nptl/sysdeps/x86_64/x32/shlib-versions
new file mode 100644
index 0000000..80ff581
--- /dev/null
+++ b/nptl/sysdeps/x86_64/x32/shlib-versions
@@ -0,0 +1 @@
+x86_64-.*-linux.*	libpthread=0		GLIBC_2.16
diff --git a/nptl/sysdeps/x86_64/x32/tls.h b/nptl/sysdeps/x86_64/x32/tls.h
new file mode 100644
index 0000000..6622b4e
--- /dev/null
+++ b/nptl/sysdeps/x86_64/x32/tls.h
@@ -0,0 +1,49 @@
+/* Definition for thread-local data handling.  nptl/x32 version.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _X32_TLS_H
+#define _X32_TLS_H	1
+
+#include <sysdeps/x86_64/tls.h>
+
+#ifndef __ASSEMBLER__
+
+# undef THREAD_SELF
+# define THREAD_SELF \
+  ({ struct pthread *__self;						      \
+     asm ("movl %%fs:%c1,%k0" : "=r" (__self)				      \
+	  : "i" (offsetof (struct pthread, header.self)));	 	      \
+     __self;})
+
+# undef CALL_THREAD_FCT
+# define CALL_THREAD_FCT(descr) \
+  ({ void *__res;							      \
+     asm volatile ("movl %%fs:%P2, %%edi\n\t"				      \
+		   "movl %%fs:%P1, %k0\n\t"				      \
+		   "callq *%q0"						      \
+		   : "=a" (__res)					      \
+		   : "i" (offsetof (struct pthread, start_routine)),	      \
+		     "i" (offsetof (struct pthread, arg))		      \
+		   : "di", "si", "cx", "dx", "r8", "r9", "r10", "r11",	      \
+		     "memory", "cc");					      \
+     __res; })
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* x32/tls.h */
diff --git a/nptl/unwind.c b/nptl/unwind.c
index 9a35695..37eeba7 100644
--- a/nptl/unwind.c
+++ b/nptl/unwind.c
@@ -69,7 +69,7 @@ unwind_stop (int version, _Unwind_Action actions,
 	 registered with the old method which would be unwound by this
 	 step.  */
       struct _pthread_cleanup_buffer *oldp = buf->priv.data.cleanup;
-      void *cfa = (void *) _Unwind_GetCFA (context);
+      void *cfa = (void *) (_Unwind_Ptr) _Unwind_GetCFA (context);
 
       if (curp != oldp && (do_longjump || FRAME_LEFT (cfa, curp, adj)))
 	{
diff --git a/scripts/data/c++-types-x32-linux-gnu.data b/scripts/data/c++-types-x32-linux-gnu.data
new file mode 100644
index 0000000..348bf52
--- /dev/null
+++ b/scripts/data/c++-types-x32-linux-gnu.data
@@ -0,0 +1,67 @@
+blkcnt64_t:x
+blkcnt_t:x
+blksize_t:x
+caddr_t:Pc
+clockid_t:i
+clock_t:x
+daddr_t:i
+dev_t:y
+fd_mask:l
+fsblkcnt64_t:y
+fsblkcnt_t:y
+fsfilcnt64_t:y
+fsfilcnt_t:y
+fsid_t:8__fsid_t
+gid_t:j
+id_t:j
+ino64_t:y
+ino_t:y
+int16_t:s
+int32_t:i
+int64_t:x
+int8_t:a
+intptr_t:i
+key_t:i
+loff_t:x
+mode_t:j
+nlink_t:y
+off64_t:x
+off_t:x
+pid_t:i
+pthread_attr_t:14pthread_attr_t
+pthread_barrier_t:17pthread_barrier_t
+pthread_barrierattr_t:21pthread_barrierattr_t
+pthread_cond_t:14pthread_cond_t
+pthread_condattr_t:18pthread_condattr_t
+pthread_key_t:j
+pthread_mutex_t:15pthread_mutex_t
+pthread_mutexattr_t:19pthread_mutexattr_t
+pthread_once_t:i
+pthread_rwlock_t:16pthread_rwlock_t
+pthread_rwlockattr_t:20pthread_rwlockattr_t
+pthread_spinlock_t:i
+pthread_t:m
+quad_t:x
+register_t:x
+rlim64_t:y
+rlim_t:y
+sigset_t:10__sigset_t
+size_t:j
+socklen_t:j
+ssize_t:i
+suseconds_t:x
+time_t:x
+u_char:h
+uid_t:j
+uint:j
+u_int:j
+u_int16_t:t
+u_int32_t:j
+u_int64_t:y
+u_int8_t:h
+ulong:m
+u_long:m
+u_quad_t:y
+useconds_t:j
+ushort:t
+u_short:t
diff --git a/shlib-versions b/shlib-versions
index a7839de..82fc846 100644
--- a/shlib-versions
+++ b/shlib-versions
@@ -28,7 +28,6 @@
 
 s390x-.*-linux.*        DEFAULT			GLIBC_2.2
 cris-.*-linux.*		DEFAULT			GLIBC_2.2
-x86_64-.*-linux.*       DEFAULT			GLIBC_2.2.5
 powerpc64-.*-linux.*	DEFAULT			GLIBC_2.3
 .*-.*-gnu-gnu.*		DEFAULT			GLIBC_2.2.6
 
@@ -85,7 +84,6 @@ ia64-.*-linux.*		ld=ld-linux-ia64.so.2	GLIBC_2.2
 s390x-.*-linux.*	ld=ld64.so.1		GLIBC_2.2
 powerpc64.*-.*-linux.*	ld=ld64.so.1		GLIBC_2.3
 cris-.*-linux.*		ld=ld.so.1		GLIBC_2.2
-x86_64-.*-linux.*	ld=ld-linux-x86-64.so.2	GLIBC_2.2.5
 # We use the ELF ABI standard name for the default.
 .*-.*-.*		ld=ld.so.1
 
diff --git a/stdio-common/_itoa.c b/stdio-common/_itoa.c
index 373843f..abb28aa 100644
--- a/stdio-common/_itoa.c
+++ b/stdio-common/_itoa.c
@@ -80,7 +80,7 @@ struct base_table_t
 
 
 /* We do not compile _itoa if we always can use _itoa_word.  */
-#if LLONG_MAX != LONG_MAX
+#if LLONG_MAX != LONG_MAX && !defined PREFER_LONG_LONG
 /* Local variables.  */
 const struct base_table_t _itoa_base_table[] attribute_hidden =
 {
@@ -202,7 +202,6 @@ _itoa_word (unsigned long value, char *buflim,
     }
   return buflim;
 }
-#undef SPECIAL
 
 
 #if LLONG_MAX != LONG_MAX
@@ -216,11 +215,31 @@ _itoa (value, buflim, base, upper_case)
   const char *digits = (upper_case
 			? INTUSE(_itoa_upper_digits)
 			: INTUSE(_itoa_lower_digits));
+
+# ifdef PREFER_LONG_LONG
+  switch (base)
+    {
+#define SPECIAL(Base)							      \
+    case Base:								      \
+      do								      \
+	*--buflim = digits[value % Base];				      \
+      while ((value /= Base) != 0);					      \
+      break
+
+      SPECIAL (10);
+      SPECIAL (16);
+      SPECIAL (8);
+    default:
+      do
+	*--buflim = digits[value % base];
+      while ((value /= base) != 0);
+    }
+# else
   const struct base_table_t *brec = &_itoa_base_table[base - 2];
 
   switch (base)
     {
-# define RUN_2N(BITS) \
+#  define RUN_2N(BITS) \
       do								      \
         {								      \
 	  /* `unsigned long long int' always has 64 bits.  */		      \
@@ -275,7 +294,7 @@ _itoa (value, buflim, base, upper_case)
     default:
       {
 	char *bufend = buflim;
-# if BITS_PER_MP_LIMB == 64
+#  if BITS_PER_MP_LIMB == 64
 	mp_limb_t base_multiplier = brec->base_multiplier;
 	if (brec->flag)
 	  while (value != 0)
@@ -299,8 +318,8 @@ _itoa (value, buflim, base, upper_case)
 	      *--buflim = digits[rem];
 	      value = quo;
 	    }
-# endif
-# if BITS_PER_MP_LIMB == 32
+#  endif
+#  if BITS_PER_MP_LIMB == 32
 	mp_limb_t t[3];
 	int n;
 
@@ -308,11 +327,11 @@ _itoa (value, buflim, base, upper_case)
 	   Optimize for frequent cases of 32 bit numbers.  */
 	if ((mp_limb_t) (value >> 32) >= 1)
 	  {
-#  if UDIV_TIME > 2 * UMUL_TIME || UDIV_NEEDS_NORMALIZATION
+#   if UDIV_TIME > 2 * UMUL_TIME || UDIV_NEEDS_NORMALIZATION
 	    int big_normalization_steps = brec->big.normalization_steps;
 	    mp_limb_t big_base_norm
 	      = brec->big.base << big_normalization_steps;
-#  endif
+#   endif
 	    if ((mp_limb_t) (value >> 32) >= brec->big.base)
 	      {
 		mp_limb_t x1hi, x1lo, r;
@@ -321,7 +340,7 @@ _itoa (value, buflim, base, upper_case)
 		   always be very small.  It might be faster just to
 		   subtract in a tight loop.  */
 
-#  if UDIV_TIME > 2 * UMUL_TIME
+#   if UDIV_TIME > 2 * UMUL_TIME
 		mp_limb_t x, xh, xl;
 
 		if (big_normalization_steps == 0)
@@ -346,7 +365,7 @@ _itoa (value, buflim, base, upper_case)
 		udiv_qrnnd_preinv (t[0], x, xh, xl, big_base_norm,
 				   brec->big.base_ninv);
 		t[1] = x >> big_normalization_steps;
-#  elif UDIV_NEEDS_NORMALIZATION
+#   elif UDIV_NEEDS_NORMALIZATION
 		mp_limb_t x, xh, xl;
 
 		if (big_normalization_steps == 0)
@@ -368,17 +387,17 @@ _itoa (value, buflim, base, upper_case)
 		xl = x1lo << big_normalization_steps;
 		udiv_qrnnd (t[0], x, xh, xl, big_base_norm);
 		t[1] = x >> big_normalization_steps;
-#  else
+#   else
 		udiv_qrnnd (x1hi, r, 0, (mp_limb_t) (value >> 32),
 			    brec->big.base);
 		udiv_qrnnd (x1lo, t[2], r, (mp_limb_t) value, brec->big.base);
 		udiv_qrnnd (t[0], t[1], x1hi, x1lo, brec->big.base);
-#  endif
+#   endif
 		n = 3;
 	      }
 	    else
 	      {
-#  if UDIV_TIME > 2 * UMUL_TIME
+#   if UDIV_TIME > 2 * UMUL_TIME
 		mp_limb_t x;
 
 		value <<= brec->big.normalization_steps;
@@ -386,17 +405,17 @@ _itoa (value, buflim, base, upper_case)
 				   (mp_limb_t) value, big_base_norm,
 				   brec->big.base_ninv);
 		t[1] = x >> brec->big.normalization_steps;
-#  elif UDIV_NEEDS_NORMALIZATION
+#   elif UDIV_NEEDS_NORMALIZATION
 		mp_limb_t x;
 
 		value <<= big_normalization_steps;
 		udiv_qrnnd (t[0], x, (mp_limb_t) (value >> 32),
 			    (mp_limb_t) value, big_base_norm);
 		t[1] = x >> big_normalization_steps;
-#  else
+#   else
 		udiv_qrnnd (t[0], t[1], (mp_limb_t) (value >> 32),
 			    (mp_limb_t) value, brec->big.base);
-#  endif
+#   endif
 		n = 2;
 	      }
 	  }
@@ -412,7 +431,7 @@ _itoa (value, buflim, base, upper_case)
 	    mp_limb_t ti = t[--n];
 	    int ndig_for_this_limb = 0;
 
-#  if UDIV_TIME > 2 * UMUL_TIME
+#   if UDIV_TIME > 2 * UMUL_TIME
 	    mp_limb_t base_multiplier = brec->base_multiplier;
 	    if (brec->flag)
 	      while (ti != 0)
@@ -438,7 +457,7 @@ _itoa (value, buflim, base, upper_case)
 		  ti = quo;
 		  ++ndig_for_this_limb;
 		}
-#  else
+#   else
 	    while (ti != 0)
 	      {
 		mp_limb_t quo, rem;
@@ -449,7 +468,7 @@ _itoa (value, buflim, base, upper_case)
 		ti = quo;
 		++ndig_for_this_limb;
 	      }
-#  endif
+#   endif
 	    /* If this wasn't the most significant word, pad with zeros.  */
 	    if (n != 0)
 	      while (ndig_for_this_limb < brec->big.ndigits)
@@ -459,17 +478,20 @@ _itoa (value, buflim, base, upper_case)
 		}
 	  }
 	while (n != 0);
-# endif
+#  endif
 	if (buflim == bufend)
 	  *--buflim = '0';
       }
       break;
     }
+# endif /* PREFER_LONG_LONG */
 
   return buflim;
 }
 #endif
 
+#undef SPECIAL
+
 char *
 _fitoa_word (unsigned long value, char *buf, unsigned int base, int upper_case)
 {
diff --git a/stdio-common/_itowa.c b/stdio-common/_itowa.c
index 09a961d..689798f 100644
--- a/stdio-common/_itowa.c
+++ b/stdio-common/_itowa.c
@@ -97,11 +97,32 @@ _itowa (value, buflim, base, upper_case)
   const wchar_t *digits = (upper_case
 			   ? _itowa_upper_digits : _itowa_lower_digits);
   wchar_t *bp = buflim;
+
+# ifdef PREFER_LONG_LONG
+  switch (base)
+    {
+#  define SPECIAL(Base)							      \
+    case Base:								      \
+      do								      \
+	*--bp = digits[value % Base];					      \
+      while ((value /= Base) != 0);					      \
+      break
+
+      SPECIAL (10);
+      SPECIAL (16);
+      SPECIAL (8);
+    default:
+      do
+	*--bp = digits[value % base];
+      while ((value /= base) != 0);
+    }
+#  undef SPECIAL
+# else
   const struct base_table_t *brec = &_itoa_base_table[base - 2];
 
   switch (base)
     {
-# define RUN_2N(BITS) \
+#  define RUN_2N(BITS) \
       do								      \
         {								      \
 	  /* `unsigned long long int' always has 64 bits.  */		      \
@@ -155,7 +176,7 @@ _itowa (value, buflim, base, upper_case)
 
     default:
       {
-# if BITS_PER_MP_LIMB == 64
+#  if BITS_PER_MP_LIMB == 64
 	mp_limb_t base_multiplier = brec->base_multiplier;
 	if (brec->flag)
 	  while (value != 0)
@@ -179,8 +200,8 @@ _itowa (value, buflim, base, upper_case)
 	      *--bp = digits[rem];
 	      value = quo;
 	    }
-# endif
-# if BITS_PER_MP_LIMB == 32
+#  endif
+#  if BITS_PER_MP_LIMB == 32
 	mp_limb_t t[3];
 	int n;
 
@@ -188,11 +209,11 @@ _itowa (value, buflim, base, upper_case)
 	   Optimize for frequent cases of 32 bit numbers.  */
 	if ((mp_limb_t) (value >> 32) >= 1)
 	  {
-# if UDIV_TIME > 2 * UMUL_TIME || UDIV_NEEDS_NORMALIZATION
+#  if UDIV_TIME > 2 * UMUL_TIME || UDIV_NEEDS_NORMALIZATION
 	    int big_normalization_steps = brec->big.normalization_steps;
 	    mp_limb_t big_base_norm
 	      = brec->big.base << big_normalization_steps;
-# endif
+#  endif
 	    if ((mp_limb_t) (value >> 32) >= brec->big.base)
 	      {
 		mp_limb_t x1hi, x1lo, r;
@@ -201,7 +222,7 @@ _itowa (value, buflim, base, upper_case)
 		   always be very small.  It might be faster just to
 		   subtract in a tight loop.  */
 
-# if UDIV_TIME > 2 * UMUL_TIME
+#  if UDIV_TIME > 2 * UMUL_TIME
 		mp_limb_t x, xh, xl;
 
 		if (big_normalization_steps == 0)
@@ -226,7 +247,7 @@ _itowa (value, buflim, base, upper_case)
 		udiv_qrnnd_preinv (t[0], x, xh, xl, big_base_norm,
 				   brec->big.base_ninv);
 		t[1] = x >> big_normalization_steps;
-# elif UDIV_NEEDS_NORMALIZATION
+#  elif UDIV_NEEDS_NORMALIZATION
 		mp_limb_t x, xh, xl;
 
 		if (big_normalization_steps == 0)
@@ -248,17 +269,17 @@ _itowa (value, buflim, base, upper_case)
 		xl = x1lo << big_normalization_steps;
 		udiv_qrnnd (t[0], x, xh, xl, big_base_norm);
 		t[1] = x >> big_normalization_steps;
-# else
+#  else
 		udiv_qrnnd (x1hi, r, 0, (mp_limb_t) (value >> 32),
 			    brec->big.base);
 		udiv_qrnnd (x1lo, t[2], r, (mp_limb_t) value, brec->big.base);
 		udiv_qrnnd (t[0], t[1], x1hi, x1lo, brec->big.base);
-# endif
+#  endif
 		n = 3;
 	      }
 	    else
 	      {
-# if UDIV_TIME > 2 * UMUL_TIME
+#  if UDIV_TIME > 2 * UMUL_TIME
 		mp_limb_t x;
 
 		value <<= brec->big.normalization_steps;
@@ -266,17 +287,17 @@ _itowa (value, buflim, base, upper_case)
 				   (mp_limb_t) value, big_base_norm,
 				   brec->big.base_ninv);
 		t[1] = x >> brec->big.normalization_steps;
-# elif UDIV_NEEDS_NORMALIZATION
+#  elif UDIV_NEEDS_NORMALIZATION
 		mp_limb_t x;
 
 		value <<= big_normalization_steps;
 		udiv_qrnnd (t[0], x, (mp_limb_t) (value >> 32),
 			    (mp_limb_t) value, big_base_norm);
 		t[1] = x >> big_normalization_steps;
-# else
+#  else
 		udiv_qrnnd (t[0], t[1], (mp_limb_t) (value >> 32),
 			    (mp_limb_t) value, brec->big.base);
-# endif
+#  endif
 		n = 2;
 	      }
 	  }
@@ -292,7 +313,7 @@ _itowa (value, buflim, base, upper_case)
 	    mp_limb_t ti = t[--n];
 	    int ndig_for_this_limb = 0;
 
-# if UDIV_TIME > 2 * UMUL_TIME
+#  if UDIV_TIME > 2 * UMUL_TIME
 	    mp_limb_t base_multiplier = brec->base_multiplier;
 	    if (brec->flag)
 	      while (ti != 0)
@@ -318,7 +339,7 @@ _itowa (value, buflim, base, upper_case)
 		  ti = quo;
 		  ++ndig_for_this_limb;
 		}
-# else
+#  else
 	    while (ti != 0)
 	      {
 		mp_limb_t quo, rem;
@@ -329,7 +350,7 @@ _itowa (value, buflim, base, upper_case)
 		ti = quo;
 		++ndig_for_this_limb;
 	      }
-# endif
+#  endif
 	    /* If this wasn't the most significant word, pad with zeros.  */
 	    if (n != 0)
 	      while (ndig_for_this_limb < brec->big.ndigits)
@@ -339,10 +360,11 @@ _itowa (value, buflim, base, upper_case)
 		}
 	  }
 	while (n != 0);
-# endif
+#  endif
       }
       break;
     }
+# endif /* PREFER_LONG_LONG */
 
   return bp;
 }
diff --git a/stdlib/longlong.h b/stdlib/longlong.h
index 60b35a3..f4ef222 100644
--- a/stdlib/longlong.h
+++ b/stdlib/longlong.h
@@ -431,8 +431,8 @@ UDItype __umulsidi3 (USItype, USItype);
 	   : "0" ((UDItype) (n0)),					\
 	     "1" ((UDItype) (n1)),					\
 	     "rm" ((UDItype) (dv)))
-#define count_leading_zeros(count, x)	((count) = __builtin_clzl (x))
-#define count_trailing_zeros(count, x)	((count) = __builtin_ctzl (x))
+#define count_leading_zeros(count, x)	((count) = __builtin_clzll (x))
+#define count_trailing_zeros(count, x)	((count) = __builtin_ctzll (x))
 #define UMUL_TIME 40
 #define UDIV_TIME 40
 #endif /* x86_64 */
diff --git a/sysdeps/generic/ldconfig.h b/sysdeps/generic/ldconfig.h
index fadd5ec..57ead17 100644
--- a/sysdeps/generic/ldconfig.h
+++ b/sysdeps/generic/ldconfig.h
@@ -34,6 +34,7 @@
 #define FLAG_POWERPC_LIB64	0x0500
 #define FLAG_MIPS64_LIBN32	0x0600
 #define FLAG_MIPS64_LIBN64	0x0700
+#define FLAG_X8664_LIBX32	0x0800
 
 /* Name of auxiliary cache.  */
 #define _PATH_LDCONFIG_AUX_CACHE "/var/cache/ldconfig/aux-cache"
diff --git a/sysdeps/generic/ldsodefs.h b/sysdeps/generic/ldsodefs.h
index b24bff3..ef3cd11 100644
--- a/sysdeps/generic/ldsodefs.h
+++ b/sysdeps/generic/ldsodefs.h
@@ -230,6 +230,10 @@ struct audit_ifaces
 				       uintptr_t *, struct La_x86_64_regs *,
 				       unsigned int *, const char *name,
 				       long int *framesizep);
+    Elf32_Addr (*x32_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *,
+				    uintptr_t *, struct La_x86_64_regs *,
+				    unsigned int *, const char *name,
+				    long int *framesizep);
     Elf32_Addr (*ppc32_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *,
 				      uintptr_t *, struct La_ppc32_regs *,
 				      unsigned int *, const char *name,
@@ -282,6 +286,11 @@ struct audit_ifaces
 					const struct La_x86_64_regs *,
 					struct La_x86_64_retval *,
 					const char *);
+    unsigned int (*x32_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *,
+				     uintptr_t *,
+				     const struct La_x86_64_regs *,
+				     struct La_x86_64_retval *,
+				     const char *);
     unsigned int (*ppc32_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *,
 				       uintptr_t *,
 				       const struct La_ppc32_regs *,
diff --git a/sysdeps/i386/bits/byteswap.h b/sysdeps/i386/bits/byteswap.h
index ddfb785..d4fb6bd 100644
--- a/sysdeps/i386/bits/byteswap.h
+++ b/sysdeps/i386/bits/byteswap.h
@@ -25,6 +25,8 @@
 #ifndef _BITS_BYTESWAP_H
 #define _BITS_BYTESWAP_H 1
 
+#include <features.h>
+
 /* Swap bytes in 16 bit value.  */
 #define __bswap_constant_16(x) \
      ((unsigned short int) ((((x) >> 8) & 0xff) | (((x) & 0xff) << 8)))
@@ -62,42 +64,8 @@ __bswap_16 (unsigned short int __bsx)
      ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
       (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
 
-#ifdef __GNUC__
-# if __GNUC__ >= 2
-/* To swap the bytes in a word the i486 processors and up provide the
-   `bswap' opcode.  On i386 we have to use three instructions.  */
-#  if !defined __i486__ && !defined __pentium__ && !defined __pentiumpro__ \
-      && !defined __pentium4__ && !defined __k8__ && !defined __athlon__ \
-      && !defined __k6__ && !defined __nocona__ && !defined __core2__ \
-      && !defined __geode__ && !defined __amdfam10__
-#   define __bswap_32(x)						      \
-     (__extension__							      \
-      ({ register unsigned int __v, __x = (x);				      \
-	 if (__builtin_constant_p (__x))				      \
-	   __v = __bswap_constant_32 (__x);				      \
-	 else								      \
-	   __asm__ ("rorw $8, %w0;"					      \
-		    "rorl $16, %0;"					      \
-		    "rorw $8, %w0"					      \
-		    : "=r" (__v)					      \
-		    : "0" (__x)						      \
-		    : "cc");						      \
-	 __v; }))
-#  else
-#   define __bswap_32(x) \
-     (__extension__							      \
-      ({ register unsigned int __v, __x = (x);				      \
-	 if (__builtin_constant_p (__x))				      \
-	   __v = __bswap_constant_32 (__x);				      \
-	 else								      \
-	   __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
-	 __v; }))
-#  endif
-# else
-#  define __bswap_32(x) \
-     (__extension__							      \
-      ({ register unsigned int __x = (x); __bswap_constant_32 (__x); }))
-# endif
+#if __GNUC_PREREQ (4,2)
+# define __bswap_32(x)  __builtin_bswap32 (x)
 #else
 static __inline unsigned int
 __bswap_32 (unsigned int __bsx)
@@ -109,7 +77,10 @@ __bswap_32 (unsigned int __bsx)
 
 #if defined __GNUC__ && __GNUC__ >= 2
 /* Swap bytes in 64 bit value.  */
-# define __bswap_constant_64(x) \
+# if __GNUC_PREREQ (4,2)
+#  define __bswap_64(x)  __builtin_bswap64 (x)
+# else
+#  define __bswap_constant_64(x) \
      (__extension__ ((((x) & 0xff00000000000000ull) >> 56)		      \
 		     | (((x) & 0x00ff000000000000ull) >> 40)		      \
 		     | (((x) & 0x0000ff0000000000ull) >> 24)		      \
@@ -119,7 +90,7 @@ __bswap_32 (unsigned int __bsx)
 		     | (((x) & 0x000000000000ff00ull) << 40)		      \
 		     | (((x) & 0x00000000000000ffull) << 56)))
 
-# define __bswap_64(x) \
+#  define __bswap_64(x) \
      (__extension__							      \
       ({ union { __extension__ unsigned long long int __ll;		      \
 		 unsigned long int __l[2]; } __w, __r;			      \
@@ -132,6 +103,7 @@ __bswap_32 (unsigned int __bsx)
 	     __r.__l[1] = __bswap_32 (__w.__l[0]);			      \
 	   }								      \
 	 __r.__ll; }))
+# endif
 #endif
 
 #endif /* _BITS_BYTESWAP_H */
diff --git a/sysdeps/ieee754/dbl-64/wordsize-64/s_llround.c b/sysdeps/ieee754/dbl-64/wordsize-64/s_llround.c
index f7c9ea5..2fbbd64 100644
--- a/sysdeps/ieee754/dbl-64/wordsize-64/s_llround.c
+++ b/sysdeps/ieee754/dbl-64/wordsize-64/s_llround.c
@@ -1 +1,80 @@
-/* The code is the same as lround.  Use an alias, see l_round.c.  */
+/* Round double value to long long int.
+   Copyright (C) 1997, 2004, 2009, 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define lround __hidden_lround
+#define __lround __hidden___lround
+
+#include <math.h>
+
+#include "math_private.h"
+
+
+long long int
+__llround (double x)
+{
+  int32_t j0;
+  int64_t i0;
+  long long int result;
+  int sign;
+
+  EXTRACT_WORDS64 (i0, x);
+  j0 = ((i0 >> 52) & 0x7ff) - 0x3ff;
+  sign = i0 < 0 ? -1 : 1;
+  i0 &= UINT64_C(0xfffffffffffff);
+  i0 |= UINT64_C(0x10000000000000);
+
+  if (j0 < (int32_t) (8 * sizeof (long long int)) - 1)
+    {
+      if (j0 < 0)
+	return j0 < -1 ? 0 : sign;
+      else if (j0 >= 52)
+	result = i0 << (j0 - 52);
+      else
+	{
+	  i0 += UINT64_C(0x8000000000000) >> j0;
+
+	  result = i0 >> (52 - j0);
+	}
+    }
+  else
+    {
+      /* The number is too large.  It is left implementation defined
+	 what happens.  */
+      return (long long int) x;
+    }
+
+  return sign * result;
+}
+
+weak_alias (__llround, llround)
+#ifdef NO_LONG_DOUBLE
+strong_alias (__llround, __lroundl)
+weak_alias (__llround, lroundl)
+#endif
+
+/* long has the same width as long long on 64-bit machines.  */
+#undef lround
+#undef __lround
+strong_alias (__llround, __lround)
+weak_alias (__llround, lround)
+#ifdef NO_LONG_DOUBLE
+strong_alias (__llround, __llroundl)
+weak_alias (__llround, llroundl)
+#endif
diff --git a/sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c b/sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c
index 30ea5db..16db260 100644
--- a/sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c
+++ b/sysdeps/ieee754/dbl-64/wordsize-64/s_lround.c
@@ -1,80 +1 @@
-/* Round double value to long int.
-   Copyright (C) 1997, 2004, 2009 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1997.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-#define llround __hidden_llround
-#define __llround __hidden___llround
-
-#include <math.h>
-
-#include "math_private.h"
-
-
-long int
-__lround (double x)
-{
-  int32_t j0;
-  int64_t i0;
-  long int result;
-  int sign;
-
-  EXTRACT_WORDS64 (i0, x);
-  j0 = ((i0 >> 52) & 0x7ff) - 0x3ff;
-  sign = i0 < 0 ? -1 : 1;
-  i0 &= UINT64_C(0xfffffffffffff);
-  i0 |= UINT64_C(0x10000000000000);
-
-  if (j0 < (int32_t) (8 * sizeof (long int)) - 1)
-    {
-      if (j0 < 0)
-	return j0 < -1 ? 0 : sign;
-      else if (j0 >= 52)
-	result = i0 << (j0 - 52);
-      else
-	{
-	  i0 += UINT64_C(0x8000000000000) >> j0;
-
-	  result = i0 >> (52 - j0);
-	}
-    }
-  else
-    {
-      /* The number is too large.  It is left implementation defined
-	 what happens.  */
-      return (long int) x;
-    }
-
-  return sign * result;
-}
-
-weak_alias (__lround, lround)
-#ifdef NO_LONG_DOUBLE
-strong_alias (__lround, __lroundl)
-weak_alias (__lround, lroundl)
-#endif
-
-/* long long has the same width as long on 64-bit machines.  */
-#undef llround
-#undef __llround
-strong_alias (__lround, __llround)
-weak_alias (__lround, llround)
-#ifdef NO_LONG_DOUBLE
-strong_alias (__lround, __llroundl)
-weak_alias (__lround, llroundl)
-#endif
+/* The code is the same as llround.  Use an alias, see ll_round.c.  */
diff --git a/sysdeps/mach/hurd/bits/typesizes.h b/sysdeps/mach/hurd/bits/typesizes.h
index 4322617..8db5866 100644
--- a/sysdeps/mach/hurd/bits/typesizes.h
+++ b/sysdeps/mach/hurd/bits/typesizes.h
@@ -58,6 +58,7 @@
 #define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
 #define __FSID_T_TYPE		__UQUAD_TYPE
 #define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
 
 /* Number of descriptors that can fit in an `fd_set'.  */
 #define	__FD_SETSIZE		256
diff --git a/sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h b/sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h
index c0e267f..430ca75 100644
--- a/sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h
+++ b/sysdeps/unix/bsd/bsd4.4/freebsd/bits/typesizes.h
@@ -58,6 +58,9 @@
 #define __BLKSIZE_T_TYPE	__U32_TYPE
 #define __FSID_T_TYPE		struct { int __val[2]; }
 #define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
 
 /* Number of descriptors that can fit in an `fd_set'.  */
 #define	__FD_SETSIZE		1024
diff --git a/sysdeps/unix/sysv/linux/configure b/sysdeps/unix/sysv/linux/configure
index a8ebcf2..f28c835 100644
--- a/sysdeps/unix/sysv/linux/configure
+++ b/sysdeps/unix/sysv/linux/configure
@@ -332,6 +332,9 @@ case "$machine" in
     libc_cv_gcc_unwind_find_fde=yes
     arch_minimum_kernel=2.0.10
     ;;
+  x86_64/x32*)
+    arch_minimum_kernel=2.6.35
+    ;;
   x86_64*)
     arch_minimum_kernel=2.4.0
     ;;
@@ -412,7 +415,7 @@ case "$prefix" in
   # and libc_cv_localedir.
   test -n "$libc_cv_slibdir" || \
   case $machine in
-  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64)
+  sparc/sparc64 | x86_64/64 | powerpc/powerpc64 | s390/s390-64)
     libc_cv_slibdir="/lib64"
     if test "$libdir" = '${exec_prefix}/lib'; then
       libdir='${exec_prefix}/lib64';
diff --git a/sysdeps/unix/sysv/linux/configure.in b/sysdeps/unix/sysv/linux/configure.in
index 3f1daab..44ad90d 100644
--- a/sysdeps/unix/sysv/linux/configure.in
+++ b/sysdeps/unix/sysv/linux/configure.in
@@ -89,6 +89,9 @@ case "$machine" in
     libc_cv_gcc_unwind_find_fde=yes
     arch_minimum_kernel=2.0.10
     ;;
+  x86_64/x32*)
+    arch_minimum_kernel=2.6.35
+    ;;
   x86_64*)
     arch_minimum_kernel=2.4.0
     ;;
@@ -151,7 +154,7 @@ case "$prefix" in
   # and libc_cv_localedir.
   test -n "$libc_cv_slibdir" || \
   case $machine in
-  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64)
+  sparc/sparc64 | x86_64/64 | powerpc/powerpc64 | s390/s390-64)
     libc_cv_slibdir="/lib64"
     if test "$libdir" = '${exec_prefix}/lib'; then
       libdir='${exec_prefix}/lib64';
diff --git a/sysdeps/unix/sysv/linux/i386/readelflib.c b/sysdeps/unix/sysv/linux/i386/readelflib.c
index a6374e6..bac83bb 100644
--- a/sysdeps/unix/sysv/linux/i386/readelflib.c
+++ b/sysdeps/unix/sysv/linux/i386/readelflib.c
@@ -33,40 +33,52 @@ process_elf_file (const char *file_name, const char *lib, int *flag,
 		  size_t file_length)
 {
   ElfW(Ehdr) *elf_header = (ElfW(Ehdr) *) file_contents;
-  int ret;
+  int ret, file_flag = 0;
 
-  if (elf_header->e_ident [EI_CLASS] == ELFCLASS32)
-    return process_elf32_file (file_name, lib, flag, osversion, soname,
-			       file_contents, file_length);
-  else
+  switch (elf_header->e_machine)
     {
-      switch (elf_header->e_machine)
+    case EM_X86_64:
+      if (elf_header->e_ident[EI_CLASS] == ELFCLASS64)
+	/* X86-64 64bit libraries are always libc.so.6+.  */
+	file_flag = FLAG_X8664_LIB64|FLAG_ELF_LIBC6;
+      else
+	/* X32 libraries are always libc.so.6+.  */
+	file_flag = FLAG_X8664_LIBX32|FLAG_ELF_LIBC6;
+      break;
+#ifndef SKIP_EM_IA_64
+    case EM_IA_64:
+      if (elf_header->e_ident[EI_CLASS] == ELFCLASS64)
 	{
-	case EM_IA_64:
-	case EM_X86_64:
+	  /* IA64 64bit libraries are always libc.so.6+.  */
+	  file_flag = FLAG_IA64_LIB64|FLAG_ELF_LIBC6;
 	  break;
-	default:
-	  error (0, 0, _("%s is for unknown machine %d.\n"),
-		 file_name, elf_header->e_machine);
-	  return 1;
 	}
+      goto failed;
+#endif
+    case EM_386:
+      if (elf_header->e_ident[EI_CLASS] == ELFCLASS32)
+	break;
+      /* Fall through.  */
+    default:
+#ifndef SKIP_EM_IA_64
+failed:
+#endif
+      error (0, 0, _("%s is for unknown machine %d.\n"),
+	     file_name, elf_header->e_machine);
+      return 1;
+    }
 
-      ret = process_elf64_file (file_name, lib, flag, osversion, soname,
-				file_contents, file_length);
-      /* IA64/X86-64 64bit libraries are always libc.so.6+.  */
-      if (!ret)
-	switch (elf_header->e_machine)
-	  {
-	  case EM_IA_64:
-	    *flag = FLAG_IA64_LIB64|FLAG_ELF_LIBC6;
-	    break;
-	  case EM_X86_64:
-	    *flag = FLAG_X8664_LIB64|FLAG_ELF_LIBC6;
-	    break;
-	  }
+  if (elf_header->e_ident[EI_CLASS] == ELFCLASS32)
+    ret = process_elf32_file (file_name, lib, flag, osversion, soname,
+			      file_contents, file_length);
+  else
+    ret = process_elf64_file (file_name, lib, flag, osversion, soname,
+			      file_contents, file_length);
 
-      return ret;
-    }
+  if (!ret && file_flag)
+    *flag = file_flag;
+
+  return ret;
 }
 
 #undef __ELF_NATIVE_CLASS
diff --git a/sysdeps/unix/sysv/linux/s390/bits/typesizes.h b/sysdeps/unix/sysv/linux/s390/bits/typesizes.h
index 2d9cd87..c016b7d 100644
--- a/sysdeps/unix/sysv/linux/s390/bits/typesizes.h
+++ b/sysdeps/unix/sysv/linux/s390/bits/typesizes.h
@@ -64,6 +64,9 @@
 /* size_t is unsigned long int on s390 -m31.  */
 #define __SSIZE_T_TYPE		__SLONGWORD_TYPE
 #endif
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
 
 /* Number of descriptors that can fit in an `fd_set'.  */
 #define	__FD_SETSIZE		1024
diff --git a/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h b/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h
index b0dd1bd..50f4a8b 100644
--- a/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h
+++ b/sysdeps/unix/sysv/linux/sparc/bits/typesizes.h
@@ -58,6 +58,9 @@
 #define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
 #define __FSID_T_TYPE		struct { int __val[2]; }
 #define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
 
 /* Number of descriptors that can fit in an `fd_set'.  */
 #define	__FD_SETSIZE		1024
diff --git a/sysdeps/unix/sysv/linux/x86_64/64/Implies b/sysdeps/unix/sysv/linux/x86_64/64/Implies
new file mode 100644
index 0000000..8d91c80
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/64/Implies
@@ -0,0 +1 @@
+unix/sysv/linux/wordsize-64
diff --git a/sysdeps/unix/sysv/linux/x86_64/Implies b/sysdeps/unix/sysv/linux/x86_64/Implies
deleted file mode 100644
index 8d91c80..0000000
--- a/sysdeps/unix/sysv/linux/x86_64/Implies
+++ /dev/null
@@ -1 +0,0 @@
-unix/sysv/linux/wordsize-64
diff --git a/sysdeps/unix/sysv/linux/x86_64/Makefile b/sysdeps/unix/sysv/linux/x86_64/Makefile
index 9c9e615..fcf835d 100644
--- a/sysdeps/unix/sysv/linux/x86_64/Makefile
+++ b/sysdeps/unix/sysv/linux/x86_64/Makefile
@@ -1,8 +1,8 @@
 syscall-list-variants := 32bit 64bit
 syscall-list-32bit-options := -D__i386__ -U__x86_64__
-syscall-list-32bit-condition := __WORDSIZE == 32
-syscall-list-64bit-options := -U__i386__ -D__x86_64__
-syscall-list-64bit-condition := __WORDSIZE == 64
+syscall-list-32bit-condition := !defined __x86_64__
+syscall-list-64bit-options := -U__i386__ -D__x86_64__ -D__LP64__
+syscall-list-64bit-condition := defined __x86_64__
 
 ifeq ($(subdir),misc)
 sysdep_routines += ioperm iopl
@@ -17,6 +17,10 @@ ifeq ($(subdir),csu)
 gen-as-const-headers += ucontext_i.sym
 endif
 
+ifeq ($(subdir),misc)
+gen-as-const-headers += sigaltstack.sym
+endif
+
 ifeq ($(subdir),elf)
 sysdep_routines += dl-vdso
 endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S b/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S
index d8cbe06..17d824b 100644
--- a/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S
+++ b/sysdeps/unix/sysv/linux/x86_64/____longjmp_chk.S
@@ -20,6 +20,8 @@
 #include <jmpbuf-offsets.h>
 #include <asm-syntax.h>
 
+#include "sigaltstack.h"
+
 	.section .rodata.str1.1,"aMS",@progbits,1
 	.type	longjmp_msg,@object
 longjmp_msg:
@@ -30,18 +32,18 @@ longjmp_msg:
 //#define __longjmp ____longjmp_chk
 
 #ifdef PIC
-# define CALL_FAIL	subq	$8, %rsp;				      \
+# define CALL_FAIL	sub	$8, %RSP_LP;				      \
 			cfi_remember_state;				      \
 			cfi_def_cfa_offset(16);				      \
-			leaq	longjmp_msg(%rip), %rdi;		      \
+			lea	longjmp_msg(%rip), %RDI_LP;		      \
 			call	HIDDEN_JUMPTARGET(__fortify_fail);	      \
 			nop;						      \
 			cfi_restore_state
 #else
-# define CALL_FAIL	subq	$8, %rsp;				      \
+# define CALL_FAIL	sub	$8, %RSP_LP;				      \
 			cfi_remember_state;				      \
 			cfi_def_cfa_offset(16);				      \
-			movq	$longjmp_msg, %rdi;			      \
+			mov	$longjmp_msg, %RDI_LP;			      \
 			call	HIDDEN_JUMPTARGET(__fortify_fail);	      \
 			nop;						      \
 			cfi_restore_state
@@ -53,16 +55,15 @@ longjmp_msg:
 	.text
 ENTRY(____longjmp_chk)
 	/* Restore registers.  */
-	movq	(JB_RSP*8)(%rdi), %r8
+	mov	(JB_RSP*8)(%rdi), %R8_LP
 	movq	(JB_RBP*8)(%rdi), %r9
-	movq	(JB_PC*8)(%rdi), %rdx
+	mov	(JB_PC*8)(%rdi), %RDX_LP
 #ifdef PTR_DEMANGLE
-	PTR_DEMANGLE (%r8)
-	PTR_DEMANGLE (%r9)
-	PTR_DEMANGLE (%rdx)
+	PTR_DEMANGLE (%R8_LP)
+	PTR_DEMANGLE (%RDX_LP)
 #endif
 
-	cmpq	%r8, %rsp
+	cmp	%R8_LP, %RSP_LP
 	jbe	.Lok
 
 	/* Save function parameters.  */
@@ -72,19 +73,19 @@ ENTRY(____longjmp_chk)
 	cfi_register (%rsi, %rbx)
 
 	xorl	%edi, %edi
-	leaq	-24(%rsp), %rsi
+	lea	-sizeSS(%rsp), %RSI_LP
 	movl	$__NR_sigaltstack, %eax
 	syscall
 	/* Without working sigaltstack we cannot perform the test.  */
 	testl	%eax, %eax
 	jne	.Lok2
-	testl	$1, -16(%rsp)
+	testl	$1, (-sizeSS + oSS_FLAGS)(%rsp)
 	jz	.Lfail
 
-	movq	-24(%rsp), %rax
-	addq	-8(%rsp), %rax
-	subq	%r8, %rax
-	cmpq	-8(%rsp), %rax
+	mov	(-sizeSS + oSS_SP)(%rsp), %RAX_LP
+	add	(-sizeSS + oSS_SIZE)(%rsp), %RAX_LP
+	sub	%R8_LP, %RAX_LP
+	cmp	(-sizeSS + oSS_SIZE)(%rsp), %RAX_LP
 	jae	.Lok2
 
 .Lfail:	CALL_FAIL
@@ -111,7 +112,7 @@ ENTRY(____longjmp_chk)
 	movq	(JB_R15*8)(%rdi), %r15
 	/* Set return value for setjmp.  */
 	movl	%esi, %eax
-	movq	%r8,%rsp
+	mov	%R8_LP, %RSP_LP
 	movq	%r9,%rbp
 	jmpq	*%rdx
 END (____longjmp_chk)
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/a.out.h b/sysdeps/unix/sysv/linux/x86_64/bits/a.out.h
index 228a8d4..0e4a7c9 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/a.out.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/a.out.h
@@ -2,9 +2,7 @@
 # error "Never use <bits/a.out.h> directly; include <a.out.h> instead."
 #endif
 
-#include <bits/wordsize.h>
-
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 
 /* Signal to users of this header that this architecture really doesn't
    support a.out binary format.  */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h b/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h
index 7f18562..0d00c69 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/fcntl.h
@@ -23,7 +23,6 @@
 #endif
 
 #include <sys/types.h>
-#include <bits/wordsize.h>
 #ifdef __USE_GNU
 # include <bits/uio.h>
 #endif
@@ -66,7 +65,7 @@
 #endif
 
 #ifdef __USE_LARGEFILE64
-# if __WORDSIZE == 64
+# ifdef __x86_64__
 #  define O_LARGEFILE	0
 # else
 #  define O_LARGEFILE	0100000
@@ -79,7 +78,7 @@
 #define F_SETFD		2	/* Set file descriptor flags.  */
 #define F_GETFL		3	/* Get file status flags.  */
 #define F_SETFL		4	/* Set file status flags.  */
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 # define F_GETLK	5	/* Get record locking info.  */
 # define F_SETLK	6	/* Set record locking info (non-blocking).  */
 # define F_SETLKW	7	/* Set record locking info (blocking).	*/
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/ipc.h b/sysdeps/unix/sysv/linux/x86_64/bits/ipc.h
new file mode 100644
index 0000000..0736d43
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/ipc.h
@@ -0,0 +1,57 @@
+/* Copyright (C) 1995-1999, 2000, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Mode bits for `msgget', `semget', and `shmget'.  */
+#define IPC_CREAT	01000		/* Create key if key does not exist. */
+#define IPC_EXCL	02000		/* Fail if key exists.  */
+#define IPC_NOWAIT	04000		/* Return error on wait.  */
+
+/* Control commands for `msgctl', `semctl', and `shmctl'.  */
+#define IPC_RMID	0		/* Remove identifier.  */
+#define IPC_SET		1		/* Set `ipc_perm' options.  */
+#define IPC_STAT	2		/* Get `ipc_perm' options.  */
+#ifdef __USE_GNU
+# define IPC_INFO	3		/* See ipcs.  */
+#endif
+
+/* Special key values.  */
+#define IPC_PRIVATE	((__key_t) 0)	/* Private key.  */
+
+
+/* Data structure used to pass permission information to IPC operations.  */
+struct ipc_perm
+  {
+    __key_t __key;			/* Key.  */
+    __uid_t uid;			/* Owner's user ID.  */
+    __gid_t gid;			/* Owner's group ID.  */
+    __uid_t cuid;			/* Creator's user ID.  */
+    __gid_t cgid;			/* Creator's group ID.  */
+    unsigned short int mode;		/* Read/write permission.  */
+    unsigned short int __pad1;
+    unsigned short int __seq;		/* Sequence number.  */
+    unsigned short int __pad2;
+    __syscall_ulong_t __unused1;
+    __syscall_ulong_t __unused2;
+  };
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/ipctypes.h b/sysdeps/unix/sysv/linux/x86_64/bits/ipctypes.h
new file mode 100644
index 0000000..025bab5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/ipctypes.h
@@ -0,0 +1,34 @@
+/* bits/ipctypes.h -- Define some types used by SysV IPC/MSG/SHM.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipctypes.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#ifndef _BITS_IPCTYPES_H
+#define _BITS_IPCTYPES_H	1
+
+/* Used in `struct shmid_ds'.  */
+# ifdef __x86_64__
+typedef int __ipc_pid_t;
+# else
+typedef unsigned short int __ipc_pid_t;
+# endif
+
+#endif /* bits/ipctypes.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h b/sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h
new file mode 100644
index 0000000..1448a7a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/mqueue.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 2004, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MQUEUE_H
+# error "Never use <bits/mqueue.h> directly; include <mqueue.h> instead."
+#endif
+
+#include <sys/types.h>
+
+typedef int mqd_t;
+
+struct mq_attr
+{
+  __syscall_slong_t mq_flags;	/* Message queue flags.  */
+  __syscall_slong_t mq_maxmsg;	/* Maximum number of messages.  */
+  __syscall_slong_t mq_msgsize;	/* Maximum message size.  */
+  __syscall_slong_t mq_curmsgs;	/* Number of messages currently queued.  */
+  __syscall_slong_t __pad[4];
+};
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/msq.h b/sysdeps/unix/sysv/linux/x86_64/bits/msq.h
index 422218a..f6a99e5 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/msq.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/msq.h
@@ -1,4 +1,5 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2011
+   Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -21,7 +22,6 @@
 #endif
 
 #include <bits/types.h>
-#include <bits/wordsize.h>
 
 /* Define options for message queue functions.  */
 #define MSG_NOERROR	010000	/* no error if message is too big */
@@ -30,8 +30,8 @@
 #endif
 
 /* Types used in the structure definition.  */
-typedef unsigned long int msgqnum_t;
-typedef unsigned long int msglen_t;
+typedef __syscall_ulong_t msgqnum_t;
+typedef __syscall_ulong_t msglen_t;
 
 /* Structure of record for one message inside the kernel.
    The type `struct msg' is opaque.  */
@@ -39,24 +39,24 @@ struct msqid_ds
 {
   struct ipc_perm msg_perm;	/* structure describing operation permission */
   __time_t msg_stime;		/* time of last msgsnd command */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
   unsigned long int __unused1;
 #endif
   __time_t msg_rtime;		/* time of last msgrcv command */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
   unsigned long int __unused2;
 #endif
   __time_t msg_ctime;		/* time of last change */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
   unsigned long int __unused3;
 #endif
-  unsigned long int __msg_cbytes; /* current number of bytes on queue */
+  __syscall_ulong_t __msg_cbytes; /* current number of bytes on queue */
   msgqnum_t msg_qnum;		/* number of messages currently on queue */
   msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
   __pid_t msg_lspid;		/* pid of last msgsnd() */
   __pid_t msg_lrpid;		/* pid of last msgrcv() */
-  unsigned long int __unused4;
-  unsigned long int __unused5;
+  __syscall_ulong_t __unused4;
+  __syscall_ulong_t __unused5;
 };
 
 #ifdef __USE_MISC
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/resource.h b/sysdeps/unix/sysv/linux/x86_64/bits/resource.h
new file mode 100644
index 0000000..dea74be
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/resource.h
@@ -0,0 +1,310 @@
+/* Bit values & structures for resource limits.  Linux version.
+   Copyright (C) 1994, 1996-2000, 2004, 2005, 2008, 2009, 2010, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  __RLIMIT_RSS = 5,
+#define	RLIMIT_RSS __RLIMIT_RSS
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 7,
+  __RLIMIT_OFILE = RLIMIT_NOFILE, /* BSD name for same.  */
+#define RLIMIT_NOFILE RLIMIT_NOFILE
+#define RLIMIT_OFILE __RLIMIT_OFILE
+
+  /* Address space limit.  */
+  RLIMIT_AS = 9,
+#define RLIMIT_AS RLIMIT_AS
+
+  /* Number of processes.  */
+  __RLIMIT_NPROC = 6,
+#define RLIMIT_NPROC __RLIMIT_NPROC
+
+  /* Locked-in-memory address space.  */
+  __RLIMIT_MEMLOCK = 8,
+#define RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
+
+  /* Maximum number of file locks.  */
+  __RLIMIT_LOCKS = 10,
+#define RLIMIT_LOCKS __RLIMIT_LOCKS
+
+  /* Maximum number of pending signals.  */
+  __RLIMIT_SIGPENDING = 11,
+#define RLIMIT_SIGPENDING __RLIMIT_SIGPENDING
+
+  /* Maximum bytes in POSIX message queues.  */
+  __RLIMIT_MSGQUEUE = 12,
+#define RLIMIT_MSGQUEUE __RLIMIT_MSGQUEUE
+
+  /* Maximum nice priority allowed to raise to.
+     Nice levels 19 .. -20 correspond to 0 .. 39
+     values of this resource limit.  */
+  __RLIMIT_NICE = 13,
+#define RLIMIT_NICE __RLIMIT_NICE
+
+  /* Maximum realtime priority allowed for non-priviledged
+     processes.  */
+  __RLIMIT_RTPRIO = 14,
+#define RLIMIT_RTPRIO __RLIMIT_RTPRIO
+
+  /* Maximum CPU time in µs that a process scheduled under a real-time
+     scheduling policy may consume without making a blocking system
+     call before being forcibly descheduled.  */
+  __RLIMIT_RTTIME = 15,
+#define RLIMIT_RTTIME __RLIMIT_RTTIME
+
+  __RLIMIT_NLIMITS = 16,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#ifndef __USE_FILE_OFFSET64
+# define RLIM_INFINITY ((__rlim_t) -1)
+#else
+# define RLIM_INFINITY 0xffffffffffffffffuLL
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0xffffffffffffffffuLL
+#endif
+
+/* We can represent all limits.  */
+#define RLIM_SAVED_MAX	RLIM_INFINITY
+#define RLIM_SAVED_CUR	RLIM_INFINITY
+
+
+/* Type for resource quantity measurement.  */
+#ifndef __USE_FILE_OFFSET64
+typedef __rlim_t rlim_t;
+#else
+typedef __rlim64_t rlim_t;
+#endif
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+
+#ifdef __USE_GNU
+  ,
+  /* The calling thread.  */
+  RUSAGE_THREAD = 1
+# define RUSAGE_THREAD RUSAGE_THREAD
+  /* Name for the same functionality on Solaris.  */
+# define RUSAGE_LWP RUSAGE_THREAD
+#endif
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused1;
+#endif
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused2;
+#endif
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused3;
+#endif
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused4;
+#endif
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused5;
+#endif
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused6;
+#endif
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused7;
+#endif
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused8;
+#endif
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused9;
+#endif
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused10;
+#endif
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused11;
+#endif
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused12;
+#endif
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused13;
+#endif
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+#if defined __x86_64__ && __WORDSIZE == 32
+    long int __unused14;
+#endif
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
+
+
+__BEGIN_DECLS
+
+#ifdef __USE_GNU
+/* Modify and return resource limits of a process atomically.  */
+# ifndef __USE_FILE_OFFSET64
+extern int prlimit (__pid_t __pid, enum __rlimit_resource __resource,
+		    __const struct rlimit *__new_limit,
+		    struct rlimit *__old_limit) __THROW;
+# else
+#  ifdef __REDIRECT_NTH
+extern int __REDIRECT_NTH (prlimit, (__pid_t __pid,
+				     enum __rlimit_resource __resource,
+				     __const struct rlimit *__new_limit,
+				     struct rlimit *__old_limit), prlimit64);
+#  else
+#   define prlimit prlimit64
+#  endif
+# endif
+# ifdef __USE_LARGEFILE64
+extern int prlimit64 (__pid_t __pid, enum __rlimit_resource __resource,
+		      __const struct rlimit64 *__new_limit,
+		      struct rlimit64 *__old_limit) __THROW;
+# endif
+#endif
+
+__END_DECLS
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/sem.h b/sysdeps/unix/sysv/linux/x86_64/bits/sem.h
index e86c357..4169641 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/sem.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/sem.h
@@ -40,12 +40,12 @@ struct semid_ds
 {
   struct ipc_perm sem_perm;		/* operation permission struct */
   __time_t sem_otime;			/* last semop() time */
-  unsigned long int __unused1;
+  __syscall_ulong_t __unused1;
   __time_t sem_ctime;			/* last time changed by semctl() */
-  unsigned long int __unused2;
-  unsigned long int sem_nsems;		/* number of semaphores in set */
-  unsigned long int __unused3;
-  unsigned long int __unused4;
+  __syscall_ulong_t __unused2;
+  __syscall_ulong_t sem_nsems;		/* number of semaphores in set */
+  __syscall_ulong_t __unused3;
+  __syscall_ulong_t __unused4;
 };
 
 /* The user should define a union like the following to use it for arguments
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/shm.h b/sysdeps/unix/sysv/linux/x86_64/bits/shm.h
index 04f5cc5..ee51deb 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/shm.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/shm.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2004, 2009
+/* Copyright (C) 1995, 1996, 1997, 2000, 2002, 2004, 2009, 2011
    Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
@@ -45,7 +45,7 @@ extern int __getpagesize (void) __THROW __attribute__ ((__const__));
 
 
 /* Type to count number of attaches.  */
-typedef unsigned long int shmatt_t;
+typedef __syscall_ulong_t shmatt_t;
 
 /* Data structure describing a shared memory segment.  */
 struct shmid_ds
@@ -53,22 +53,22 @@ struct shmid_ds
     struct ipc_perm shm_perm;		/* operation permission struct */
     size_t shm_segsz;			/* size of segment in bytes */
     __time_t shm_atime;			/* time of last shmat() */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
     unsigned long int __unused1;
 #endif
     __time_t shm_dtime;			/* time of last shmdt() */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
     unsigned long int __unused2;
 #endif
     __time_t shm_ctime;			/* time of last change by shmctl() */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
     unsigned long int __unused3;
 #endif
     __pid_t shm_cpid;			/* pid of creator */
     __pid_t shm_lpid;			/* pid of last shmop */
     shmatt_t shm_nattch;		/* number of current attaches */
-    unsigned long int __unused4;
-    unsigned long int __unused5;
+    __syscall_ulong_t __unused4;
+    __syscall_ulong_t __unused5;
   };
 
 #ifdef __USE_MISC
@@ -85,25 +85,25 @@ struct shmid_ds
 
 struct	shminfo
   {
-    unsigned long int shmmax;
-    unsigned long int shmmin;
-    unsigned long int shmmni;
-    unsigned long int shmseg;
-    unsigned long int shmall;
-    unsigned long int __unused1;
-    unsigned long int __unused2;
-    unsigned long int __unused3;
-    unsigned long int __unused4;
+    __syscall_ulong_t shmmax;
+    __syscall_ulong_t shmmin;
+    __syscall_ulong_t shmmni;
+    __syscall_ulong_t shmseg;
+    __syscall_ulong_t shmall;
+    __syscall_ulong_t __unused1;
+    __syscall_ulong_t __unused2;
+    __syscall_ulong_t __unused3;
+    __syscall_ulong_t __unused4;
   };
 
 struct shm_info
   {
     int used_ids;
-    unsigned long int shm_tot;	/* total allocated shm */
-    unsigned long int shm_rss;	/* total resident shm */
-    unsigned long int shm_swp;	/* total swapped shm */
-    unsigned long int swap_attempts;
-    unsigned long int swap_successes;
+    __syscall_ulong_t shm_tot;	/* total allocated shm */
+    __syscall_ulong_t shm_rss;	/* total resident shm */
+    __syscall_ulong_t shm_swp;	/* total swapped shm */
+    __syscall_ulong_t swap_attempts;
+    __syscall_ulong_t swap_successes;
   };
 
 #endif /* __USE_MISC */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h b/sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h
index c0d5fe7..152a546 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/sigcontext.h
@@ -45,7 +45,7 @@ struct _xmmreg
 
 
 
-#if __WORDSIZE == 32
+#ifndef __x86_64__
 
 struct _fpstate
 {
@@ -104,7 +104,7 @@ struct sigcontext
   unsigned long cr2;
 };
 
-#else /* __WORDSIZE == 64 */
+#else /* __x86_64__ */
 
 struct _fpstate
 {
@@ -124,36 +124,39 @@ struct _fpstate
 
 struct sigcontext
 {
-  unsigned long r8;
-  unsigned long r9;
-  unsigned long r10;
-  unsigned long r11;
-  unsigned long r12;
-  unsigned long r13;
-  unsigned long r14;
-  unsigned long r15;
-  unsigned long rdi;
-  unsigned long rsi;
-  unsigned long rbp;
-  unsigned long rbx;
-  unsigned long rdx;
-  unsigned long rax;
-  unsigned long rcx;
-  unsigned long rsp;
-  unsigned long rip;
-  unsigned long eflags;
+  unsigned long long r8;
+  unsigned long long r9;
+  unsigned long long r10;
+  unsigned long long r11;
+  unsigned long long r12;
+  unsigned long long r13;
+  unsigned long long r14;
+  unsigned long long r15;
+  unsigned long long rdi;
+  unsigned long long rsi;
+  unsigned long long rbp;
+  unsigned long long rbx;
+  unsigned long long rdx;
+  unsigned long long rax;
+  unsigned long long rcx;
+  unsigned long long rsp;
+  unsigned long long rip;
+  unsigned long long eflags;
   unsigned short cs;
   unsigned short gs;
   unsigned short fs;
   unsigned short __pad0;
-  unsigned long err;
-  unsigned long trapno;
-  unsigned long oldmask;
-  unsigned long cr2;
+  unsigned long long err;
+  unsigned long long trapno;
+  unsigned long long oldmask;
+  unsigned long long cr2;
   struct _fpstate * fpstate;
-  unsigned long __reserved1 [8];
+# if __WORDSIZE == 32
+  unsigned int pad0;
+# endif
+  unsigned long long __reserved1 [8];
 };
 
-#endif /* __WORDSIZE == 64 */
+#endif /* __x86_64__ */
 
 #endif /* _BITS_SIGCONTEXT_H */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/siginfo.h b/sysdeps/unix/sysv/linux/x86_64/bits/siginfo.h
new file mode 100644
index 0000000..5db7139
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/siginfo.h
@@ -0,0 +1,325 @@
+/* siginfo_t, sigevent and constants.  Linux x86-64 version.
+   Copyright (C) 1997-2002, 2003, 2011, 2012
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _SIGNAL_H && !defined __need_siginfo_t \
+    && !defined __need_sigevent_t
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+#if (!defined __have_sigval_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t \
+	 || defined __need_sigevent_t))
+# define __have_sigval_t	1
+
+/* Type for data associated with a signal.  */
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+#endif
+
+#if (!defined __have_siginfo_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t))
+# define __have_siginfo_t	1
+
+# define __SI_MAX_SIZE     128
+# if __WORDSIZE == 64
+#  define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 4)
+# else
+#  define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 3)
+# endif
+
+# if defined __x86_64__ && __WORDSIZE == 32
+/* si_utime and si_stime must be 4 byte aligned for x32 to match the
+   kernel.  We align siginfo_t to 8 bytes so that si_utime and si_stime
+   are actually aligned to 8 bytes since their offsets are multiple of
+   8 bytes.  */
+typedef __clock_t __attribute__ ((__aligned__ (4))) __sigchld_clock_t;
+#  define __SI_ALIGNMENT __attribute__ ((__aligned__ (8)))
+# else
+typedef __clock_t __sigchld_clock_t;
+#  define __SI_ALIGNMENT
+# endif
+
+typedef struct siginfo
+  {
+    int si_signo;		/* Signal number.  */
+    int si_errno;		/* If non-zero, an errno value associated with
+				   this signal, as defined in <errno.h>.  */
+    int si_code;		/* Signal code.  */
+
+    union
+      {
+	int _pad[__SI_PAD_SIZE];
+
+	 /* kill().  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	  } _kill;
+
+	/* POSIX.1b timers.  */
+	struct
+	  {
+	    int si_tid;		/* Timer ID.  */
+	    int si_overrun;	/* Overrun count.  */
+	    sigval_t si_sigval;	/* Signal value.  */
+	  } _timer;
+
+	/* POSIX.1b signals.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    sigval_t si_sigval;	/* Signal value.  */
+	  } _rt;
+
+	/* SIGCHLD.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Which child.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    int si_status;	/* Exit value or signal.  */
+	    __sigchld_clock_t si_utime;
+	    __sigchld_clock_t si_stime;
+	  } _sigchld;
+
+	/* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
+	struct
+	  {
+	    void *si_addr;	/* Faulting insn/memory ref.  */
+	  } _sigfault;
+
+	/* SIGPOLL.  */
+	struct
+	  {
+	    long int si_band;	/* Band event for SIGPOLL.  */
+	    int si_fd;
+	  } _sigpoll;
+      } _sifields;
+  } siginfo_t __SI_ALIGNMENT;
+
+
+/* X/Open requires some more fields with fixed names.  */
+# define si_pid		_sifields._kill.si_pid
+# define si_uid		_sifields._kill.si_uid
+# define si_timerid	_sifields._timer.si_tid
+# define si_overrun	_sifields._timer.si_overrun
+# define si_status	_sifields._sigchld.si_status
+# define si_utime	_sifields._sigchld.si_utime
+# define si_stime	_sifields._sigchld.si_stime
+# define si_value	_sifields._rt.si_sigval
+# define si_int		_sifields._rt.si_sigval.sival_int
+# define si_ptr		_sifields._rt.si_sigval.sival_ptr
+# define si_addr	_sifields._sigfault.si_addr
+# define si_band	_sifields._sigpoll.si_band
+# define si_fd		_sifields._sigpoll.si_fd
+
+
+/* Values for `si_code'.  Positive values are reserved for kernel-generated
+   signals.  */
+enum
+{
+  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
+# define SI_ASYNCNL	SI_ASYNCNL
+  SI_TKILL = -6,		/* Sent by tkill.  */
+# define SI_TKILL	SI_TKILL
+  SI_SIGIO,			/* Sent by queued SIGIO. */
+# define SI_SIGIO	SI_SIGIO
+  SI_ASYNCIO,			/* Sent by AIO completion.  */
+# define SI_ASYNCIO	SI_ASYNCIO
+  SI_MESGQ,			/* Sent by real time mesq state change.  */
+# define SI_MESGQ	SI_MESGQ
+  SI_TIMER,			/* Sent by timer expiration.  */
+# define SI_TIMER	SI_TIMER
+  SI_QUEUE,			/* Sent by sigqueue.  */
+# define SI_QUEUE	SI_QUEUE
+  SI_USER,			/* Sent by kill, sigsend.  */
+# define SI_USER	SI_USER
+  SI_KERNEL = 0x80		/* Send by kernel.  */
+#define SI_KERNEL	SI_KERNEL
+};
+
+
+/* `si_code' values for SIGILL signal.  */
+enum
+{
+  ILL_ILLOPC = 1,		/* Illegal opcode.  */
+# define ILL_ILLOPC	ILL_ILLOPC
+  ILL_ILLOPN,			/* Illegal operand.  */
+# define ILL_ILLOPN	ILL_ILLOPN
+  ILL_ILLADR,			/* Illegal addressing mode.  */
+# define ILL_ILLADR	ILL_ILLADR
+  ILL_ILLTRP,			/* Illegal trap. */
+# define ILL_ILLTRP	ILL_ILLTRP
+  ILL_PRVOPC,			/* Privileged opcode.  */
+# define ILL_PRVOPC	ILL_PRVOPC
+  ILL_PRVREG,			/* Privileged register.  */
+# define ILL_PRVREG	ILL_PRVREG
+  ILL_COPROC,			/* Coprocessor error.  */
+# define ILL_COPROC	ILL_COPROC
+  ILL_BADSTK			/* Internal stack error.  */
+# define ILL_BADSTK	ILL_BADSTK
+};
+
+/* `si_code' values for SIGFPE signal.  */
+enum
+{
+  FPE_INTDIV = 1,		/* Integer divide by zero.  */
+# define FPE_INTDIV	FPE_INTDIV
+  FPE_INTOVF,			/* Integer overflow.  */
+# define FPE_INTOVF	FPE_INTOVF
+  FPE_FLTDIV,			/* Floating point divide by zero.  */
+# define FPE_FLTDIV	FPE_FLTDIV
+  FPE_FLTOVF,			/* Floating point overflow.  */
+# define FPE_FLTOVF	FPE_FLTOVF
+  FPE_FLTUND,			/* Floating point underflow.  */
+# define FPE_FLTUND	FPE_FLTUND
+  FPE_FLTRES,			/* Floating point inexact result.  */
+# define FPE_FLTRES	FPE_FLTRES
+  FPE_FLTINV,			/* Floating point invalid operation.  */
+# define FPE_FLTINV	FPE_FLTINV
+  FPE_FLTSUB			/* Subscript out of range.  */
+# define FPE_FLTSUB	FPE_FLTSUB
+};
+
+/* `si_code' values for SIGSEGV signal.  */
+enum
+{
+  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
+# define SEGV_MAPERR	SEGV_MAPERR
+  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
+# define SEGV_ACCERR	SEGV_ACCERR
+};
+
+/* `si_code' values for SIGBUS signal.  */
+enum
+{
+  BUS_ADRALN = 1,		/* Invalid address alignment.  */
+# define BUS_ADRALN	BUS_ADRALN
+  BUS_ADRERR,			/* Non-existant physical address.  */
+# define BUS_ADRERR	BUS_ADRERR
+  BUS_OBJERR			/* Object specific hardware error.  */
+# define BUS_OBJERR	BUS_OBJERR
+};
+
+/* `si_code' values for SIGTRAP signal.  */
+enum
+{
+  TRAP_BRKPT = 1,		/* Process breakpoint.  */
+# define TRAP_BRKPT	TRAP_BRKPT
+  TRAP_TRACE			/* Process trace trap.  */
+# define TRAP_TRACE	TRAP_TRACE
+};
+
+/* `si_code' values for SIGCHLD signal.  */
+enum
+{
+  CLD_EXITED = 1,		/* Child has exited.  */
+# define CLD_EXITED	CLD_EXITED
+  CLD_KILLED,			/* Child was killed.  */
+# define CLD_KILLED	CLD_KILLED
+  CLD_DUMPED,			/* Child terminated abnormally.  */
+# define CLD_DUMPED	CLD_DUMPED
+  CLD_TRAPPED,			/* Traced child has trapped.  */
+# define CLD_TRAPPED	CLD_TRAPPED
+  CLD_STOPPED,			/* Child has stopped.  */
+# define CLD_STOPPED	CLD_STOPPED
+  CLD_CONTINUED			/* Stopped child has continued.  */
+# define CLD_CONTINUED	CLD_CONTINUED
+};
+
+/* `si_code' values for SIGPOLL signal.  */
+enum
+{
+  POLL_IN = 1,			/* Data input available.  */
+# define POLL_IN	POLL_IN
+  POLL_OUT,			/* Output buffers available.  */
+# define POLL_OUT	POLL_OUT
+  POLL_MSG,			/* Input message available.   */
+# define POLL_MSG	POLL_MSG
+  POLL_ERR,			/* I/O error.  */
+# define POLL_ERR	POLL_ERR
+  POLL_PRI,			/* High priority input available.  */
+# define POLL_PRI	POLL_PRI
+  POLL_HUP			/* Device disconnected.  */
+# define POLL_HUP	POLL_HUP
+};
+
+# undef __need_siginfo_t
+#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
+
+
+#if (defined _SIGNAL_H || defined __need_sigevent_t) \
+    && !defined __have_sigevent_t
+# define __have_sigevent_t	1
+
+/* Structure to transport application-defined values with signals.  */
+# define __SIGEV_MAX_SIZE	64
+# if __WORDSIZE == 64
+#  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 4)
+# else
+#  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 3)
+# endif
+
+typedef struct sigevent
+  {
+    sigval_t sigev_value;
+    int sigev_signo;
+    int sigev_notify;
+
+    union
+      {
+	int _pad[__SIGEV_PAD_SIZE];
+
+	/* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the
+	   thread to receive the signal.  */
+	__pid_t _tid;
+
+	struct
+	  {
+	    void (*_function) (sigval_t);	/* Function to start.  */
+	    void *_attribute;			/* Really pthread_attr_t.  */
+	  } _sigev_thread;
+      } _sigev_un;
+  } sigevent_t;
+
+/* POSIX names to access some of the members.  */
+# define sigev_notify_function   _sigev_un._sigev_thread._function
+# define sigev_notify_attributes _sigev_un._sigev_thread._attribute
+
+/* `sigev_notify' values.  */
+enum
+{
+  SIGEV_SIGNAL = 0,		/* Notify via signal.  */
+# define SIGEV_SIGNAL	SIGEV_SIGNAL
+  SIGEV_NONE,			/* Other notification: meaningless.  */
+# define SIGEV_NONE	SIGEV_NONE
+  SIGEV_THREAD,			/* Deliver via thread creation.  */
+# define SIGEV_THREAD	SIGEV_THREAD
+
+  SIGEV_THREAD_ID = 4		/* Send signal to specific thread.  */
+#define SIGEV_THREAD_ID	SIGEV_THREAD_ID
+};
+
+#endif	/* have _SIGNAL_H.  */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/stat.h b/sysdeps/unix/sysv/linux/x86_64/bits/stat.h
index c7e4e1f..0647a17 100644
--- a/sysdeps/unix/sysv/linux/x86_64/bits/stat.h
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/stat.h
@@ -26,7 +26,7 @@
 /* Versions of the `struct stat' data structure.  */
 #define _STAT_VER_KERNEL	0
 
-#if __WORDSIZE == 32
+#ifndef __x86_64__
 # define _STAT_VER_SVR4		2
 # define _STAT_VER_LINUX	3
 
@@ -46,37 +46,37 @@
 struct stat
   {
     __dev_t st_dev;		/* Device.  */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
     unsigned short int __pad1;
 #endif
-#if __WORDSIZE == 64 || !defined __USE_FILE_OFFSET64
+#if defined __x86_64__ || !defined __USE_FILE_OFFSET64
     __ino_t st_ino;		/* File serial number.	*/
 #else
-    __ino_t __st_ino;			/* 32bit file serial number.	*/
+    __ino_t __st_ino;		/* 32bit file serial number.	*/
 #endif
-#if __WORDSIZE == 32
-    __mode_t st_mode;			/* File mode.  */
-    __nlink_t st_nlink;			/* Link count.  */
+#ifndef __x86_64__
+    __mode_t st_mode;		/* File mode.  */
+    __nlink_t st_nlink;		/* Link count.  */
 #else
     __nlink_t st_nlink;		/* Link count.  */
     __mode_t st_mode;		/* File mode.  */
 #endif
     __uid_t st_uid;		/* User ID of the file's owner.	*/
     __gid_t st_gid;		/* Group ID of the file's group.*/
-#if __WORDSIZE == 64
+#ifdef __x86_64__
     int __pad0;
 #endif
     __dev_t st_rdev;		/* Device number, if device.  */
-#if __WORDSIZE == 32
+#ifndef __x86_64__
     unsigned short int __pad2;
 #endif
-#if __WORDSIZE == 64 || !defined __USE_FILE_OFFSET64
+#if defined __x86_64__ || !defined __USE_FILE_OFFSET64
     __off_t st_size;			/* Size of file, in bytes.  */
 #else
     __off64_t st_size;			/* Size of file, in bytes.  */
 #endif
     __blksize_t st_blksize;	/* Optimal block size for I/O.  */
-#if __WORDSIZE == 64 || !defined __USE_FILE_OFFSET64
+#if defined __x86_64__  || !defined __USE_FILE_OFFSET64
     __blkcnt_t st_blocks;		/* Number 512-byte blocks allocated. */
 #else
     __blkcnt64_t st_blocks;		/* Number 512-byte blocks allocated. */
@@ -96,14 +96,14 @@ struct stat
 # define st_ctime st_ctim.tv_sec
 #else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __syscall_ulong_t st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __syscall_ulong_t st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+    __syscall_ulong_t st_ctimensec;	/* Nsecs of last status change.  */
 #endif
-#if __WORDSIZE == 64
-    long int __unused[3];
+#ifdef __x86_64__
+    long long int __unused[3];
 #else
 # ifndef __USE_FILE_OFFSET64
     unsigned long int __unused4;
@@ -119,7 +119,7 @@ struct stat
 struct stat64
   {
     __dev_t st_dev;		/* Device.  */
-# if __WORDSIZE == 64
+# ifdef __x86_64__
     __ino64_t st_ino;		/* File serial number.  */
     __nlink_t st_nlink;		/* Link count.  */
     __mode_t st_mode;		/* File mode.  */
@@ -131,7 +131,7 @@ struct stat64
 # endif
     __uid_t st_uid;		/* User ID of the file's owner.	*/
     __gid_t st_gid;		/* Group ID of the file's group.*/
-# if __WORDSIZE == 64
+# ifdef __x86_64__
     int __pad0;
     __dev_t st_rdev;		/* Device number, if device.  */
     __off_t st_size;		/* Size of file, in bytes.  */
@@ -157,14 +157,14 @@ struct stat64
 #  define st_ctime st_ctim.tv_sec
 # else
     __time_t st_atime;			/* Time of last access.  */
-    unsigned long int st_atimensec;	/* Nscecs of last access.  */
+    __syscall_ulong_t st_atimensec;	/* Nscecs of last access.  */
     __time_t st_mtime;			/* Time of last modification.  */
-    unsigned long int st_mtimensec;	/* Nsecs of last modification.  */
+    __syscall_ulong_t st_mtimensec;	/* Nsecs of last modification.  */
     __time_t st_ctime;			/* Time of last status change.  */
-    unsigned long int st_ctimensec;	/* Nsecs of last status change.  */
+    __syscall_ulong_t st_ctimensec;	/* Nsecs of last status change.  */
 # endif
-# if __WORDSIZE == 64
-    long int __unused[3];
+# ifdef __x86_64__
+    long long int __unused[3];
 # else
     __ino64_t st_ino;			/* File serial number.		*/
 # endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/statfs.h b/sysdeps/unix/sysv/linux/x86_64/bits/statfs.h
new file mode 100644
index 0000000..d96337e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/statfs.h
@@ -0,0 +1,71 @@
+/* Copyright (C) 1997, 1998, 2000, 2002, 2003, 2010, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STATFS_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <bits/types.h>
+
+struct statfs
+  {
+    __syscall_slong_t f_type;
+    __syscall_slong_t f_bsize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+#endif
+    __fsid_t f_fsid;
+    __syscall_slong_t f_namelen;
+    __syscall_slong_t f_frsize;
+    __syscall_slong_t f_flags;
+    __syscall_slong_t f_spare[4];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+    __syscall_slong_t f_type;
+    __syscall_slong_t f_bsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsid_t f_fsid;
+    __syscall_slong_t f_namelen;
+    __syscall_slong_t f_frsize;
+    __syscall_slong_t f_flags;
+    __syscall_slong_t f_spare[4];
+  };
+#endif
+
+/* Tell code we have these members.  */
+#define _STATFS_F_NAMELEN
+#define _STATFS_F_FRSIZE
+#define _STATFS_F_FLAGS
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/statvfs.h b/sysdeps/unix/sysv/linux/x86_64/bits/statvfs.h
new file mode 100644
index 0000000..a2769bd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/statvfs.h
@@ -0,0 +1,110 @@
+/* Copyright (C) 1997,1998,2000,2001,2002,2006,2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STATVFS_H
+# error "Never include <bits/statvfs.h> directly; use <sys/statvfs.h> instead."
+#endif
+
+#include <bits/types.h>  /* For __fsblkcnt_t and __fsfilcnt_t.  */
+
+#ifndef __x86_64__
+#define _STATVFSBUF_F_UNUSED
+#endif
+
+struct statvfs
+  {
+    unsigned long int f_bsize;
+    unsigned long int f_frsize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+    __fsfilcnt_t f_favail;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsfilcnt64_t f_favail;
+#endif
+    unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
+    int __f_unused;
+#endif
+    unsigned long int f_flag;
+    unsigned long int f_namemax;
+    int __f_spare[6];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statvfs64
+  {
+    unsigned long int f_bsize;
+    unsigned long int f_frsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsfilcnt64_t f_favail;
+    unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
+    int __f_unused;
+#endif
+    unsigned long int f_flag;
+    unsigned long int f_namemax;
+    int __f_spare[6];
+  };
+#endif
+
+/* Definitions for the flag in `f_flag'.  These definitions should be
+   kept in sync with the definitions in <sys/mount.h>.  */
+enum
+{
+  ST_RDONLY = 1,		/* Mount read-only.  */
+#define ST_RDONLY	ST_RDONLY
+  ST_NOSUID = 2			/* Ignore suid and sgid bits.  */
+#define ST_NOSUID	ST_NOSUID
+#ifdef __USE_GNU
+  ,
+  ST_NODEV = 4,			/* Disallow access to device special files.  */
+# define ST_NODEV	ST_NODEV
+  ST_NOEXEC = 8,		/* Disallow program execution.  */
+# define ST_NOEXEC	ST_NOEXEC
+  ST_SYNCHRONOUS = 16,		/* Writes are synced at once.  */
+# define ST_SYNCHRONOUS	ST_SYNCHRONOUS
+  ST_MANDLOCK = 64,		/* Allow mandatory locks on an FS.  */
+# define ST_MANDLOCK	ST_MANDLOCK
+  ST_WRITE = 128,		/* Write on file/directory/symlink.  */
+# define ST_WRITE	ST_WRITE
+  ST_APPEND = 256,		/* Append-only file.  */
+# define ST_APPEND	ST_APPEND
+  ST_IMMUTABLE = 512,		/* Immutable file.  */
+# define ST_IMMUTABLE	ST_IMMUTABLE
+  ST_NOATIME = 1024,		/* Do not update access times.  */
+# define ST_NOATIME	ST_NOATIME
+  ST_NODIRATIME = 2048,		/* Do not update directory access times.  */
+# define ST_NODIRATIME	ST_NODIRATIME
+  ST_RELATIME = 4096		/* Update atime relative to mtime/ctime.  */
+# define ST_RELATIME	ST_RELATIME
+#endif	/* Use GNU.  */
+};
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/timex.h b/sysdeps/unix/sysv/linux/x86_64/bits/timex.h
new file mode 100644
index 0000000..adf6292
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/timex.h
@@ -0,0 +1,128 @@
+/* Copyright (C) 1995-1997, 1999, 2007, 2009, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_BITS_TIMEX_H
+#define	_BITS_TIMEX_H	1
+
+/* These definitions from linux/timex.h as of 2.6.30.  */
+
+struct timex
+{
+  /* mode selector */
+  unsigned int modes;
+  /* time offset (usec) */
+  __syscall_slong_t offset;
+  /* frequency offset (scaled ppm) */
+  __syscall_slong_t freq;
+  /* maximum error (usec) */
+  __syscall_slong_t maxerror;
+  /* estimated error (usec) */
+  __syscall_slong_t esterror;
+  /* clock command/status */
+  int status;
+  /* pll time constant */
+  __syscall_slong_t constant;
+  /* clock precision (usec) (read only) */
+  __syscall_slong_t precision;
+  /* clock frequency tolerance (ppm) (read only) */
+  __syscall_slong_t tolerance;
+  /* (read only) */
+  struct timeval time;
+  /* (modified) usecs between clock ticks */
+  __syscall_slong_t tick;
+  /* pps frequency (scaled ppm) (ro) */
+  __syscall_slong_t ppsfreq;
+  /* pps jitter (us) (ro) */
+  __syscall_slong_t jitter;
+  /* interval duration (s) (shift) (ro) */
+  int shift;
+  /* pps stability (scaled ppm) (ro) */
+  __syscall_slong_t stabil;
+  /* jitter limit exceeded (ro) */
+  __syscall_slong_t jitcnt;
+  /* calibration intervals (ro) */
+  __syscall_slong_t calcnt;
+  /* calibration errors (ro) */
+  __syscall_slong_t errcnt;
+  /* stability limit exceeded (ro) */
+  __syscall_slong_t stbcnt;
+
+  /* TAI offset (ro) */
+  int tai;
+
+  /* ??? */
+  int  :32; int  :32; int  :32; int  :32;
+  int  :32; int  :32; int  :32; int  :32;
+  int  :32; int  :32; int  :32;
+};
+
+/* Mode codes (timex.mode) */
+#define ADJ_OFFSET		0x0001	/* time offset */
+#define ADJ_FREQUENCY		0x0002	/* frequency offset */
+#define ADJ_MAXERROR		0x0004	/* maximum time error */
+#define ADJ_ESTERROR		0x0008	/* estimated time error */
+#define ADJ_STATUS		0x0010	/* clock status */
+#define ADJ_TIMECONST		0x0020	/* pll time constant */
+#define ADJ_TAI			0x0080	/* set TAI offset */
+#define ADJ_MICRO		0x1000	/* select microsecond resolution */
+#define ADJ_NANO		0x2000	/* select nanosecond resolution */
+#define ADJ_TICK		0x4000	/* tick value */
+#define ADJ_OFFSET_SINGLESHOT	0x8001	/* old-fashioned adjtime */
+#define ADJ_OFFSET_SS_READ	0xa001	/* read-only adjtime */
+
+/* xntp 3.4 compatibility names */
+#define MOD_OFFSET	ADJ_OFFSET
+#define MOD_FREQUENCY	ADJ_FREQUENCY
+#define MOD_MAXERROR	ADJ_MAXERROR
+#define MOD_ESTERROR	ADJ_ESTERROR
+#define MOD_STATUS	ADJ_STATUS
+#define MOD_TIMECONST	ADJ_TIMECONST
+#define MOD_CLKB	ADJ_TICK
+#define MOD_CLKA	ADJ_OFFSET_SINGLESHOT /* 0x8000 in original */
+#define MOD_TAI		ADJ_TAI
+#define MOD_MICRO	ADJ_MICRO
+#define MOD_NANO	ADJ_NANO
+
+
+/* Status codes (timex.status) */
+#define STA_PLL		0x0001	/* enable PLL updates (rw) */
+#define STA_PPSFREQ	0x0002	/* enable PPS freq discipline (rw) */
+#define STA_PPSTIME	0x0004	/* enable PPS time discipline (rw) */
+#define STA_FLL		0x0008	/* select frequency-lock mode (rw) */
+
+#define STA_INS		0x0010	/* insert leap (rw) */
+#define STA_DEL		0x0020	/* delete leap (rw) */
+#define STA_UNSYNC	0x0040	/* clock unsynchronized (rw) */
+#define STA_FREQHOLD	0x0080	/* hold frequency (rw) */
+
+#define STA_PPSSIGNAL	0x0100	/* PPS signal present (ro) */
+#define STA_PPSJITTER	0x0200	/* PPS signal jitter exceeded (ro) */
+#define STA_PPSWANDER	0x0400	/* PPS signal wander exceeded (ro) */
+#define STA_PPSERROR	0x0800	/* PPS signal calibration error (ro) */
+
+#define STA_CLOCKERR	0x1000	/* clock hardware fault (ro) */
+#define STA_NANO	0x2000	/* resolution (0 = us, 1 = ns) (ro) */
+#define STA_MODE	0x4000	/* mode (0 = PLL, 1 = FLL) (ro) */
+#define STA_CLK		0x8000	/* clock source (0 = A, 1 = B) (ro) */
+
+/* Read-only bits */
+#define STA_RONLY (STA_PPSSIGNAL | STA_PPSJITTER | STA_PPSWANDER | \
+    STA_PPSERROR | STA_CLOCKERR | STA_NANO | STA_MODE | STA_CLK)
+
+#endif /* bits/timex.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h b/sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h
new file mode 100644
index 0000000..d6d4b92
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/typesizes.h
@@ -0,0 +1,88 @@
+/* bits/typesizes.h -- underlying types for *_t.  X86_64 version.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+/* X32 kernel interface is 64bit.  */
+#if defined __x86_64__ && __WORDSIZE == 32
+#define __INO_T_TYPE		__UQUAD_TYPE
+#define __NLINK_T_TYPE		__UQUAD_TYPE
+#define __OFF_T_TYPE		__SQUAD_TYPE
+#define __RLIM_T_TYPE		__UQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__UQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__UQUAD_TYPE
+#define __CLOCK_T_TYPE		__SQUAD_TYPE
+#define __TIME_T_TYPE		__SQUAD_TYPE
+#define __SUSECONDS_T_TYPE	__SQUAD_TYPE
+#define __SNSECONDS_T_TYPE	__SQUAD_TYPE
+#define __BLKSIZE_T_TYPE	__SQUAD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SQUAD_TYPE
+#define __SYSCALL_ULONG_TYPE	__UQUAD_TYPE
+#else
+#define __INO_T_TYPE		__ULONGWORD_TYPE
+#define __NLINK_T_TYPE		__UWORD_TYPE
+#define __OFF_T_TYPE		__SLONGWORD_TYPE
+#define __RLIM_T_TYPE		__ULONGWORD_TYPE
+#define	__BLKCNT_T_TYPE		__SLONGWORD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define __CLOCK_T_TYPE		__SLONGWORD_TYPE
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __BLKSIZE_T_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
+#endif
+
+#define __DEV_T_TYPE		__UQUAD_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U32_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM64_T_TYPE		__UQUAD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __DADDR_T_TYPE		__S32_TYPE
+#define __SWBLK_T_TYPE		__SLONGWORD_TYPE
+#define __KEY_T_TYPE		__S32_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		void *
+#define __FSID_T_TYPE		struct { int __val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/utmp.h b/sysdeps/unix/sysv/linux/x86_64/bits/utmp.h
new file mode 100644
index 0000000..3e18f17
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/utmp.h
@@ -0,0 +1,124 @@
+/* The `struct utmp' type, describing entries in the utmp file.  GNU version.
+   Copyright (C) 1993, 1996, 1997, 1998, 1999, 2002, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UTMP_H
+# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
+#endif
+
+#include <paths.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+
+#define UT_LINESIZE	32
+#define UT_NAMESIZE	32
+#define UT_HOSTSIZE	256
+
+
+/* The structure describing an entry in the database of
+   previous logins.  */
+struct lastlog
+  {
+#ifdef __x86_64__
+    int32_t ll_time;
+#else
+    __time_t ll_time;
+#endif
+    char ll_line[UT_LINESIZE];
+    char ll_host[UT_HOSTSIZE];
+  };
+
+
+/* The structure describing the status of a terminated process.  This
+   type is used in `struct utmp' below.  */
+struct exit_status
+  {
+    short int e_termination;	/* Process termination status.  */
+    short int e_exit;		/* Process exit status.  */
+  };
+
+
+/* The structure describing an entry in the user accounting database.  */
+struct utmp
+{
+  short int ut_type;		/* Type of login.  */
+  pid_t ut_pid;			/* Process ID of login process.  */
+  char ut_line[UT_LINESIZE];	/* Devicename.  */
+  char ut_id[4];		/* Inittab ID.  */
+  char ut_user[UT_NAMESIZE];	/* Username.  */
+  char ut_host[UT_HOSTSIZE];	/* Hostname for remote login.  */
+  struct exit_status ut_exit;	/* Exit status of a process marked
+				   as DEAD_PROCESS.  */
+/* The ut_session and ut_tv fields must be the same size when compiled
+   32- and 64-bit.  This allows data files and shared memory to be
+   shared between 32- and 64-bit applications.  */
+#ifdef __x86_64__
+  int32_t ut_session;		/* Session ID, used for windowing.  */
+  struct
+  {
+    int32_t tv_sec;		/* Seconds.  */
+    int32_t tv_usec;		/* Microseconds.  */
+  } ut_tv;			/* Time entry was made.  */
+#else
+  long int ut_session;		/* Session ID, used for windowing.  */
+  struct timeval ut_tv;		/* Time entry was made.  */
+#endif
+
+  int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
+  char __unused[20];		/* Reserved for future use.  */
+};
+
+/* Backwards compatibility hacks.  */
+#define ut_name		ut_user
+#ifndef _NO_UT_TIME
+/* We have a problem here: `ut_time' is also used otherwise.  Define
+   _NO_UT_TIME if the compiler complains.  */
+# define ut_time	ut_tv.tv_sec
+#endif
+#define ut_xtime	ut_tv.tv_sec
+#define ut_addr		ut_addr_v6[0]
+
+
+/* Values for the `ut_type' field of a `struct utmp'.  */
+#define EMPTY		0	/* No valid user accounting information.  */
+
+#define RUN_LVL		1	/* The system's runlevel.  */
+#define BOOT_TIME	2	/* Time of system boot.  */
+#define NEW_TIME	3	/* Time after system clock changed.  */
+#define OLD_TIME	4	/* Time when system clock changed.  */
+
+#define INIT_PROCESS	5	/* Process spawned by the init process.  */
+#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
+#define USER_PROCESS	7	/* Normal process.  */
+#define DEAD_PROCESS	8	/* Terminated process.  */
+
+#define ACCOUNTING	9
+
+/* Old Linux name for the EMPTY type.  */
+#define UT_UNKNOWN	EMPTY
+
+
+/* Tell the user that we have a modern system with UT_HOST, UT_PID,
+   UT_TYPE, UT_ID and UT_TV fields.  */
+#define _HAVE_UT_TYPE	1
+#define _HAVE_UT_PID	1
+#define _HAVE_UT_ID	1
+#define _HAVE_UT_TV	1
+#define _HAVE_UT_HOST	1
diff --git a/sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h b/sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h
new file mode 100644
index 0000000..6972b91
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/bits/utmpx.h
@@ -0,0 +1,103 @@
+/* Structures and definitions for the user accounting database.  GNU version.
+   Copyright (C) 1997, 1998, 2000, 2001, 2002, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UTMPX_H
+# error "Never include <bits/utmpx.h> directly; use <utmpx.h> instead."
+#endif
+
+#include <bits/types.h>
+#include <sys/time.h>
+
+
+#ifdef __USE_GNU
+# include <paths.h>
+# define _PATH_UTMPX	_PATH_UTMP
+# define _PATH_WTMPX	_PATH_WTMP
+#endif
+
+
+#define __UT_LINESIZE	32
+#define __UT_NAMESIZE	32
+#define __UT_HOSTSIZE	256
+
+
+/* The structure describing the status of a terminated process.  This
+   type is used in `struct utmpx' below.  */
+struct __exit_status
+  {
+#ifdef __USE_GNU
+    short int e_termination;	/* Process termination status.  */
+    short int e_exit;		/* Process exit status.  */
+#else
+    short int __e_termination;	/* Process termination status.  */
+    short int __e_exit;		/* Process exit status.  */
+#endif
+  };
+
+
+/* The structure describing an entry in the user accounting database.  */
+struct utmpx
+{
+  short int ut_type;		/* Type of login.  */
+  __pid_t ut_pid;		/* Process ID of login process.  */
+  char ut_line[__UT_LINESIZE];	/* Devicename.  */
+  char ut_id[4];		/* Inittab ID. */
+  char ut_user[__UT_NAMESIZE];	/* Username.  */
+  char ut_host[__UT_HOSTSIZE];	/* Hostname for remote login.  */
+  struct __exit_status ut_exit;	/* Exit status of a process marked
+				   as DEAD_PROCESS.  */
+
+/* The fields ut_session and ut_tv must be the same size when compiled
+   32- and 64-bit.  This allows files and shared memory to be shared
+   between 32- and 64-bit applications.  */
+#ifdef __x86_64__
+  __int32_t ut_session;		/* Session ID, used for windowing.  */
+  struct
+  {
+    __int32_t tv_sec;		/* Seconds.  */
+    __int32_t tv_usec;		/* Microseconds.  */
+  } ut_tv;			/* Time entry was made.  */
+#else
+  long int ut_session;		/* Session ID, used for windowing.  */
+  struct timeval ut_tv;		/* Time entry was made.  */
+#endif
+  __int32_t ut_addr_v6[4];	/* Internet address of remote host.  */
+  char __unused[20];		/* Reserved for future use.  */
+};
+
+
+/* Values for the `ut_type' field of a `struct utmpx'.  */
+#define EMPTY		0	/* No valid user accounting information.  */
+
+#ifdef __USE_GNU
+# define RUN_LVL	1	/* The system's runlevel.  */
+#endif
+#define BOOT_TIME	2	/* Time of system boot.  */
+#define NEW_TIME	3	/* Time after system clock changed.  */
+#define OLD_TIME	4	/* Time when system clock changed.  */
+
+#define INIT_PROCESS	5	/* Process spawned by the init process.  */
+#define LOGIN_PROCESS	6	/* Session leader of a logged in user.  */
+#define USER_PROCESS	7	/* Normal process.  */
+#define DEAD_PROCESS	8	/* Terminated process.  */
+
+#ifdef __USE_GNU
+# define ACCOUNTING	9	/* System accounting.  */
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/clone.S b/sysdeps/unix/sysv/linux/x86_64/clone.S
index db42f20..be8c6c6 100644
--- a/sysdeps/unix/sysv/linux/x86_64/clone.S
+++ b/sysdeps/unix/sysv/linux/x86_64/clone.S
@@ -73,7 +73,7 @@ ENTRY (BP_SYM (__clone))
 	movq	%rdx, %rdi
 	movq	%r8, %rdx
 	movq	%r9, %r8
-	movq	8(%rsp), %r10
+	mov	8(%rsp), %R10_LP
 	movl	$SYS_ify(clone),%eax
 
 	/* End FDE now, because in the child the unwind info will be
diff --git a/sysdeps/unix/sysv/linux/x86_64/dl-cache.h b/sysdeps/unix/sysv/linux/x86_64/dl-cache.h
index cb647ab..1f400eb 100644
--- a/sysdeps/unix/sysv/linux/x86_64/dl-cache.h
+++ b/sysdeps/unix/sysv/linux/x86_64/dl-cache.h
@@ -22,4 +22,31 @@
 #define _dl_cache_check_flags(flags)			\
   ((flags) == _DL_CACHE_DEFAULT_ID)
 
-#include <sysdeps/unix/sysv/linux/sparc/dl-cache.h>
+#define add_system_dir(dir) \
+  do								\
+    {								\
+      size_t len = strlen (dir);				\
+      char path[len + 4];					\
+      memcpy (path, dir, len + 1);				\
+      if (len >= 6 && ! memcmp (path + len - 6, "/lib64", 6))	\
+	{							\
+	  len -= 2;						\
+	  path[len] = '\0';					\
+	}							\
+      else if (len >= 7						\
+	       && ! memcmp (path + len - 7, "/libx32", 7))	\
+	{							\
+	  len -= 3;						\
+	  path[len] = '\0';					\
+	}							\
+      add_dir (path);						\
+      if (len >= 4 && ! memcmp (path + len - 4, "/lib", 4))	\
+	{							\
+	  memcpy (path + len, "64", 3);				\
+	  add_dir (path);					\
+	  memcpy (path + len, "x32", 4);				\
+	  add_dir (path);					\
+	}							\
+    } while (0)
+
+#include <sysdeps/generic/dl-cache.h>
diff --git a/sysdeps/unix/sysv/linux/x86_64/ldconfig.h b/sysdeps/unix/sysv/linux/x86_64/ldconfig.h
index f7f64eb..69f77dd 100644
--- a/sysdeps/unix/sysv/linux/x86_64/ldconfig.h
+++ b/sysdeps/unix/sysv/linux/x86_64/ldconfig.h
@@ -20,6 +20,7 @@
 
 #define SYSDEP_KNOWN_INTERPRETER_NAMES \
   { "/lib/ld-linux.so.2", FLAG_ELF_LIBC6 }, \
+  { "/libx32/ld-linux-x32.so.2", FLAG_ELF_LIBC6 }, \
   { "/lib64/ld-linux-x86-64.so.2", FLAG_ELF_LIBC6 },
 #define SYSDEP_KNOWN_LIBRARY_NAMES \
   { "libc.so.6", FLAG_ELF_LIBC6 },	\
diff --git a/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed b/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
index 3f1530d..44d76e8 100644
--- a/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
+++ b/sysdeps/unix/sysv/linux/x86_64/ldd-rewrite.sed
@@ -1,3 +1,3 @@
 /LD_TRACE_LOADED_OBJECTS=1/a\
 add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
-s_^\(RTLDLIST=\)\(.*lib\)\(\|64\)\(/[^/]*\)\(-x86-64\)\(\.so\.[0-9.]*\)[ 	]*$_\1"\2\4\6 \264\4\5\6"_
+s_^\(RTLDLIST=\)\(.*lib\)\(\|64\|x32\)\(/[^/]*\)\(-x86-64\|-x32\)\(\.so\.[0-9.]*\)[ 	]*$_\1"\2\4\6 \264\4-x86-64\6 \2x32\4-x32\6"_
diff --git a/sysdeps/unix/sysv/linux/x86_64/makecontext.c b/sysdeps/unix/sysv/linux/x86_64/makecontext.c
index 615dede..9ae9528 100644
--- a/sysdeps/unix/sysv/linux/x86_64/makecontext.c
+++ b/sysdeps/unix/sysv/linux/x86_64/makecontext.c
@@ -53,29 +53,30 @@ void
 __makecontext (ucontext_t *ucp, void (*func) (void), int argc, ...)
 {
   extern void __start_context (void);
-  unsigned long int *sp, idx_uc_link;
+  greg_t *sp;
+  unsigned int idx_uc_link;
   va_list ap;
   int i;
 
   /* Generate room on stack for parameter if needed and uc_link.  */
-  sp = (unsigned long int *) ((uintptr_t) ucp->uc_stack.ss_sp
-			      + ucp->uc_stack.ss_size);
+  sp = (greg_t *) ((uintptr_t) ucp->uc_stack.ss_sp
+		   + ucp->uc_stack.ss_size);
   sp -= (argc > 6 ? argc - 6 : 0) + 1;
   /* Align stack and make space for trampoline address.  */
-  sp = (unsigned long int *) ((((uintptr_t) sp) & -16L) - 8);
+  sp = (greg_t *) ((((uintptr_t) sp) & -16L) - 8);
 
   idx_uc_link = (argc > 6 ? argc - 6 : 0) + 1;
 
   /* Setup context ucp.  */
   /* Address to jump to.  */
-  ucp->uc_mcontext.gregs[REG_RIP] = (long int) func;
+  ucp->uc_mcontext.gregs[REG_RIP] = (uintptr_t) func;
   /* Setup rbx.*/
-  ucp->uc_mcontext.gregs[REG_RBX] = (long int) &sp[idx_uc_link];
-  ucp->uc_mcontext.gregs[REG_RSP] = (long int) sp;
+  ucp->uc_mcontext.gregs[REG_RBX] = (uintptr_t) &sp[idx_uc_link];
+  ucp->uc_mcontext.gregs[REG_RSP] = (uintptr_t) sp;
 
   /* Setup stack.  */
-  sp[0] = (unsigned long int) &__start_context;
-  sp[idx_uc_link] = (unsigned long int) ucp->uc_link;
+  sp[0] = (uintptr_t) &__start_context;
+  sp[idx_uc_link] = (uintptr_t) ucp->uc_link;
 
   va_start (ap, argc);
   /* Handle arguments.
@@ -91,26 +92,26 @@ __makecontext (ucontext_t *ucp, void (*func) (void), int argc, ...)
     switch (i)
       {
       case 0:
-	ucp->uc_mcontext.gregs[REG_RDI] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_RDI] = va_arg (ap, greg_t);
 	break;
       case 1:
-	ucp->uc_mcontext.gregs[REG_RSI] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_RSI] = va_arg (ap, greg_t);
 	break;
       case 2:
-	ucp->uc_mcontext.gregs[REG_RDX] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_RDX] = va_arg (ap, greg_t);
 	break;
       case 3:
-	ucp->uc_mcontext.gregs[REG_RCX] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_RCX] = va_arg (ap, greg_t);
 	break;
       case 4:
-	ucp->uc_mcontext.gregs[REG_R8] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_R8] = va_arg (ap, greg_t);
 	break;
       case 5:
-	ucp->uc_mcontext.gregs[REG_R9] = va_arg (ap, long int);
+	ucp->uc_mcontext.gregs[REG_R9] = va_arg (ap, greg_t);
 	break;
       default:
 	/* Put value on stack.  */
-	sp[i - 5] = va_arg (ap, unsigned long int);
+	sp[i - 5] = va_arg (ap, greg_t);
 	break;
       }
   va_end (ap);
diff --git a/sysdeps/unix/sysv/linux/x86_64/readelflib.c b/sysdeps/unix/sysv/linux/x86_64/readelflib.c
index 5a49af3..4c4e5f9 100644
--- a/sysdeps/unix/sysv/linux/x86_64/readelflib.c
+++ b/sysdeps/unix/sysv/linux/x86_64/readelflib.c
@@ -1,62 +1,2 @@
-/* Copyright (C) 1999, 2001, 2002, 2005 Free Software Foundation, Inc.
-   This file is part of the GNU C Library.
-   Contributed by Andreas Jaeger <aj@suse.de>, 1999 and
-		  Jakub Jelinek <jakub@redhat.com>, 1999.
-
-   The GNU C Library is free software; you can redistribute it and/or
-   modify it under the terms of the GNU Lesser General Public
-   License as published by the Free Software Foundation; either
-   version 2.1 of the License, or (at your option) any later version.
-
-   The GNU C Library is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-   Lesser General Public License for more details.
-
-   You should have received a copy of the GNU Lesser General Public
-   License along with the GNU C Library; if not, write to the Free
-   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
-   02111-1307 USA.  */
-
-
-int process_elf32_file (const char *file_name, const char *lib, int *flag,
-			unsigned int *osversion, char **soname,
-			void *file_contents, size_t file_length);
-int process_elf64_file (const char *file_name, const char *lib, int *flag,
-			unsigned int *osversion, char **soname,
-			void *file_contents, size_t file_length);
-
-/* Returns 0 if everything is ok, != 0 in case of error.  */
-int
-process_elf_file (const char *file_name, const char *lib, int *flag,
-		  unsigned int *osversion, char **soname, void *file_contents,
-		  size_t file_length)
-{
-  ElfW(Ehdr) *elf_header = (ElfW(Ehdr) *) file_contents;
-  int ret;
-
-  if (elf_header->e_ident [EI_CLASS] == ELFCLASS32)
-    return process_elf32_file (file_name, lib, flag, osversion, soname,
-			       file_contents, file_length);
-  else
-    {
-      ret = process_elf64_file (file_name, lib, flag, osversion, soname,
-				file_contents, file_length);
-      /* x86-64 64bit libraries are always libc.so.6+.  */
-      if (!ret)
-	*flag = FLAG_X8664_LIB64|FLAG_ELF_LIBC6;
-      return ret;
-    }
-}
-
-#undef __ELF_NATIVE_CLASS
-#undef process_elf_file
-#define process_elf_file process_elf32_file
-#define __ELF_NATIVE_CLASS 32
-#include "elf/readelflib.c"
-
-#undef __ELF_NATIVE_CLASS
-#undef process_elf_file
-#define process_elf_file process_elf64_file
-#define __ELF_NATIVE_CLASS 64
-#include "elf/readelflib.c"
+#define SKIP_EM_IA_64
+#include <sysdeps/unix/sysv/linux/i386/readelflib.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/sigaction.c b/sysdeps/unix/sysv/linux/x86_64/sigaction.c
index ab10123..a97e072 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sigaction.c
+++ b/sysdeps/unix/sysv/linux/x86_64/sigaction.c
@@ -147,7 +147,7 @@ asm									\
    ".LSTARTAUGMNT_" #name ":\n"						\
    "	.byte 0x1b\n"	/* DW_EH_PE_pcrel|DW_EH_PE_sdata4. */		\
    ".LENDAUGMNT_" #name ":\n"						\
-   "	.align 8\n"							\
+   "	.align " LP_SIZE "\n"						\
    ".LENDCIE_" #name ":\n"						\
    "	.long .LENDFDE_" #name "-.LSTARTFDE_" #name "\n" /* FDE len */	\
    ".LSTARTFDE_" #name ":\n"						\
@@ -178,7 +178,7 @@ asm									\
    /* do_expr (49 |* rflags *|, oEFL) */				\
    /* `cs'/`ds'/`fs' are unaligned and a different size.  */		\
    /* gas: Error: register save offset not a multiple of 8  */		\
-   "	.align 8\n"							\
+   "	.align " LP_SIZE "\n"						\
    ".LENDFDE_" #name ":\n"						\
    "	.previous\n"							\
    );
diff --git a/sysdeps/unix/sysv/linux/x86_64/sigaltstack.sym b/sysdeps/unix/sysv/linux/x86_64/sigaltstack.sym
new file mode 100644
index 0000000..9fd26fe
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/sigaltstack.sym
@@ -0,0 +1,15 @@
+#ifndef _XOPEN_EXTENDED
+# define _XOPEN_EXTENDED
+#endif
+
+#include <stddef.h>
+#include <signal.h>
+
+--
+
+#define sigaltstack(member)	offsetof (stack_t, member)
+
+sizeSS				sizeof(stack_t)
+oSS_SP				sigaltstack(ss_sp)
+oSS_SIZE			sigaltstack(ss_size)
+oSS_FLAGS			sigaltstack(ss_flags)
diff --git a/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h b/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h
index 11493c5..78c9aa7 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sigcontextinfo.h
@@ -16,11 +16,16 @@
    Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
    02111-1307 USA.  */
 
+#include <stdint.h>
+
 #define SIGCONTEXT siginfo_t *_si, struct ucontext *
 #define SIGCONTEXT_EXTRA_ARGS _si,
-#define GET_PC(ctx)	((void *) (ctx)->uc_mcontext.gregs[REG_RIP])
-#define GET_FRAME(ctx)	((void *) (ctx)->uc_mcontext.gregs[REG_RBP])
-#define GET_STACK(ctx)	((void *) (ctx)->uc_mcontext.gregs[REG_RSP])
+#define GET_PC(ctx)	\
+  ((void *) (uintptr_t) (ctx)->uc_mcontext.gregs[REG_RIP])
+#define GET_FRAME(ctx)	\
+  ((void *) (uintptr_t) (ctx)->uc_mcontext.gregs[REG_RBP])
+#define GET_STACK(ctx)	\
+  ((void *) (uintptr_t) (ctx)->uc_mcontext.gregs[REG_RSP])
 
 #define CALL_SIGHANDLER(handler, signo, ctx) \
   (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h b/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
index 8abbf75..c3adbdf 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/debugreg.h
@@ -18,7 +18,6 @@
 
 #ifndef _SYS_DEBUGREG_H
 #define _SYS_DEBUGREG_H	1
-#include <bits/wordsize.h>
 
 /* Indicate the register numbers for a number of the specific
    debug registers.  Registers 0-3 contain the addresses we wish to trap on */
@@ -77,8 +76,8 @@
 
 
 
-#if __WORDSIZE == 64
-# define DR_CONTROL_RESERVED (0xFFFFFFFF0000FC00UL) /* Reserved */
+#ifdef __x86_64__
+# define DR_CONTROL_RESERVED (0xFFFFFFFF0000FC00ULL) /* Reserved */
 #else
 # define DR_CONTROL_RESERVED (0x00FC00U) /* Reserved */
 #endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/msg.h b/sysdeps/unix/sysv/linux/x86_64/sys/msg.h
new file mode 100644
index 0000000..35aa171
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/msg.h
@@ -0,0 +1,85 @@
+/* Copyright (C) 1995-1997, 1999, 2000, 2003, 2006, 2007, 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MSG_H
+#define _SYS_MSG_H
+
+#include <features.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+/* Get common definition of System V style IPC.  */
+#include <sys/ipc.h>
+
+/* Get system dependent definition of `struct msqid_ds' and more.  */
+#include <bits/msq.h>
+
+/* Define types required by the standard.  */
+#define	__need_time_t
+#include <time.h>
+
+#ifndef __pid_t_defined
+typedef __pid_t pid_t;
+# define __pid_t_defined
+#endif
+
+#ifndef __ssize_t_defined
+typedef __ssize_t ssize_t;
+# define __ssize_t_defined
+#endif
+
+/* The following System V style IPC functions implement a message queue
+   system.  The definition is found in XPG2.  */
+
+#ifdef __USE_GNU
+/* Template for struct to be used as argument for `msgsnd' and `msgrcv'.  */
+struct msgbuf
+  {
+    __syscall_slong_t mtype;	/* type of received/sent message */
+    char mtext[1];		/* text of the message */
+  };
+#endif
+
+
+__BEGIN_DECLS
+
+/* Message queue control operation.  */
+extern int msgctl (int __msqid, int __cmd, struct msqid_ds *__buf) __THROW;
+
+/* Get messages queue.  */
+extern int msgget (key_t __key, int __msgflg) __THROW;
+
+/* Receive message from message queue.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern ssize_t msgrcv (int __msqid, void *__msgp, size_t __msgsz,
+		       long int __msgtyp, int __msgflg);
+
+/* Send message to message queue.
+
+   This function is a cancellation point and therefore not marked with
+   __THROW.  */
+extern int msgsnd (int __msqid, __const void *__msgp, size_t __msgsz,
+		   int __msgflg);
+
+__END_DECLS
+
+#endif /* sys/msg.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h b/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h
index 853d7db..80c6cfb 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/procfs.h
@@ -36,7 +36,11 @@
 __BEGIN_DECLS
 
 /* Type for a general-purpose register.  */
+#ifdef __x86_64__
+typedef unsigned long long elf_greg_t;
+#else
 typedef unsigned long elf_greg_t;
+#endif
 
 /* And the whole bunch of them.  We could have used `struct
    user_regs_struct' directly in the typedef, but tradition says that
@@ -45,7 +49,7 @@ typedef unsigned long elf_greg_t;
 #define ELF_NGREG (sizeof (struct user_regs_struct) / sizeof(elf_greg_t))
 typedef elf_greg_t elf_gregset_t[ELF_NGREG];
 
-#if __WORDSIZE == 32
+#ifndef __x86_64__
 /* Register set for the floating-point registers.  */
 typedef struct user_fpregs_struct elf_fpregset_t;
 
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/reg.h b/sysdeps/unix/sysv/linux/x86_64/sys/reg.h
index acb71a2..0772bc7 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sys/reg.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/reg.h
@@ -18,10 +18,9 @@
 
 #ifndef _SYS_REG_H
 #define _SYS_REG_H	1
-#include <bits/wordsize.h>
 
 
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 /* Index into an array of 8 byte longs returned from ptrace for
    location of the users' stored general purpose registers.  */
 
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h b/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h
index b59cd29..75e37c4 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/ucontext.h
@@ -21,16 +21,15 @@
 
 #include <features.h>
 #include <signal.h>
-#include <bits/wordsize.h>
 
 /* We need the signal context definitions even if they are not used
    included in <signal.h>.  */
 #include <bits/sigcontext.h>
 
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 
 /* Type for general register.  */
-typedef long int greg_t;
+typedef long long int greg_t;
 
 /* Number of general registers.  */
 #define NGREG	23
@@ -128,7 +127,7 @@ typedef struct
     gregset_t gregs;
     /* Note that fpregs is a pointer.  */
     fpregset_t fpregs;
-    unsigned long __reserved1 [8];
+    unsigned long long __reserved1 [8];
 } mcontext_t;
 
 /* Userlevel context.  */
@@ -142,7 +141,7 @@ typedef struct ucontext
     struct _libc_fpstate __fpregs_mem;
   } ucontext_t;
 
-#else /* __WORDSIZE == 32 */
+#else /* !__x86_64__ */
 
 /* Type for general register.  */
 typedef int greg_t;
@@ -243,6 +242,6 @@ typedef struct ucontext
     struct _libc_fpstate __fpregs_mem;
   } ucontext_t;
 
-#endif /* __WORDSIZE == 32 */
+#endif /* !__x86_64__ */
 
 #endif /* sys/ucontext.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/sys/user.h b/sysdeps/unix/sysv/linux/x86_64/sys/user.h
index e4423cf..35bfa8b 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sys/user.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sys/user.h
@@ -25,7 +25,7 @@
 
 #include <bits/wordsize.h>
 
-#if __WORDSIZE == 64
+#ifdef __x86_64__
 
 struct user_fpregs_struct
 {
@@ -33,8 +33,8 @@ struct user_fpregs_struct
   unsigned short int	swd;
   unsigned short int	ftw;
   unsigned short int	fop;
-  unsigned long int	rip;
-  unsigned long int	rdp;
+  unsigned long long int rip;
+  unsigned long long int rdp;
   unsigned int		mxcsr;
   unsigned int		mxcr_mask;
   unsigned int		st_space[32];   /* 8*16 bytes for each FP-reg = 128 bytes */
@@ -44,33 +44,33 @@ struct user_fpregs_struct
 
 struct user_regs_struct
 {
-  unsigned long int r15;
-  unsigned long int r14;
-  unsigned long int r13;
-  unsigned long int r12;
-  unsigned long int rbp;
-  unsigned long int rbx;
-  unsigned long int r11;
-  unsigned long int r10;
-  unsigned long int r9;
-  unsigned long int r8;
-  unsigned long int rax;
-  unsigned long int rcx;
-  unsigned long int rdx;
-  unsigned long int rsi;
-  unsigned long int rdi;
-  unsigned long int orig_rax;
-  unsigned long int rip;
-  unsigned long int cs;
-  unsigned long int eflags;
-  unsigned long int rsp;
-  unsigned long int ss;
-  unsigned long int fs_base;
-  unsigned long int gs_base;
-  unsigned long int ds;
-  unsigned long int es;
-  unsigned long int fs;
-  unsigned long int gs;
+  unsigned long long int r15;
+  unsigned long long int r14;
+  unsigned long long int r13;
+  unsigned long long int r12;
+  unsigned long long int rbp;
+  unsigned long long int rbx;
+  unsigned long long int r11;
+  unsigned long long int r10;
+  unsigned long long int r9;
+  unsigned long long int r8;
+  unsigned long long int rax;
+  unsigned long long int rcx;
+  unsigned long long int rdx;
+  unsigned long long int rsi;
+  unsigned long long int rdi;
+  unsigned long long int orig_rax;
+  unsigned long long int rip;
+  unsigned long long int cs;
+  unsigned long long int eflags;
+  unsigned long long int rsp;
+  unsigned long long int ss;
+  unsigned long long int fs_base;
+  unsigned long long int gs_base;
+  unsigned long long int ds;
+  unsigned long long int es;
+  unsigned long long int fs;
+  unsigned long long int gs;
 };
 
 struct user
@@ -78,18 +78,24 @@ struct user
   struct user_regs_struct	regs;
   int				u_fpvalid;
   struct user_fpregs_struct	i387;
-  unsigned long int		u_tsize;
-  unsigned long int		u_dsize;
-  unsigned long int		u_ssize;
-  unsigned long int		start_code;
-  unsigned long int		start_stack;
-  long int			signal;
+  unsigned long long int	u_tsize;
+  unsigned long long int	u_dsize;
+  unsigned long long int	u_ssize;
+  unsigned long long int	start_code;
+  unsigned long long int	start_stack;
+  long long int			signal;
   int				reserved;
   struct user_regs_struct*	u_ar0;
+# if __WORDSIZE == 32
+  unsigned int			pad0;
+# endif
   struct user_fpregs_struct*	u_fpstate;
-  unsigned long int		magic;
+# if __WORDSIZE == 32
+  unsigned int			pad1;
+# endif
+  unsigned long long int	magic;
   char				u_comm [32];
-  unsigned long int		u_debugreg [8];
+  unsigned long long int	u_debugreg [8];
 };
 
 #else
@@ -162,7 +168,7 @@ struct user
   char				u_comm [32];
   int				u_debugreg [8];
 };
-#endif  /* __WORDSIZE */
+#endif  /* __x86_64__ */
 
 #define PAGE_SHIFT		12
 #define PAGE_SIZE		(1UL << PAGE_SHIFT)
diff --git a/sysdeps/unix/sysv/linux/x86_64/sysdep.h b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
index 6436230..9f4105d 100644
--- a/sysdeps/unix/sysv/linux/x86_64/sysdep.h
+++ b/sysdeps/unix/sysv/linux/x86_64/sysdep.h
@@ -343,33 +343,33 @@
 /* We cannot use the thread descriptor because in ld.so we use setjmp
    earlier than the descriptor is initialized.  */
 # ifdef __ASSEMBLER__
-#  define PTR_MANGLE(reg)	xorq __pointer_chk_guard_local(%rip), reg;    \
-				rolq $17, reg
-#  define PTR_DEMANGLE(reg)	rorq $17, reg;				      \
-				xorq __pointer_chk_guard_local(%rip), reg
+#  define PTR_MANGLE(reg)	xor __pointer_chk_guard_local(%rip), reg;    \
+				rol $2*LP_SIZE+1, reg
+#  define PTR_DEMANGLE(reg)	ror $2*LP_SIZE+1, reg;			     \
+				xor __pointer_chk_guard_local(%rip), reg
 # else
-#  define PTR_MANGLE(reg)	asm ("xorq __pointer_chk_guard_local(%%rip), %0\n" \
-				     "rolq $17, %0"			      \
+#  define PTR_MANGLE(reg)	asm ("xor __pointer_chk_guard_local(%%rip), %0\n" \
+				     "rol $2*" LP_SIZE "+1, %0"			  \
 				     : "=r" (reg) : "0" (reg))
-#  define PTR_DEMANGLE(reg)	asm ("rorq $17, %0\n"			      \
-				     "xorq __pointer_chk_guard_local(%%rip), %0" \
+#  define PTR_DEMANGLE(reg)	asm ("ror $2*" LP_SIZE "+1, %0\n"		  \
+				     "xor __pointer_chk_guard_local(%%rip), %0"   \
 				     : "=r" (reg) : "0" (reg))
 # endif
 #else
 # ifdef __ASSEMBLER__
-#  define PTR_MANGLE(reg)	xorq %fs:POINTER_GUARD, reg;		      \
-				rolq $17, reg
-#  define PTR_DEMANGLE(reg)	rorq $17, reg;				      \
-				xorq %fs:POINTER_GUARD, reg
+#  define PTR_MANGLE(reg)	xor %fs:POINTER_GUARD, reg;		      \
+				rol $2*LP_SIZE+1, reg
+#  define PTR_DEMANGLE(reg)	ror $2*LP_SIZE+1, reg;			      \
+				xor %fs:POINTER_GUARD, reg
 # else
-#  define PTR_MANGLE(var)	asm ("xorq %%fs:%c2, %0\n"		      \
-				     "rolq $17, %0"			      \
+#  define PTR_MANGLE(var)	asm ("xor %%fs:%c2, %0\n"		      \
+				     "rol $2*" LP_SIZE "+1, %0"		      \
 				     : "=r" (var)			      \
 				     : "0" (var),			      \
 				       "i" (offsetof (tcbhead_t,	      \
 						      pointer_guard)))
-#  define PTR_DEMANGLE(var)	asm ("rorq $17, %0\n"			      \
-				     "xorq %%fs:%c2, %0"		      \
+#  define PTR_DEMANGLE(var)	asm ("ror $2*" LP_SIZE "+1, %0\n"	      \
+				     "xor %%fs:%c2, %0"			      \
 				     : "=r" (var)			      \
 				     : "0" (var),			      \
 				       "i" (offsetof (tcbhead_t,	      \
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/Implies b/sysdeps/unix/sysv/linux/x86_64/x32/Implies
new file mode 100644
index 0000000..8d91c80
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/Implies
@@ -0,0 +1 @@
+unix/sysv/linux/wordsize-64
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/Makefile b/sysdeps/unix/sysv/linux/x86_64/x32/Makefile
new file mode 100644
index 0000000..aa78238
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/Makefile
@@ -0,0 +1,7 @@
+ifeq ($(subdir),misc)
+sysdep_routines += arch_prctl
+endif
+
+ifeq ($(subdir),posix)
+sysdep_routines += getcpu sched_getcpu-static
+endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/alphasort.c b/sysdeps/unix/sysv/linux/x86_64/x32/alphasort.c
new file mode 100644
index 0000000..69ec427
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/alphasort.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/alphasort.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/alphasort64.c b/sysdeps/unix/sysv/linux/x86_64/x32/alphasort64.c
new file mode 100644
index 0000000..6c5b2a1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/alphasort64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/alphasort64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/arch_prctl.c b/sysdeps/unix/sysv/linux/x86_64/x32/arch_prctl.c
new file mode 100644
index 0000000..a4079af
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/arch_prctl.c
@@ -0,0 +1,64 @@
+/* arch_prctl call for Linux/x32.
+   Copyright (C) 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/prctl.h>
+#include <sys/syscall.h>
+#include <sysdep.h>
+
+/* Since x32 arch_prctl stores 32bit base address of segment register %fs
+   and %gs as unsigned 64bit value via ARCH_GET_FS and ARCH_GET_GS, we
+   use a local unsigned 64bit variable to hold the base address and copy
+   it to ADDR after arch_prctl return.  */
+
+int
+__arch_prctl (int code, unsigned long *addr)
+{
+  int res;
+  unsigned long long base_addr;
+  unsigned long *addr_saved;
+
+  switch (code)
+    {
+    case ARCH_GET_FS:
+    case ARCH_GET_GS:
+      addr_saved = addr;
+      addr = &base_addr;
+      break;
+
+    default:
+      break;
+    }
+
+  res = INLINE_SYSCALL (arch_prctl, 2, code, addr);
+  if (res == 0)
+    switch (code)
+      {
+      case ARCH_GET_FS:
+      case ARCH_GET_GS:
+	*addr_saved = (unsigned long) base_addr;
+	break;
+
+      default:
+	break;
+      }
+
+  return res;
+}
+
+weak_alias (__arch_prctl, arch_prctl);
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/dl-cache.h b/sysdeps/unix/sysv/linux/x86_64/x32/dl-cache.h
new file mode 100644
index 0000000..22a56d7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/dl-cache.h
@@ -0,0 +1,23 @@
+/* Support for reading /etc/ld.so.cache files written by Linux ldconfig.
+   Copyright (C) 20011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/unix/sysv/linux/x86_64/dl-cache.h>
+
+#undef _DL_CACHE_DEFAULT_ID
+#define _DL_CACHE_DEFAULT_ID	0x803
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/fallocate.c b/sysdeps/unix/sysv/linux/x86_64/x32/fallocate.c
new file mode 100644
index 0000000..3b849d5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/fallocate.c
@@ -0,0 +1,56 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+#undef LOAD_ARGS_3
+#define LOAD_ARGS_3(a1, a2, a3)				\
+  long long int __arg3 = (long long int) (a3);		\
+  LOAD_ARGS_2 (a1, a2)
+#undef LOAD_REGS_3
+#define LOAD_REGS_3					\
+  register long long int _a3 asm ("rdx") = __arg3;	\
+  LOAD_REGS_2
+
+#undef LOAD_ARGS_4
+#define LOAD_ARGS_4(a1, a2, a3, a4)			\
+  long long int __arg4 = (long long int) (a4);		\
+  LOAD_ARGS_3 (a1, a2, a3)
+#undef LOAD_REGS_4
+#define LOAD_REGS_4					\
+  register long long int _a4 asm ("r10") = __arg4;	\
+  LOAD_REGS_3
+
+/* Reserve storage for the data of the file associated with FD.  */
+int
+fallocate (int fd, int mode, __off_t offset, __off_t len)
+{
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (fallocate, 4, fd, mode, offset, len);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (fallocate, 4, fd, mode, offset, len);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+strong_alias (fallocate, fallocate64)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/fseeko.c b/sysdeps/unix/sysv/linux/x86_64/x32/fseeko.c
new file mode 100644
index 0000000..dc47698
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/fseeko.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/fseeko.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/fseeko64.c b/sysdeps/unix/sysv/linux/x86_64/x32/fseeko64.c
new file mode 100644
index 0000000..3e554ec
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/fseeko64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/fseeko64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/ftello.c b/sysdeps/unix/sysv/linux/x86_64/x32/ftello.c
new file mode 100644
index 0000000..735e3e1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/ftello.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/ftello.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/ftello64.c b/sysdeps/unix/sysv/linux/x86_64/x32/ftello64.c
new file mode 100644
index 0000000..eb155ed
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/ftello64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/ftello64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/ftw.c b/sysdeps/unix/sysv/linux/x86_64/x32/ftw.c
new file mode 100644
index 0000000..a21dfe5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/ftw.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/ftw.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/ftw64.c b/sysdeps/unix/sysv/linux/x86_64/x32/ftw64.c
new file mode 100644
index 0000000..3c025b7
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/ftw64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/ftw64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/getcpu.c b/sysdeps/unix/sysv/linux/x86_64/x32/getcpu.c
new file mode 100644
index 0000000..06c2722
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/getcpu.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef SHARED
+# include <dl-vdso.h>
+
+void *getcpu_ifunc (void) __asm__ ("__getcpu");
+
+void *
+getcpu_ifunc (void)
+{
+  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
+
+  return _dl_vdso_vsym ("__vdso_getcpu", &linux26);
+}
+__asm (".type __getcpu, %gnu_indirect_function");
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/getdents.c b/sysdeps/unix/sysv/linux/x86_64/x32/getdents.c
new file mode 100644
index 0000000..7634853
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/getdents.c
@@ -0,0 +1,161 @@
+/* Copyright (C) 2011
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <alloca.h>
+#include <errno.h>
+#include <dirent.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <bp-checks.h>
+
+/* For Linux we need a special version of this file since the
+   definition of `struct dirent' is not the same for the kernel and
+   the libc.  There is one additional field which might be introduced
+   in the kernel structure in the future.
+
+   Here is the kernel definition of `struct dirent64' as of 2.1.20:  */
+
+struct kernel_dirent64
+  {
+    uint64_t		d_ino;
+    int64_t		d_off;
+    unsigned short int	d_reclen;
+    unsigned char	d_type;
+    char		d_name[256];
+  };
+
+#ifndef __GETDENTS
+# define __GETDENTS __getdents
+#endif
+#ifndef DIRENT_TYPE
+# define DIRENT_TYPE struct dirent
+#endif
+#ifndef DIRENT_SET_DP_INO
+# define DIRENT_SET_DP_INO(dp, value) (dp)->d_ino = (value)
+#endif
+
+/* The problem here is that we cannot simply read the next NBYTES
+   bytes.  We need to take the additional field into account.  We use
+   some heuristic.  Assuming the directory contains names with 14
+   characters on average we can compute an estimated number of entries
+   which fit in the buffer.  Taking this number allows us to specify a
+   reasonable number of bytes to read.  If we should be wrong, we can
+   reset the file descriptor.  In practice the kernel is limiting the
+   amount of data returned much more then the reduced buffer size.  */
+ssize_t
+internal_function
+__GETDENTS (int fd, char *buf, size_t nbytes)
+{
+  ssize_t retval;
+  off64_t last_offset = -1;
+  union
+    {
+      struct kernel_dirent64 k;
+      DIRENT_TYPE u;
+      char b[1];
+    } *kbuf = (void *) buf, *outp, *inp;
+  size_t kbytes = nbytes;
+  if (offsetof (DIRENT_TYPE, d_name)
+      < offsetof (struct kernel_dirent64, d_name)
+      && nbytes <= sizeof (DIRENT_TYPE))
+    {
+      kbytes = nbytes + offsetof (struct kernel_dirent64, d_name)
+	- offsetof (DIRENT_TYPE, d_name);
+      kbuf = __alloca(kbytes);
+    }
+  retval = INLINE_SYSCALL (getdents64, 3, fd, CHECK_N(kbuf, kbytes),
+			   kbytes);
+  const size_t size_diff = (offsetof (struct kernel_dirent64, d_name)
+			    - offsetof (DIRENT_TYPE, d_name));
+
+  /* Return the error if encountered.  */
+  if (retval == -1)
+    return -1;
+
+  /* If the structure returned by the kernel is identical to what we
+     need, don't do any conversions.  */
+  if (offsetof (DIRENT_TYPE, d_name)
+      == offsetof (struct kernel_dirent64, d_name)
+      && sizeof (outp->u.d_ino) == sizeof (inp->k.d_ino)
+      && sizeof (outp->u.d_off) == sizeof (inp->k.d_off))
+    return retval;
+
+  /* These two pointers might alias the same memory buffer.
+     Standard C requires that we always use the same type for them,
+     so we must use the union type.  */
+  inp = kbuf;
+  outp = (void *) buf;
+
+  while (&inp->b < &kbuf->b + retval)
+    {
+      const size_t alignment = __alignof__ (DIRENT_TYPE);
+      /* Since inp->k.d_reclen is already aligned for the kernel
+	 structure this may compute a value that is bigger
+	 than necessary.  */
+      size_t old_reclen = inp->k.d_reclen;
+      size_t new_reclen = ((old_reclen - size_diff + alignment - 1)
+			   & ~(alignment - 1));
+
+      /* Copy the data out of the old structure into temporary space.
+	 Then copy the name, which may overlap if BUF == KBUF.  */
+      const uint64_t d_ino = inp->k.d_ino;
+      const int64_t d_off = inp->k.d_off;
+      const uint8_t d_type = inp->k.d_type;
+
+      memmove (outp->u.d_name, inp->k.d_name,
+	       old_reclen - offsetof (struct kernel_dirent64, d_name));
+
+      /* Now we have copied the data from INP and access only OUTP.  */
+
+      DIRENT_SET_DP_INO (&outp->u, d_ino);
+      outp->u.d_off = d_off;
+      if ((sizeof (outp->u.d_ino) != sizeof (inp->k.d_ino)
+	   && outp->u.d_ino != d_ino)
+	  || (sizeof (outp->u.d_off) != sizeof (inp->k.d_off)
+	      && outp->u.d_off != d_off))
+	{
+	  /* Overflow.  If there was at least one entry
+	     before this one, return them without error,
+	     otherwise signal overflow.  */
+	  if (last_offset != -1)
+	    {
+	      __lseek64 (fd, last_offset, SEEK_SET);
+	      return outp->b - buf;
+	    }
+	  __set_errno (EOVERFLOW);
+	  return -1;
+	}
+
+      last_offset = d_off;
+      outp->u.d_reclen = new_reclen;
+      outp->u.d_type = d_type;
+
+      inp = (void *) inp + old_reclen;
+      outp = (void *) outp + new_reclen;
+    }
+
+  return outp->b - buf;
+}
+
+#undef __getdents64
+weak_alias (__getdents, __getdents64);
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/gettimeofday.c b/sysdeps/unix/sysv/linux/x86_64/x32/gettimeofday.c
new file mode 100644
index 0000000..e998e14
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/gettimeofday.c
@@ -0,0 +1,45 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef SHARED
+# include <dl-vdso.h>
+
+void *gettimeofday_ifunc (void) __asm__ ("__gettimeofday");
+
+void *
+gettimeofday_ifunc (void)
+{
+  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
+
+  return _dl_vdso_vsym ("__vdso_gettimeofday", &linux26);
+}
+__asm (".type __gettimeofday, %gnu_indirect_function");
+#else
+# include <errno.h>
+# include <sysdep.h>
+# include <sys/time.h>
+
+int
+__gettimeofday (struct timeval *tv, struct timezone *tz)
+{
+  return INLINE_SYSCALL (gettimeofday, 2, tv, tz);
+}
+#endif
+
+weak_alias (__gettimeofday, gettimeofday)
+strong_alias (__gettimeofday, __gettimeofday_internal)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/glob.c b/sysdeps/unix/sysv/linux/x86_64/x32/glob.c
new file mode 100644
index 0000000..e542747
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/glob.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/glob.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/init-first.c b/sysdeps/unix/sysv/linux/x86_64/x32/init-first.c
new file mode 100644
index 0000000..f0aa8c8
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/init-first.c
@@ -0,0 +1,40 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef SHARED
+# include <dl-vdso.h>
+# include <bits/libc-vdso.h>
+
+long int (*__vdso_clock_gettime) (clockid_t, struct timespec *)
+  __attribute__ ((nocommon));
+strong_alias (__vdso_clock_gettime, __GI___vdso_clock_gettime attribute_hidden)
+
+static inline void
+_libc_vdso_platform_setup (void)
+{
+  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
+
+  void *p = _dl_vdso_vsym ("__vdso_clock_gettime", &linux26);
+  PTR_MANGLE (p);
+  __GI___vdso_clock_gettime = p;
+}
+
+# define VDSO_SETUP _libc_vdso_platform_setup
+#endif
+
+#include "../../init-first.c"
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos.c
new file mode 100644
index 0000000..de2ff01
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofgetpos.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos64.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos64.c
new file mode 100644
index 0000000..34aabfc
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofgetpos64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofgetpos64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofopen.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofopen.c
new file mode 100644
index 0000000..e39bb55
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofopen.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofopen.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofopen64.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofopen64.c
new file mode 100644
index 0000000..af0c6ae
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofopen64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofopen64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos.c
new file mode 100644
index 0000000..a4c99c9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofsetpos.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos64.c b/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos64.c
new file mode 100644
index 0000000..e83fbba
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/iofsetpos64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/iofsetpos64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/llseek.S b/sysdeps/unix/sysv/linux/x86_64/x32/llseek.S
new file mode 100644
index 0000000..5084d0e
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/llseek.S
@@ -0,0 +1 @@
+/* No llseek for x32.  */
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/lockf.c b/sysdeps/unix/sysv/linux/x86_64/x32/lockf.c
new file mode 100644
index 0000000..42306a0
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/lockf.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/lockf.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/lockf64.c b/sysdeps/unix/sysv/linux/x86_64/x32/lockf64.c
new file mode 100644
index 0000000..3b4b55a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/lockf64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/lockf64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/lseek.S b/sysdeps/unix/sysv/linux/x86_64/x32/lseek.S
new file mode 100644
index 0000000..ca33fd1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/lseek.S
@@ -0,0 +1,33 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define SYSCALL_RETURN_INT64
+#include <sysdep.h>
+
+#define SYSCALL_NAME lseek
+#define SYSCALL_NARGS 3
+#define SYSCALL_SYMBOL __libc_lseek64
+#define SYSCALL_CANCELLABLE 1
+#include <syscall-template.S>
+weak_alias (__libc_lseek64, __lseek64)
+libc_hidden_weak (__lseek64)
+weak_alias (__libc_lseek64, lseek64)
+libc_hidden_weak (lseek64)
+weak_alias (__libc_lseek64, __lseek)
+libc_hidden_weak (__lseek)
+weak_alias (__libc_lseek64, lseek)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp.c b/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp.c
new file mode 100644
index 0000000..177f68a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/mkostemp.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp64.c b/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp64.c
new file mode 100644
index 0000000..68455a8
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/mkostemp64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/mkostemp64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp.c b/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp.c
new file mode 100644
index 0000000..4bc129b
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/mkstemp.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp64.c b/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp64.c
new file mode 100644
index 0000000..76a8363
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/mkstemp64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/mkstemp64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/posix_fadvise.c b/sysdeps/unix/sysv/linux/x86_64/x32/posix_fadvise.c
new file mode 100644
index 0000000..b56b1b9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/posix_fadvise.c
@@ -0,0 +1,53 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+#undef LOAD_ARGS_2
+#define LOAD_ARGS_2(a1, a2)				\
+  long long int __arg2 = (long long int) (a2);		\
+  LOAD_ARGS_1 (a1)
+#undef LOAD_REGS_2
+#define LOAD_REGS_2					\
+  register long long int _a2 asm ("rsi") = __arg2;	\
+  LOAD_REGS_1
+
+#undef LOAD_ARGS_3
+#define LOAD_ARGS_3(a1, a2, a3)				\
+  long long int __arg3 = (long long int) (a3);		\
+  LOAD_ARGS_2 (a1, a2)
+#undef LOAD_REGS_3
+#define LOAD_REGS_3					\
+  register long long int _a3 asm ("rdx") = __arg3;	\
+  LOAD_REGS_2
+
+/* Advice the system about the expected behaviour of the application with
+   respect to the file associated with FD.  */
+
+int
+posix_fadvise (int fd, off_t offset, off_t len, int advise)
+{
+  INTERNAL_SYSCALL_DECL (err);
+  int ret = INTERNAL_SYSCALL (fadvise64, err, 4, fd, offset, len, advise);
+  if (INTERNAL_SYSCALL_ERROR_P (ret, err))
+    return INTERNAL_SYSCALL_ERRNO (ret, err);
+  return 0;
+}
+strong_alias (posix_fadvise, posix_fadvise64)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/posix_fallocate.c b/sysdeps/unix/sysv/linux/x86_64/x32/posix_fallocate.c
new file mode 100644
index 0000000..80d4de1
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/posix_fallocate.c
@@ -0,0 +1,59 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fcntl.h>
+#include <sysdep.h>
+
+#define posix_fallocate static internal_fallocate
+#include <sysdeps/posix/posix_fallocate.c>
+#undef posix_fallocate
+
+#undef LOAD_ARGS_2
+#define LOAD_ARGS_2(a1, a2)				\
+  long long int __arg2 = (long long int) (a2);		\
+  LOAD_ARGS_1 (a1)
+#undef LOAD_REGS_2
+#define LOAD_REGS_2					\
+  register long long int _a2 asm ("rsi") = __arg2;	\
+  LOAD_REGS_1
+
+#undef LOAD_ARGS_3
+#define LOAD_ARGS_3(a1, a2, a3)				\
+  long long int __arg3 = (long long int) (a3);		\
+  LOAD_ARGS_2 (a1, a2)
+#undef LOAD_REGS_3
+#define LOAD_REGS_3					\
+  register long long int _a3 asm ("rdx") = __arg3;	\
+  LOAD_REGS_2
+
+/* Reserve storage for the data of the file associated with FD.  */
+int
+posix_fallocate (int fd, __off_t offset, __off_t len)
+{
+  INTERNAL_SYSCALL_DECL (err);
+  int res = INTERNAL_SYSCALL (fallocate, err, 4, fd, 0, offset, len);
+
+  if (! INTERNAL_SYSCALL_ERROR_P (res, err))
+    return 0;
+
+  if (INTERNAL_SYSCALL_ERRNO (res, err) != EOPNOTSUPP)
+    return INTERNAL_SYSCALL_ERRNO (res, err);
+
+  return internal_fallocate (fd, offset, len);
+}
+strong_alias (posix_fallocate, posix_fallocate64)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/preadv.c b/sysdeps/unix/sysv/linux/x86_64/x32/preadv.c
new file mode 100644
index 0000000..7399dd3
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/preadv.c
@@ -0,0 +1,49 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#define preadv64 __redirect_preadv64
+#include <sys/uio.h>
+#include <sysdep-cancel.h>
+
+#undef LOAD_ARGS_4
+#define LOAD_ARGS_4(a1, a2, a3, a4)			\
+  long long int __arg4 = (long long int) (a4);		\
+  LOAD_ARGS_3 (a1, a2, a3)
+#undef LOAD_REGS_4
+#define LOAD_REGS_4					\
+  register long long int _a4 asm ("r10") = __arg4;	\
+  LOAD_REGS_3
+
+ssize_t
+preadv (int fd, const struct iovec *vector, int count, off_t offset)
+{
+  ssize_t result;
+  if (SINGLE_THREAD_P)
+    result = INLINE_SYSCALL (preadv, 4, fd, vector, count, offset);
+  else
+    {
+      int oldtype = LIBC_CANCEL_ASYNC ();
+      result = INLINE_SYSCALL (preadv, 4, fd, vector, count, offset);
+      LIBC_CANCEL_RESET (oldtype);
+    }
+  return result;
+}
+#undef preadv64
+strong_alias (preadv, preadv64)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/pselect.c b/sysdeps/unix/sysv/linux/x86_64/x32/pselect.c
new file mode 100644
index 0000000..01a0a91
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/pselect.c
@@ -0,0 +1,70 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <time.h>
+#include <sys/poll.h>
+#include <sysdep-cancel.h>
+
+
+int
+__pselect (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,
+	   const struct timespec *timeout, const sigset_t *sigmask)
+{
+  /* The Linux kernel can in some situations update the timeout value.
+     We do not want that so use a local variable.  */
+  struct timespec tval;
+  if (timeout != NULL)
+    {
+      tval = *timeout;
+      timeout = &tval;
+    }
+
+  /* Note: the system call expects 7 values but on most architectures
+     we can only pass in 6 directly.  If there is an architecture with
+     support for more parameters a new version of this file needs to
+     be created.  */
+  struct
+  {
+    const sigset_t *ss;
+    unsigned long long ss_len;
+  } data;
+
+  data.ss = sigmask;
+  data.ss_len = _NSIG / 8;
+
+  int result;
+
+  if (SINGLE_THREAD_P)
+    result = INLINE_SYSCALL (pselect6, 6, nfds, readfds, writefds,
+			     exceptfds, timeout, &data);
+  else
+    {
+      int oldtype = LIBC_CANCEL_ASYNC ();
+
+      result = INLINE_SYSCALL (pselect6, 6, nfds, readfds, writefds,
+			       exceptfds, timeout, &data);
+
+      LIBC_CANCEL_RESET (oldtype);
+    }
+
+  return result;
+}
+weak_alias (__pselect, pselect)
+strong_alias (__pselect, __libc_pselect)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/pwritev.c b/sysdeps/unix/sysv/linux/x86_64/x32/pwritev.c
new file mode 100644
index 0000000..5aaa400
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/pwritev.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sysdep.h>
+/* Hide the pwritev64 declaration.  */
+#define pwritev64 __redirect_pwritev64
+#include <sys/uio.h>
+#include <sysdep-cancel.h>
+
+#undef LOAD_ARGS_4
+#define LOAD_ARGS_4(a1, a2, a3, a4)			\
+  long long int __arg4 = (long long int) (a4);		\
+  LOAD_ARGS_3 (a1, a2, a3)
+#undef LOAD_REGS_4
+#define LOAD_REGS_4					\
+  register long long int _a4 asm ("r10") = __arg4;	\
+  LOAD_REGS_3
+
+ssize_t
+pwritev (int fd, const struct iovec *vector, int count, off_t offset)
+{
+  ssize_t result;
+  if (SINGLE_THREAD_P)
+    result = INLINE_SYSCALL (pwritev, 4, fd, vector, count, offset);
+  else
+    {
+      int oldtype = LIBC_CANCEL_ASYNC ();
+      result = INLINE_SYSCALL (pwritev, 4, fd, vector, count, offset);
+      LIBC_CANCEL_RESET (oldtype);
+    }
+  return result;
+}
+#undef pwritev64
+strong_alias (pwritev, pwritev64)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/scandir.c b/sysdeps/unix/sysv/linux/x86_64/x32/scandir.c
new file mode 100644
index 0000000..9288ca2
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/scandir.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/scandir.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/scandir64.c b/sysdeps/unix/sysv/linux/x86_64/x32/scandir64.c
new file mode 100644
index 0000000..6d22057
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/scandir64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/scandir64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/scandirat.c b/sysdeps/unix/sysv/linux/x86_64/x32/scandirat.c
new file mode 100644
index 0000000..5b88993
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/scandirat.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/scandirat.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/scandirat64.c b/sysdeps/unix/sysv/linux/x86_64/x32/scandirat64.c
new file mode 100644
index 0000000..0d7893d
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/scandirat64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/scandirat64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu-static.c b/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu-static.c
new file mode 100644
index 0000000..38bbf9a
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu-static.c
@@ -0,0 +1,3 @@
+#ifndef SHARED
+#include "../../sched_getcpu.c"
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu.S b/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu.S
new file mode 100644
index 0000000..a4040ef
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/sched_getcpu.S
@@ -0,0 +1,47 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef SHARED
+#include <sysdep.h>
+#include <tls.h>
+#define _ERRNO_H	1
+#include <bits/errno.h>
+
+ENTRY (sched_getcpu)
+	/* Align stack and create local variable for result.  */
+	sub	$0x8, %esp
+	cfi_adjust_cfa_offset(8)
+
+	mov	%esp, %edi
+	xor	%esi, %esi
+	mov	$VGETCPU_CACHE_OFFSET, %edx
+	add	%fs:0, %edx
+
+	call	__getcpu@PLT
+
+	cmp	$-4095, %eax
+	jae	SYSCALL_ERROR_LABEL
+
+	mov	(%rsp), %eax
+
+L(pseudo_end):
+	add	$0x8, %esp
+	cfi_adjust_cfa_offset(-8)
+	ret
+PSEUDO_END(sched_getcpu)
+#endif
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/sendfile64.c b/sysdeps/unix/sysv/linux/x86_64/x32/sendfile64.c
new file mode 100644
index 0000000..4c451bd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/sendfile64.c
@@ -0,0 +1 @@
+/* sendfile64 is alias of sendfile syscall.  */
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/syscalls.list b/sysdeps/unix/sysv/linux/x86_64/x32/syscalls.list
new file mode 100644
index 0000000..7edb6fd
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/syscalls.list
@@ -0,0 +1,6 @@
+# File name	Caller	Syscall name	# args	Strong name	Weak names
+
+fallocate	-	fallocate	Ci:iiii	fallocate	fallocate64
+posix_fadvise	-	fadvise64	Vi:iiii	posix_fadvise	posix_fadvise64
+preadv		-	preadv		Ci:ipii	preadv		preadv64
+pwritev		-	pwritev		Ci:ipii	pwritev		pwritev64
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/sysctl.c b/sysdeps/unix/sysv/linux/x86_64/x32/sysctl.c
new file mode 100644
index 0000000..634c289
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/sysctl.c
@@ -0,0 +1 @@
+/* X32 doesn't have _sysctl.  */
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/sysdep.h b/sysdeps/unix/sysv/linux/x86_64/x32/sysdep.h
new file mode 100644
index 0000000..15b67b4
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/sysdep.h
@@ -0,0 +1,60 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LINUX_X32_SYSDEP_H
+#define _LINUX_X32_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/sysv/linux/x86_64/sysdep.h>
+#include <sysdeps/x86_64/x32/sysdep.h>
+
+#ifdef __ASSEMBLER__
+
+# ifdef SYSCALL_RETURN_INT64
+#  define SYSCALL_SET_ERROR_RETURN orq $-1, %rax
+# else
+#  define SYSCALL_SET_ERROR_RETURN orl $-1, %eax
+# endif
+
+# ifndef PIC
+/* Nothing here.  */
+# elif RTLD_PRIVATE_ERRNO
+#  undef SYSCALL_ERROR_HANDLER
+#  define SYSCALL_ERROR_HANDLER			\
+0:						\
+  lea rtld_errno(%rip), %ecx;			\
+  xorl %edx, %edx;				\
+  subl %eax, %edx;				\
+  movl %edx, (%rcx);				\
+  SYSCALL_SET_ERROR_RETURN;			\
+  jmp L(pseudo_end);
+# else
+#  undef SYSCALL_ERROR_HANDLER
+#  define SYSCALL_ERROR_HANDLER			\
+0:						\
+  movq SYSCALL_ERROR_ERRNO@GOTTPOFF(%rip), %rcx;\
+  xorl %edx, %edx;				\
+  subl %eax, %edx;				\
+  movl %edx, %fs:(%rcx);			\
+  SYSCALL_SET_ERROR_RETURN;			\
+  jmp L(pseudo_end);
+# endif	/* PIC */
+
+#endif	/* __ASSEMBLER__ */
+
+#endif /* linux/x86_64/x32/sysdep.h */
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/time.c b/sysdeps/unix/sysv/linux/x86_64/x32/time.c
new file mode 100644
index 0000000..086cb01
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/time.c
@@ -0,0 +1,77 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#include <time.h>
+
+# undef INLINE_SYSCALL
+# define INLINE_SYSCALL(name, nr, args...) \
+  ({									      \
+    unsigned long long int resultvar = INTERNAL_SYSCALL (name, , nr, args);   \
+    if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))	      \
+      {									      \
+	__set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		      \
+	resultvar = (unsigned long long int) -1LL;			      \
+      }									      \
+    (long long int) resultvar; })
+
+# undef INTERNAL_SYSCALL_NCS
+# define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
+  ({									      \
+    unsigned long long int resultvar;					      \
+    LOAD_ARGS_##nr (args)						      \
+    LOAD_REGS_##nr							      \
+    asm volatile (							      \
+    "syscall\n\t"							      \
+    : "=a" (resultvar)							      \
+    : "0" (name) ASM_ARGS_##nr : "memory", "cc", "r11", "cx");		      \
+    (long long int) resultvar; })
+
+# undef INTERNAL_SYSCALL_ERROR_P
+# define INTERNAL_SYSCALL_ERROR_P(val, err) \
+  ((unsigned long long int) (long long int) (val) >= -4095LL)
+
+#ifdef SHARED
+# include <dl-vdso.h>
+
+void *time_ifunc (void) __asm__ ("__GI_time");
+
+static time_t
+time_syscall (time_t *t)
+{
+  return INLINE_SYSCALL (time, 1, t);
+}
+
+void *
+time_ifunc (void)
+{
+  PREPARE_VERSION (linux26, "LINUX_2.6", 61765110);
+
+  return _dl_vdso_vsym ("__vdso_time", &linux26) ?: (void *) time_syscall;
+}
+__asm (".type __GI_time, %gnu_indirect_function");
+#else
+time_t
+time (time_t *t)
+{
+  return INLINE_SYSCALL (time, 1, t);
+}
+#endif
+
+libc_hidden_def (time)
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile.c b/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile.c
new file mode 100644
index 0000000..f24f361
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/tmpfile.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile64.c b/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile64.c
new file mode 100644
index 0000000..55feef2
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/tmpfile64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/tmpfile64.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/versionsort.c b/sysdeps/unix/sysv/linux/x86_64/x32/versionsort.c
new file mode 100644
index 0000000..af5a668
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/versionsort.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/versionsort.c>
diff --git a/sysdeps/unix/sysv/linux/x86_64/x32/versionsort64.c b/sysdeps/unix/sysv/linux/x86_64/x32/versionsort64.c
new file mode 100644
index 0000000..fe220c9
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/x86_64/x32/versionsort64.c
@@ -0,0 +1 @@
+#include <sysdeps/wordsize-64/versionsort64.c>
diff --git a/sysdeps/x86_64/64/Implies b/sysdeps/x86_64/64/Implies
new file mode 100644
index 0000000..8ec4217
--- /dev/null
+++ b/sysdeps/x86_64/64/Implies
@@ -0,0 +1,6 @@
+x86_64/fpu
+wordsize-64
+ieee754/ldbl-96
+ieee754/dbl-64/wordsize-64
+ieee754/dbl-64
+ieee754/flt-32
diff --git a/sysdeps/x86_64/64/bits/wordsize.h b/sysdeps/x86_64/64/bits/wordsize.h
new file mode 100644
index 0000000..9b38756
--- /dev/null
+++ b/sysdeps/x86_64/64/bits/wordsize.h
@@ -0,0 +1,8 @@
+/* Determine the wordsize from the preprocessor defines.  */
+
+#if defined __x86_64__ && !defined __ILP32__
+# define __WORDSIZE	64
+# define __WORDSIZE_COMPAT32	1
+#else
+# define __WORDSIZE	32
+#endif
diff --git a/sysdeps/x86_64/64/shlib-versions b/sysdeps/x86_64/64/shlib-versions
new file mode 100644
index 0000000..f793bda
--- /dev/null
+++ b/sysdeps/x86_64/64/shlib-versions
@@ -0,0 +1,2 @@
+x86_64-.*-linux.*       DEFAULT			GLIBC_2.2.5
+x86_64-.*-linux.*	ld=ld-linux-x86-64.so.2	GLIBC_2.2.5
diff --git a/sysdeps/x86_64/Implies b/sysdeps/x86_64/Implies
deleted file mode 100644
index 2e0a323..0000000
--- a/sysdeps/x86_64/Implies
+++ /dev/null
@@ -1,5 +0,0 @@
-wordsize-64
-ieee754/ldbl-96
-ieee754/dbl-64/wordsize-64
-ieee754/dbl-64
-ieee754/flt-32
diff --git a/sysdeps/x86_64/__longjmp.S b/sysdeps/x86_64/__longjmp.S
index b045c04..a88ff07 100644
--- a/sysdeps/x86_64/__longjmp.S
+++ b/sysdeps/x86_64/__longjmp.S
@@ -30,9 +30,8 @@ ENTRY(__longjmp)
 	movq (JB_RBP*8)(%rdi),%r9
 	movq (JB_PC*8)(%rdi),%rdx
 #ifdef PTR_DEMANGLE
-	PTR_DEMANGLE (%r8)
-	PTR_DEMANGLE (%r9)
-	PTR_DEMANGLE (%rdx)
+	PTR_DEMANGLE (%R8_LP)
+	PTR_DEMANGLE (%RDX_LP)
 #endif
 	/* We add unwind information for the target here.  */
 	cfi_def_cfa(%rdi, 0)
@@ -51,7 +50,7 @@ ENTRY(__longjmp)
 	movq (JB_R15*8)(%rdi),%r15
 	/* Set return value for setjmp.  */
 	mov %esi, %eax
-	movq %r8,%rsp
+	mov %R8_LP,%RSP_LP
 	movq %r9,%rbp
 	jmpq *%rdx
 END (__longjmp)
diff --git a/sysdeps/x86_64/bits/atomic.h b/sysdeps/x86_64/bits/atomic.h
index 7c138eb..e5cd5c1 100644
--- a/sysdeps/x86_64/bits/atomic.h
+++ b/sysdeps/x86_64/bits/atomic.h
@@ -87,8 +87,8 @@ typedef uintmax_t uatomic_max_t;
   ({ __typeof (*mem) ret;						      \
      __asm __volatile (LOCK_PREFIX "cmpxchgq %q2, %1"			      \
 		       : "=a" (ret), "=m" (*mem)			      \
-		       : "r" ((long int) (newval)), "m" (*mem),		      \
-			 "0" ((long int) (oldval)));			      \
+		       : "r" ((long long int) (newval)), "m" (*mem),	      \
+			 "0" ((long long int) (oldval)));		      \
      ret; })
 #endif
 
@@ -133,8 +133,8 @@ typedef uintmax_t uatomic_max_t;
 		       "lock\n"						      \
 		       "0:\tcmpxchgq %q2, %1"				      \
 		       : "=a" (ret), "=m" (*mem)			      \
-		       : "q" ((long int) (newval)), "m" (*mem),		      \
-			 "0" ((long int)oldval),			      \
+		       : "q" ((atomic64_t) (newval)), "m" (*mem),	      \
+			 "0" ((atomic64_t) (oldval)),		      \
 			 "i" (offsetof (tcbhead_t, multiple_threads)));	      \
      ret; })
 
@@ -157,7 +157,7 @@ typedef uintmax_t uatomic_max_t;
      else								      \
        __asm __volatile ("xchgq %q0, %1"				      \
 			 : "=r" (result), "=m" (*mem)			      \
-			 : "0" ((long) (newvalue)), "m" (*mem));	      \
+			 : "0" ((atomic64_t) (newvalue)), "m" (*mem));	      \
      result; })
 
 
@@ -181,7 +181,7 @@ typedef uintmax_t uatomic_max_t;
      else								      \
        __asm __volatile (lock "xaddq %q0, %1"				      \
 			 : "=r" (result), "=m" (*mem)			      \
-			 : "0" ((long) (value)), "m" (*mem),		      \
+			 : "0" ((atomic64_t) (value)), "m" (*mem),	      \
 			   "i" (offsetof (tcbhead_t, multiple_threads)));     \
      result; })
 
@@ -224,7 +224,7 @@ typedef uintmax_t uatomic_max_t;
     else								      \
       __asm __volatile (lock "addq %q1, %0"				      \
 			: "=m" (*mem)					      \
-			: "ir" ((long) (value)), "m" (*mem),		      \
+			: "ir" ((atomic64_t) (value)), "m" (*mem),	      \
 			  "i" (offsetof (tcbhead_t, multiple_threads)));      \
   } while (0)
 
@@ -255,7 +255,7 @@ typedef uintmax_t uatomic_max_t;
      else								      \
        __asm __volatile (LOCK_PREFIX "addq %q2, %0; sets %1"		      \
 			 : "=m" (*mem), "=qm" (__result)		      \
-			 : "ir" ((long) (value)), "m" (*mem));		      \
+			 : "ir" ((atomic64_t) (value)), "m" (*mem));	      \
      __result; })
 
 
@@ -276,7 +276,7 @@ typedef uintmax_t uatomic_max_t;
      else								      \
        __asm __volatile (LOCK_PREFIX "addq %q2, %0; setz %1"		      \
 			 : "=m" (*mem), "=qm" (__result)		      \
-			 : "ir" ((long) (value)), "m" (*mem));		      \
+			 : "ir" ((atomic64_t) (value)), "m" (*mem));	      \
      __result; })
 
 
diff --git a/sysdeps/x86_64/bits/byteswap.h b/sysdeps/x86_64/bits/byteswap.h
index c6db93c..98767e4 100644
--- a/sysdeps/x86_64/bits/byteswap.h
+++ b/sysdeps/x86_64/bits/byteswap.h
@@ -25,6 +25,7 @@
 #ifndef _BITS_BYTESWAP_H
 #define _BITS_BYTESWAP_H 1
 
+#include <features.h>
 #include <bits/wordsize.h>
 
 /* Swap bytes in 16 bit value.  */
@@ -57,38 +58,8 @@
      ((((x) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >>  8) |		      \
       (((x) & 0x0000ff00) <<  8) | (((x) & 0x000000ff) << 24))
 
-#if defined __GNUC__ && __GNUC__ >= 2
-# if __WORDSIZE == 64 || (defined __i486__ || defined __pentium__	      \
-			  || defined __pentiumpro__ || defined __pentium4__   \
-			  || defined __k8__ || defined __athlon__	      \
-			  || defined __k6__ || defined __nocona__	      \
-			  || defined __core2__ || defined __geode__	      \
-			  || defined __amdfam10__)
-/* To swap the bytes in a word the i486 processors and up provide the
-   `bswap' opcode.  On i386 we have to use three instructions.  */
-#  define __bswap_32(x) \
-     (__extension__							      \
-      ({ register unsigned int __v, __x = (x);				      \
-	 if (__builtin_constant_p (__x))				      \
-	   __v = __bswap_constant_32 (__x);				      \
-	 else								      \
-	   __asm__ ("bswap %0" : "=r" (__v) : "0" (__x));		      \
-	 __v; }))
-# else
-#  define __bswap_32(x)							      \
-     (__extension__							      \
-      ({ register unsigned int __v, __x = (x);				      \
-	 if (__builtin_constant_p (__x))				      \
-	   __v = __bswap_constant_32 (__x);				      \
-	 else								      \
-	   __asm__ ("rorw $8, %w0;"					      \
-		    "rorl $16, %0;"					      \
-		    "rorw $8, %w0"					      \
-		    : "=r" (__v)					      \
-		    : "0" (__x)						      \
-		    : "cc");						      \
-	 __v; }))
-# endif
+#if __GNUC_PREREQ (4,2)
+# define __bswap_32(x)  __builtin_bswap32 (x)
 #else
 # define __bswap_32(x) \
      (__extension__							      \
@@ -98,7 +69,10 @@
 
 #if defined __GNUC__ && __GNUC__ >= 2
 /* Swap bytes in 64 bit value.  */
-# define __bswap_constant_64(x) \
+# if __GNUC_PREREQ (4,2)
+#  define __bswap_64(x)  __builtin_bswap64 (x)
+# else
+#  define __bswap_constant_64(x) \
      (__extension__ ((((x) & 0xff00000000000000ull) >> 56)		      \
 		     | (((x) & 0x00ff000000000000ull) >> 40)		      \
 		     | (((x) & 0x0000ff0000000000ull) >> 24)		      \
@@ -108,8 +82,8 @@
 		     | (((x) & 0x000000000000ff00ull) << 40)		      \
 		     | (((x) & 0x00000000000000ffull) << 56)))
 
-# if __WORDSIZE == 64
-#  define __bswap_64(x) \
+#  if __WORDSIZE == 64
+#   define __bswap_64(x) \
      (__extension__							      \
       ({ register unsigned long __v, __x = (x);				      \
 	 if (__builtin_constant_p (__x))				      \
@@ -117,8 +91,8 @@
 	 else								      \
 	   __asm__ ("bswap %q0" : "=r" (__v) : "0" (__x));		      \
 	 __v; }))
-# else
-#  define __bswap_64(x) \
+#  else
+#   define __bswap_64(x) \
      (__extension__                                                           \
       ({ union { __extension__ unsigned long long int __ll;                   \
 		 unsigned int __l[2]; } __w, __r;                             \
@@ -131,6 +105,7 @@
 	     __r.__l[1] = __bswap_32 (__w.__l[0]);                            \
 	   }                                                                  \
 	 __r.__ll; }))
+#  endif
 # endif
 #endif
 
diff --git a/sysdeps/x86_64/bits/link.h b/sysdeps/x86_64/bits/link.h
index 14cc92b..df32930 100644
--- a/sysdeps/x86_64/bits/link.h
+++ b/sysdeps/x86_64/bits/link.h
@@ -21,7 +21,7 @@
 #endif
 
 
-#if __ELF_NATIVE_CLASS == 32
+#ifndef __x86_64__
 /* Registers for entry into PLT on IA-32.  */
 typedef struct La_i86_regs
 {
@@ -125,6 +125,22 @@ extern unsigned int la_x86_64_gnu_pltexit (Elf64_Sym *__sym,
 					   La_x86_64_retval *__outregs,
 					   const char *__symname);
 
+extern Elf32_Addr la_x32_gnu_pltenter (Elf32_Sym *__sym,
+				       unsigned int __ndx,
+				       uintptr_t *__refcook,
+				       uintptr_t *__defcook,
+				       La_x86_64_regs *__regs,
+				       unsigned int *__flags,
+				       const char *__symname,
+				       long int *__framesizep);
+extern unsigned int la_x32_gnu_pltexit (Elf32_Sym *__sym,
+					unsigned int __ndx,
+					uintptr_t *__refcook,
+					uintptr_t *__defcook,
+					const La_x86_64_regs *__inregs,
+					La_x86_64_retval *__outregs,
+					const char *__symname);
+
 __END_DECLS
 
 #endif
diff --git a/sysdeps/x86_64/bits/mathdef.h b/sysdeps/x86_64/bits/mathdef.h
index 9146392..9e23501 100644
--- a/sysdeps/x86_64/bits/mathdef.h
+++ b/sysdeps/x86_64/bits/mathdef.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2001, 2004, 2010 Free Software Foundation, Inc.
+/* Copyright (C) 2001, 2004, 2010, 2011 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -23,9 +23,7 @@
 #if defined __USE_ISOC99 && defined _MATH_H && !defined _MATH_H_MATHDEF
 # define _MATH_H_MATHDEF	1
 
-# include <bits/wordsize.h>
-
-# if __WORDSIZE == 64 || (defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0)
+# if defined __x86_64__ || (defined __FLT_EVAL_METHOD__ && __FLT_EVAL_METHOD__ == 0)
 /* The x86-64 architecture computes values with the precission of the
    used type.  Similarly for -m32 -mfpmath=sse.  */
 typedef float float_t;		/* `float' expressions are evaluated as `float'.  */
diff --git a/sysdeps/x86_64/bits/setjmp.h b/sysdeps/x86_64/bits/setjmp.h
index c9b98b2..3f6f2fe 100644
--- a/sysdeps/x86_64/bits/setjmp.h
+++ b/sysdeps/x86_64/bits/setjmp.h
@@ -30,6 +30,8 @@
 
 # if __WORDSIZE == 64
 typedef long int __jmp_buf[8];
+# elif defined  __x86_64__
+typedef long long int __jmp_buf[8];
 # else
 typedef int __jmp_buf[6];
 # endif
diff --git a/sysdeps/x86_64/bits/wordsize.h b/sysdeps/x86_64/bits/wordsize.h
deleted file mode 100644
index a40a0d8..0000000
--- a/sysdeps/x86_64/bits/wordsize.h
+++ /dev/null
@@ -1,8 +0,0 @@
-/* Determine the wordsize from the preprocessor defines.  */
-
-#if defined __x86_64__
-# define __WORDSIZE	64
-# define __WORDSIZE_COMPAT32	1
-#else
-# define __WORDSIZE	32
-#endif
diff --git a/sysdeps/x86_64/dl-irel.h b/sysdeps/x86_64/dl-irel.h
index 19f9457..db03827 100644
--- a/sysdeps/x86_64/dl-irel.h
+++ b/sysdeps/x86_64/dl-irel.h
@@ -26,23 +26,23 @@
 
 #define ELF_MACHINE_IRELA	1
 
-static inline Elf64_Addr
+static inline ElfW(Addr)
 __attribute ((always_inline))
-elf_ifunc_invoke (Elf64_Addr addr)
+elf_ifunc_invoke (ElfW(Addr) addr)
 {
-  return ((Elf64_Addr (*) (void)) (addr)) ();
+  return ((ElfW(Addr) (*) (void)) (addr)) ();
 }
 
 static inline void
 __attribute ((always_inline))
-elf_irela (const Elf64_Rela *reloc)
+elf_irela (const ElfW(Rela) *reloc)
 {
-  Elf64_Addr *const reloc_addr = (void *) reloc->r_offset;
-  const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);
+  ElfW(Addr) *const reloc_addr = (void *) reloc->r_offset;
+  const unsigned long int r_type = ELF32_R_TYPE (reloc->r_info);
 
   if (__builtin_expect (r_type == R_X86_64_IRELATIVE, 1))
     {
-      Elf64_Addr value = elf_ifunc_invoke(reloc->r_addend);
+      ElfW(Addr) value = elf_ifunc_invoke(reloc->r_addend);
       *reloc_addr = value;
     }
   else
diff --git a/sysdeps/x86_64/dl-machine.h b/sysdeps/x86_64/dl-machine.h
index a8fbc16..99e8900 100644
--- a/sysdeps/x86_64/dl-machine.h
+++ b/sysdeps/x86_64/dl-machine.h
@@ -30,7 +30,7 @@
 
 /* Return nonzero iff ELF header is compatible with the running host.  */
 static inline int __attribute__ ((unused))
-elf_machine_matches_host (const Elf64_Ehdr *ehdr)
+elf_machine_matches_host (const ElfW(Ehdr) *ehdr)
 {
   return ehdr->e_machine == EM_X86_64;
 }
@@ -39,24 +39,24 @@ elf_machine_matches_host (const Elf64_Ehdr *ehdr)
 /* Return the link-time address of _DYNAMIC.  Conveniently, this is the
    first element of the GOT.  This must be inlined in a function which
    uses global data.  */
-static inline Elf64_Addr __attribute__ ((unused))
+static inline ElfW(Addr) __attribute__ ((unused))
 elf_machine_dynamic (void)
 {
-  Elf64_Addr addr;
+  ElfW(Addr) addr;
 
   /* This works because we have our GOT address available in the small PIC
      model.  */
-  addr = (Elf64_Addr) &_DYNAMIC;
+  addr = (ElfW(Addr)) &_DYNAMIC;
 
   return addr;
 }
 
 
 /* Return the run-time load address of the shared object.  */
-static inline Elf64_Addr __attribute__ ((unused))
+static inline ElfW(Addr) __attribute__ ((unused))
 elf_machine_load_address (void)
 {
-  Elf64_Addr addr;
+  ElfW(Addr) addr;
 
   /* The easy way is just the same as on x86:
        leaq _dl_start, %0
@@ -73,10 +73,10 @@ elf_machine_load_address (void)
      load offset which is zero if the binary was loaded at the address
      it is prelinked for.  */
 
-  asm ("leaq _dl_start(%%rip), %0\n\t"
-       "subq 1f(%%rip), %0\n\t"
+  asm ("lea _dl_start(%%rip), %0\n\t"
+       "sub 1f(%%rip), %0\n\t"
        ".section\t.data.rel.ro\n"
-       "1:\t.quad _dl_start\n\t"
+       "1:\t" ASM_ADDR " _dl_start\n\t"
        ".previous\n\t"
        : "=r" (addr) : : "cc");
 
@@ -90,8 +90,8 @@ static inline int __attribute__ ((unused, always_inline))
 elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
 {
   Elf64_Addr *got;
-  extern void _dl_runtime_resolve (Elf64_Word) attribute_hidden;
-  extern void _dl_runtime_profile (Elf64_Word) attribute_hidden;
+  extern void _dl_runtime_resolve (ElfW(Word)) attribute_hidden;
+  extern void _dl_runtime_profile (ElfW(Word)) attribute_hidden;
 
   if (l->l_info[DT_JMPREL] && lazy)
     {
@@ -106,9 +106,10 @@ elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
       if (got[1])
 	{
 	  l->l_mach.plt = got[1] + l->l_addr;
-	  l->l_mach.gotplt = (Elf64_Addr) &got[3];
+	  l->l_mach.gotplt = (ElfW(Addr)) &got[3];
 	}
-      got[1] = (Elf64_Addr) l;	/* Identify this shared object.  */
+      /* Identify this shared object.  */
+      *(ElfW(Addr) *) (got + 1) = (ElfW(Addr)) l;
 
       /* The got[2] entry contains the address of a function which gets
 	 called to get the address of a so far unresolved function and
@@ -118,7 +119,7 @@ elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
 	 end in this function.  */
       if (__builtin_expect (profile, 0))
 	{
-	  got[2] = (Elf64_Addr) &_dl_runtime_profile;
+	  *(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_profile;
 
 	  if (GLRO(dl_profile) != NULL
 	      && _dl_name_match_p (GLRO(dl_profile), l))
@@ -129,12 +130,12 @@ elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
       else
 	/* This function will get called to fix up the GOT entry indicated by
 	   the offset on the stack, and then jump to the resolved address.  */
-	got[2] = (Elf64_Addr) &_dl_runtime_resolve;
+	*(ElfW(Addr) *) (got + 2) = (ElfW(Addr)) &_dl_runtime_resolve;
     }
 
   if (l->l_info[ADDRIDX (DT_TLSDESC_GOT)] && lazy)
-    *(Elf64_Addr*)(D_PTR (l, l_info[ADDRIDX (DT_TLSDESC_GOT)]) + l->l_addr)
-      = (Elf64_Addr) &_dl_tlsdesc_resolve_rela;
+    *(ElfW(Addr)*)(D_PTR (l, l_info[ADDRIDX (DT_TLSDESC_GOT)]) + l->l_addr)
+      = (ElfW(Addr)) &_dl_tlsdesc_resolve_rela;
 
   return lazy;
 }
@@ -211,7 +212,7 @@ _dl_start_user:\n\
 // XXX This is a work-around for a broken linker.  Remove!
 #define ELF_MACHINE_IRELATIVE	R_X86_64_IRELATIVE
 
-/* The x86-64 never uses Elf64_Rel relocations.  */
+/* The x86-64 never uses Elf64_Rel/Elf32_Rel relocations.  */
 #define ELF_MACHINE_NO_REL 1
 
 /* We define an initialization function.  This is called very early in
@@ -226,19 +227,19 @@ dl_platform_init (void)
     GLRO(dl_platform) = NULL;
 }
 
-static inline Elf64_Addr
+static inline ElfW(Addr)
 elf_machine_fixup_plt (struct link_map *map, lookup_t t,
-		       const Elf64_Rela *reloc,
-		       Elf64_Addr *reloc_addr, Elf64_Addr value)
+		       const ElfW(Rela) *reloc,
+		       ElfW(Addr) *reloc_addr, ElfW(Addr) value)
 {
   return *reloc_addr = value;
 }
 
 /* Return the final value of a PLT relocation.  On x86-64 the
    JUMP_SLOT relocation ignores the addend.  */
-static inline Elf64_Addr
-elf_machine_plt_value (struct link_map *map, const Elf64_Rela *reloc,
-		       Elf64_Addr value)
+static inline ElfW(Addr)
+elf_machine_plt_value (struct link_map *map, const ElfW(Rela) *reloc,
+		       ElfW(Addr) value)
 {
   return value;
 }
@@ -257,12 +258,12 @@ elf_machine_plt_value (struct link_map *map, const Elf64_Rela *reloc,
 
 auto inline void
 __attribute__ ((always_inline))
-elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
-		  const Elf64_Sym *sym, const struct r_found_version *version,
+elf_machine_rela (struct link_map *map, const ElfW(Rela) *reloc,
+		  const ElfW(Sym) *sym, const struct r_found_version *version,
 		  void *const reloc_addr_arg, int skip_ifunc)
 {
-  Elf64_Addr *const reloc_addr = reloc_addr_arg;
-  const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);
+  ElfW(Addr) *const reloc_addr = reloc_addr_arg;
+  const unsigned long int r_type = ELF32_R_TYPE (reloc->r_info);
 
 # if !defined RTLD_BOOTSTRAP || !defined HAVE_Z_COMBRELOC
   if (__builtin_expect (r_type == R_X86_64_RELATIVE, 0))
@@ -283,23 +284,29 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
     }
   else
 # endif
+# if !defined RTLD_BOOTSTRAP && !defined __LP64__
+  if (__builtin_expect (r_type == R_X86_64_RELATIVE64, 0))
+    *((Elf64_Addr *) (uintptr_t) reloc_addr)
+      = (Elf64_Addr) map->l_addr + reloc->r_addend;
+  else
+# endif
   if (__builtin_expect (r_type == R_X86_64_NONE, 0))
     return;
   else
     {
 # ifndef RTLD_BOOTSTRAP
-      const Elf64_Sym *const refsym = sym;
+      const ElfW(Sym) *const refsym = sym;
 # endif
       struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
-      Elf64_Addr value = (sym == NULL ? 0
-			  : (Elf64_Addr) sym_map->l_addr + sym->st_value);
+      ElfW(Addr) value = (sym == NULL ? 0
+			  : (ElfW(Addr)) sym_map->l_addr + sym->st_value);
 
       if (sym != NULL
 	  && __builtin_expect (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC,
 			       0)
 	  && __builtin_expect (sym->st_shndx != SHN_UNDEF, 1)
 	  && __builtin_expect (!skip_ifunc, 1))
-	value = ((Elf64_Addr (*) (void)) value) ();
+	value = ((ElfW(Addr) (*) (void)) value) ();
 
       switch (r_type)
 	{
@@ -328,7 +335,13 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
 	  /* During relocation all TLS symbols are defined and used.
 	     Therefore the offset is already correct.  */
 	  if (sym != NULL)
+#   ifdef __LP64__
 	    *reloc_addr = sym->st_value + reloc->r_addend;
+#   else
+	    *(Elf64_Sxword *) reloc_addr
+	      = (Elf64_Sxword)
+		  ((Elf32_Sword) (sym->st_value + reloc->r_addend));
+#   endif
 #  endif
 	  break;
 	case R_X86_64_TLSDESC:
@@ -378,15 +391,27 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
 	      /* We know the offset of the object the symbol is contained in.
 		 It is a negative value which will be added to the
 		 thread pointer.  */
+#  ifdef __LP64__
 	      *reloc_addr = (sym->st_value + reloc->r_addend
 			     - sym_map->l_tls_offset);
+#  else
+	    *(Elf64_Sxword *) reloc_addr
+	      = (Elf64_Sxword)
+		  ((Elf32_Sword) (sym->st_value + reloc->r_addend
+				  - sym_map->l_tls_offset));
+#  endif
 	    }
 	  break;
 # endif
 
 # ifndef RTLD_BOOTSTRAP
 	case R_X86_64_64:
+#  ifdef __LP64__
 	  *reloc_addr = value + reloc->r_addend;
+#  else
+	  *((Elf64_Addr *) (uintptr_t) reloc_addr)
+	    = (Elf64_Addr) value + reloc->r_addend;
+#  endif
 	  break;
 	case R_X86_64_32:
 	  value += reloc->r_addend;
@@ -412,7 +437,7 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
 #  ifndef RESOLVE_CONFLICT_FIND_MAP
 	  /* Not needed for dl-conflict.c.  */
 	case R_X86_64_PC32:
-	  value += reloc->r_addend - (Elf64_Addr) reloc_addr;
+	  value += reloc->r_addend - (ElfW(Addr)) reloc_addr;
 	  *(unsigned int *) reloc_addr = value;
 	  if (__builtin_expect (value != (int) value, 0))
 	    {
@@ -440,7 +465,7 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
 #  endif
 	case R_X86_64_IRELATIVE:
 	  value = map->l_addr + reloc->r_addend;
-	  value = ((Elf64_Addr (*) (void)) value) ();
+	  value = ((ElfW(Addr) (*) (void)) value) ();
 	  *reloc_addr = value;
 	  break;
 	default:
@@ -453,22 +478,29 @@ elf_machine_rela (struct link_map *map, const Elf64_Rela *reloc,
 
 auto inline void
 __attribute ((always_inline))
-elf_machine_rela_relative (Elf64_Addr l_addr, const Elf64_Rela *reloc,
+elf_machine_rela_relative (ElfW(Addr) l_addr, const ElfW(Rela) *reloc,
 			   void *const reloc_addr_arg)
 {
-  Elf64_Addr *const reloc_addr = reloc_addr_arg;
-  assert (ELF64_R_TYPE (reloc->r_info) == R_X86_64_RELATIVE);
-  *reloc_addr = l_addr + reloc->r_addend;
+  ElfW(Addr) *const reloc_addr = reloc_addr_arg;
+#if !defined RTLD_BOOTSTRAP
+  if (__builtin_expect (ELF32_R_TYPE (reloc->r_info) == R_X86_64_RELATIVE64, 0))
+    *(Elf64_Addr *) reloc_addr = (Elf64_Addr) l_addr + reloc->r_addend;
+  else
+#endif
+    {
+      assert (ELF32_R_TYPE (reloc->r_info) == R_X86_64_RELATIVE);
+      *reloc_addr = l_addr + reloc->r_addend;
+    }
 }
 
 auto inline void
 __attribute ((always_inline))
 elf_machine_lazy_rel (struct link_map *map,
-		      Elf64_Addr l_addr, const Elf64_Rela *reloc,
+		      ElfW(Addr) l_addr, const ElfW(Rela) *reloc,
 		      int skip_ifunc)
 {
-  Elf64_Addr *const reloc_addr = (void *) (l_addr + reloc->r_offset);
-  const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);
+  ElfW(Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned long int r_type = ELF32_R_TYPE (reloc->r_info);
 
   /* Check for unexpected PLT reloc type.  */
   if (__builtin_expect (r_type == R_X86_64_JUMP_SLOT, 1))
@@ -478,7 +510,7 @@ elf_machine_lazy_rel (struct link_map *map,
       else
 	*reloc_addr =
 	  map->l_mach.plt
-	  + (((Elf64_Addr) reloc_addr) - map->l_mach.gotplt) * 2;
+	  + (((ElfW(Addr)) reloc_addr) - map->l_mach.gotplt) * 2;
     }
   else if (__builtin_expect (r_type == R_X86_64_TLSDESC, 1))
     {
@@ -491,9 +523,9 @@ elf_machine_lazy_rel (struct link_map *map,
     }
   else if (__builtin_expect (r_type == R_X86_64_IRELATIVE, 0))
     {
-      Elf64_Addr value = map->l_addr + reloc->r_addend;
+      ElfW(Addr) value = map->l_addr + reloc->r_addend;
       if (__builtin_expect (!skip_ifunc, 1))
-	value = ((Elf64_Addr (*) (void)) value) ();
+	value = ((ElfW(Addr) (*) (void)) value) ();
       *reloc_addr = value;
     }
   else
diff --git a/sysdeps/x86_64/dl-tls.h b/sysdeps/x86_64/dl-tls.h
index c382cd8..5ddaaef 100644
--- a/sysdeps/x86_64/dl-tls.h
+++ b/sysdeps/x86_64/dl-tls.h
@@ -21,8 +21,8 @@
 /* Type used for the representation of TLS information in the GOT.  */
 typedef struct dl_tls_index
 {
-  unsigned long int ti_module;
-  unsigned long int ti_offset;
+  unsigned long long int ti_module;
+  unsigned long long int ti_offset;
 } tls_index;
 
 
diff --git a/sysdeps/x86_64/dl-tlsdesc.h b/sysdeps/x86_64/dl-tlsdesc.h
index 9e64aab..dcff33e 100644
--- a/sysdeps/x86_64/dl-tlsdesc.h
+++ b/sysdeps/x86_64/dl-tlsdesc.h
@@ -31,13 +31,19 @@
 struct tlsdesc
 {
   ptrdiff_t (*entry)(struct tlsdesc *on_rax);
+#ifndef __LP64__
+  int pad1;
+#endif
   void *arg;
+#ifndef __LP64__
+  int pad2;
+#endif
 };
 
 typedef struct dl_tls_index
 {
-  unsigned long int ti_module;
-  unsigned long int ti_offset;
+  unsigned long long int ti_module;
+  unsigned long long int ti_offset;
 } tls_index;
 
 /* Type used as the argument in a TLS descriptor for a symbol that
diff --git a/sysdeps/x86_64/dl-trampoline.S b/sysdeps/x86_64/dl-trampoline.S
index 6523c92..9a1cfac 100644
--- a/sysdeps/x86_64/dl-trampoline.S
+++ b/sysdeps/x86_64/dl-trampoline.S
@@ -21,6 +21,10 @@
 #include <sysdep.h>
 #include <link-defines.h>
 
+#if (RTLD_SAVESPACE_SSE % 32) != 0
+# error "RTLD_SAVESPACE_SSE must be 32byte aligned"
+#endif
+
 	.text
 	.globl _dl_runtime_resolve
 	.type _dl_runtime_resolve, @function
diff --git a/sysdeps/x86_64/dl-trampoline.h b/sysdeps/x86_64/dl-trampoline.h
index 1c39579..483fda2 100644
--- a/sysdeps/x86_64/dl-trampoline.h
+++ b/sysdeps/x86_64/dl-trampoline.h
@@ -45,7 +45,7 @@
 	movq 48(%rbx), %rdx	# Load return address if needed.
 	movq 40(%rbx), %rsi	# Copy args pushed by PLT in register.
 	movq 32(%rbx), %rdi	# %rdi: link_map, %rsi: reloc_index
-	leaq 16(%rbx), %r8
+	leaq 16(%rbx), %r8	# Address of framesize
 	call _dl_profile_fixup	# Call resolver.
 
 	movq %rax, %r11		# Save return value.
@@ -141,8 +141,8 @@
 
 1:
 #endif
-	movq 16(%rbx), %r10	# Anything in framesize?
-	testq %r10, %r10
+	mov  16(%rbx), %R10_LP	# Anything in framesize?
+	test %R10_LP, %R10_LP
 	jns 3f
 
 	/* There's nothing in the frame size, so there
diff --git a/sysdeps/x86_64/elf/start.S b/sysdeps/x86_64/elf/start.S
index 3c2caf9..6c5af7b 100644
--- a/sysdeps/x86_64/elf/start.S
+++ b/sysdeps/x86_64/elf/start.S
@@ -45,15 +45,16 @@
 		before this code runs.
 
    %rsp		The stack contains the arguments and environment:
-		0(%rsp)			argc
-		8(%rsp)			argv[0]
+		0(%rsp)				argc
+		LP_SIZE(%rsp)			argv[0]
 		...
-		(8*argc)(%rsp)		NULL
-		(8*(argc+1))(%rsp)	envp[0]
+		(LP_SIZE*argc)(%rsp)		NULL
+		(LP_SIZE*(argc+1))(%rsp)	envp[0]
 		...
-					NULL
+						NULL
 */
 
+#include <sysdep.h>
 #include "bp-sym.h"
 
 	.text
@@ -78,12 +79,17 @@ _start:
 	rtld_fini:	%r9
 	stack_end:	stack.	*/
 
-	movq %rdx, %r9		/* Address of the shared library termination
+	mov %RDX_LP, %R9_LP	/* Address of the shared library termination
 				   function.  */
+#ifdef __LP64__
 	popq %rsi		/* Pop the argument count.  */
-	movq %rsp, %rdx		/* argv starts just at the current stack top.  */
+#else
+	mov (%rsp),%esi		/* Simulate popping 4byte argument count.  */
+	addl $4,%esp
+#endif
+	mov %RSP_LP, %RDX_LP	/* argv starts just at the current stack top.  */
 	/* Align the stack to a 16 byte boundary to follow the ABI.  */
-	andq  $~15, %rsp
+	and  $~15, %RSP_LP
 
 	pushq %rax		/* Push garbage because we push 8 more bytes.  */
 
@@ -93,20 +99,20 @@ _start:
 
 #ifdef SHARED
 	/* Pass address of our own entry points to .fini and .init.  */
-	movq __libc_csu_fini@GOTPCREL(%rip), %r8
-	movq __libc_csu_init@GOTPCREL(%rip), %rcx
+	mov __libc_csu_fini@GOTPCREL(%rip), %R8_LP
+	mov __libc_csu_init@GOTPCREL(%rip), %RCX_LP
 
-	movq BP_SYM (main)@GOTPCREL(%rip), %rdi
+	mov BP_SYM (main)@GOTPCREL(%rip), %RDI_LP
 
 	/* Call the user's main function, and exit with its value.
 	   But let the libc call main.	  */
 	call BP_SYM (__libc_start_main)@PLT
 #else
 	/* Pass address of our own entry points to .fini and .init.  */
-	movq $__libc_csu_fini, %r8
-	movq $__libc_csu_init, %rcx
+	mov $__libc_csu_fini, %R8_LP
+	mov $__libc_csu_init, %RCX_LP
 
-	movq $BP_SYM (main), %rdi
+	mov $BP_SYM (main), %RDI_LP
 
 	/* Call the user's main function, and exit with its value.
 	   But let the libc call main.	  */
diff --git a/sysdeps/x86_64/ffsll.c b/sysdeps/x86_64/ffsll.c
index 7213c03..f243cf7 100644
--- a/sysdeps/x86_64/ffsll.c
+++ b/sysdeps/x86_64/ffsll.c
@@ -1,7 +1,8 @@
 /* ffsll -- find first set bit in a word, counted from least significant end.
    For AMD x86-64.
    This file is part of the GNU C Library.
-   Copyright (C) 1991,92,93,94,97,98,2001 Free Software Foundation, Inc.
+   Copyright (C) 1991,92,93,94,97,98,2001,2011
+   Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@cygnus.com>.
 
    The GNU C Library is free software; you can redistribute it and/or
@@ -37,5 +38,7 @@ ffsll (long long int x)
   return cnt + 1;
 }
 
+#ifdef __LP64__
 #undef	ffsl
 weak_alias (ffsll, ffsl)
+#endif
diff --git a/sysdeps/x86_64/fpu/bits/fenv.h b/sysdeps/x86_64/fpu/bits/fenv.h
index 8bc2450..75884dc 100644
--- a/sysdeps/x86_64/fpu/bits/fenv.h
+++ b/sysdeps/x86_64/fpu/bits/fenv.h
@@ -20,9 +20,6 @@
 # error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
 #endif
 
-#include <bits/wordsize.h>
-
-
 /* Define bits representing the exception.  We use the bit positions
    of the appropriate bits in the FPU control word.  */
 enum
@@ -82,7 +79,7 @@ typedef struct
     unsigned int __data_offset;
     unsigned short int __data_selector;
     unsigned short int __unused5;
-#if __WORDSIZE == 64
+#ifdef __x86_64__
     unsigned int __mxcsr;
 #endif
   }
diff --git a/sysdeps/x86_64/fpu/bits/mathinline.h b/sysdeps/x86_64/fpu/bits/mathinline.h
index 1a2c1ee..7692ebc 100644
--- a/sysdeps/x86_64/fpu/bits/mathinline.h
+++ b/sysdeps/x86_64/fpu/bits/mathinline.h
@@ -21,8 +21,6 @@
 # error "Never use <bits/mathinline.h> directly; include <math.h> instead."
 #endif
 
-#include <bits/wordsize.h>
-
 #ifndef __extern_always_inline
 # define __MATH_INLINE __inline
 #else
@@ -39,7 +37,7 @@ __BEGIN_NAMESPACE_C99
 __MATH_INLINE int
 __NTH (__signbitf (float __x))
 {
-# if __WORDSIZE == 32
+# ifndef __x86_64__
   __extension__ union { float __f; int __i; } __u = { __f: __x };
   return __u.__i < 0;
 # else
@@ -51,7 +49,7 @@ __NTH (__signbitf (float __x))
 __MATH_INLINE int
 __NTH (__signbit (double __x))
 {
-# if __WORDSIZE == 32
+# ifndef __x86_64__
   __extension__ union { double __d; int __i[2]; } __u = { __d: __x };
   return __u.__i[1] < 0;
 # else
@@ -78,7 +76,7 @@ __END_NAMESPACE_C99
 __BEGIN_NAMESPACE_C99
 
 /* Round to nearest integer.  */
-#  if __WORDSIZE == 64 || defined __SSE_MATH__
+#  if defined __x86_64__ || defined __SSE_MATH__
 __MATH_INLINE long int
 __NTH (lrintf (float __x))
 {
@@ -87,7 +85,7 @@ __NTH (lrintf (float __x))
   return __res;
 }
 #  endif
-#  if __WORDSIZE == 64 || defined __SSE2_MATH__
+#  if defined __x86_64__ || defined __SSE_MATH__
 __MATH_INLINE long int
 __NTH (lrint (double __x))
 {
@@ -96,7 +94,7 @@ __NTH (lrint (double __x))
   return __res;
 }
 #  endif
-#  if __WORDSIZE == 64
+#  ifdef __x86_64__
 __MATH_INLINE long long int
 __NTH (llrintf (float __x))
 {
@@ -114,7 +112,7 @@ __NTH (llrint (double __x))
 #  endif
 
 #  if defined __FINITE_MATH_ONLY__ && __FINITE_MATH_ONLY__ > 0 \
-      && (__WORDSIZE == 64 || defined __SSE2_MATH__)
+      && (defined __x86_64__ || defined __SSE2_MATH__)
 /* Determine maximum of two values.  */
 __MATH_INLINE float
 __NTH (fmaxf (float __x, float __y))
@@ -147,7 +145,7 @@ __NTH (fmin (double __x, double __y))
 __END_NAMESPACE_C99
 # endif
 
-# if defined __SSE4_1__ && (__WORDSIZE == 64 || defined __SSE2_MATH__)
+# if defined __SSE4_1__ && (defined __x86_64__ || defined __SSE2_MATH__)
 #  if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
 __BEGIN_NAMESPACE_C99
 
diff --git a/sysdeps/x86_64/fpu/math_private.h b/sysdeps/x86_64/fpu/math_private.h
index 7f52d5e..ded64a8 100644
--- a/sysdeps/x86_64/fpu/math_private.h
+++ b/sysdeps/x86_64/fpu/math_private.h
@@ -29,7 +29,7 @@
 #undef EXTRACT_WORDS64
 #define EXTRACT_WORDS64(i, d)						      \
   do {									      \
-    long int i_;							      \
+    long long int i_;							      \
     asm (MOVD " %1, %0" : "=rm" (i_) : "x" ((double) (d)));		      \
     (i) = i_;								      \
   } while (0)
@@ -38,7 +38,7 @@
 #undef INSERT_WORDS64
 #define INSERT_WORDS64(d, i) \
   do {									      \
-    long int i_ = i;							      \
+    long long int i_ = i;						      \
     double d__;								      \
     asm (MOVD " %1, %0" : "=x" (d__) : "rm" (i_));			      \
     d = d__;								      \
@@ -66,22 +66,22 @@
 #endif
 
 #define __isnan(d) \
-  ({ long int __di; EXTRACT_WORDS64 (__di, (double) (d));		      \
-     (__di & 0x7fffffffffffffffl) > 0x7ff0000000000000l; })
+  ({ long long int __di; EXTRACT_WORDS64 (__di, (double) (d));		      \
+     (__di & 0x7fffffffffffffffll) > 0x7ff0000000000000ll; })
 #define __isnanf(d) \
   ({ int __di; GET_FLOAT_WORD (__di, (float) d);			      \
      (__di & 0x7fffffff) > 0x7f800000; })
 
 #define __isinf_ns(d) \
-  ({ long int __di; EXTRACT_WORDS64 (__di, (double) (d));		      \
-     (__di & 0x7fffffffffffffffl) == 0x7ff0000000000000l; })
+  ({ long long int __di; EXTRACT_WORDS64 (__di, (double) (d));		      \
+     (__di & 0x7fffffffffffffffll) == 0x7ff0000000000000ll; })
 #define __isinf_nsf(d) \
   ({ int __di; GET_FLOAT_WORD (__di, (float) d);			      \
      (__di & 0x7fffffff) == 0x7f800000; })
 
 #define __finite(d) \
-  ({ long int __di; EXTRACT_WORDS64 (__di, (double) (d));		      \
-     (__di & 0x7fffffffffffffffl) < 0x7ff0000000000000l; })
+  ({ long long int __di; EXTRACT_WORDS64 (__di, (double) (d));		      \
+     (__di & 0x7fffffffffffffffll) < 0x7ff0000000000000ll; })
 #define __finitef(d) \
   ({ int __di; GET_FLOAT_WORD (__di, (float) d);			      \
      (__di & 0x7fffffff) < 0x7f800000; })
diff --git a/sysdeps/x86_64/jmpbuf-unwind.h b/sysdeps/x86_64/jmpbuf-unwind.h
index 299a4a8..ce31ea5 100644
--- a/sysdeps/x86_64/jmpbuf-unwind.h
+++ b/sysdeps/x86_64/jmpbuf-unwind.h
@@ -29,7 +29,9 @@
   ((void *) (address) < (void *) demangle ((jmpbuf)[JB_RSP]))
 
 #define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
-  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, \
+		       (void *) (_Unwind_Ptr) _Unwind_GetCFA (_context), \
+		       _adj)
 
 static inline uintptr_t __attribute__ ((unused))
 _jmpbuf_sp (__jmp_buf regs)
diff --git a/sysdeps/x86_64/lib-names.awk b/sysdeps/x86_64/lib-names.awk
new file mode 100644
index 0000000..e402c6e
--- /dev/null
+++ b/sysdeps/x86_64/lib-names.awk
@@ -0,0 +1,114 @@
+# awk script for soversions.i -> gnu/lib-names.h; see Makeconfig.
+
+$1 != "DEFAULT" { multi = 1 }
+
+#
+{
+  lib = $2;
+  version = $3;
+  if ($3 !~ /^[0-9]/) {
+    soname = $3;
+    extra = $3;
+    sub(/\.so.*$/, "", extra);
+  }
+  else {
+    soname = lib ".so." $3;
+    extra = "";
+  }
+  soname = "\"" soname "\"";
+  lib = toupper(lib);
+  extra = toupper(extra);
+  gsub(/-/, "_", lib);
+  gsub(/-/, "_", extra);
+  if (extra) {
+    if (extra == "LD_LINUX_X32") {
+      x32_macros[$1 FS lib "_SO"] = soname;
+      x32_macros[$1 FS extra "_SO"] = soname;
+      x86_64_macros[$1 FS lib "_SO"] = "\"ld-linux-x86-64.so.2\"";
+      x86_64_macros[$1 FS "LD_LINUX_X86_64_SO"] = "\"ld-linux-x86-64.so.2\"";
+    }
+    else if (extra == "LD_LINUX_X86_64") {
+      x86_64_macros[$1 FS lib "_SO"] = soname;
+      x86_64_macros[$1 FS extra "_SO"] = soname;
+      x32_macros[$1 FS lib "_SO"] = "\"ld-linux-x32.so.2\"";
+      x32_macros[$1 FS "LD_LINUX_X32_SO"] = "\"ld-linux-x32.so.2\"";
+    }
+    else {
+      macros[$1 FS lib "_SO"] = soname;
+      macros[$1 FS extra "_SO"] = soname;
+    }
+  }
+  else {
+    macros[$1 FS lib "_SO"] = soname;
+  }
+}
+
+END {
+  print "/* This file is automatically generated.";
+  print "   It defines macros to allow user program to find the shared";
+  print "   library files which come as part of GNU libc.  */";
+  print "#ifndef __GNU_LIB_NAMES_H";
+  print "#define __GNU_LIB_NAMES_H	1";
+  print "";
+
+  pfx = multi ? "# define " : "#define ";
+  for (elt in macros) {
+    split(elt, x);
+    line = sprintf("%-40s%s", pfx x[2], macros[elt]);
+    if (x[1] in lines)
+      lines[x[1]] = lines[x[1]] "\n" line;
+    else
+      lines[x[1]] = line;
+  }
+
+  if (multi) {
+    # Print these in a fixed order so the result is identical
+    # on both sides of the coin.
+    pfx = "#  define ";
+    for (elt in x32_macros) {
+      split(elt, x);
+      line = sprintf("%-40s%s", pfx x[2], x32_macros[elt]);
+      if (x[1] in x32_lines)
+	x32_lines[x[1]] = x32_lines[x[1]] "\n" line;
+      else
+	x32_lines[x[1]] = line;
+    }
+    for (elt in x86_64_macros) {
+      split(elt, x);
+      line = sprintf("%-40s%s", pfx x[2], x86_64_macros[elt]);
+      if (x[1] in x86_64_lines)
+	x86_64_lines[x[1]] = x86_64_lines[x[1]] "\n" line;
+      else
+	x86_64_lines[x[1]] = line;
+    }
+    if (!("WORDSIZE32" in lines))
+      lines["WORDSIZE32"] = lines["DEFAULT"];
+    if (!("WORDSIZE64" in lines))
+      lines["WORDSIZE64"] = lines["DEFAULT"];
+    if (!("WORDSIZE32" in x32_lines))
+      x32_lines["WORDSIZE32"] = x32_lines["DEFAULT"];
+    if (!("WORDSIZE64" in x32_lines))
+      x32_lines["WORDSIZE64"] = x32_lines["DEFAULT"];
+    if (!("WORDSIZE32" in x86_64_lines))
+      x86_64_lines["WORDSIZE32"] = x86_64_lines["DEFAULT"];
+    if (!("WORDSIZE64" in x86_64_lines))
+      x86_64_lines["WORDSIZE64"] = x86_64_lines["DEFAULT"];
+    print "#include <bits/wordsize.h>\n";
+    print "#ifndef __x86_64__";
+    cmd = "LC_ALL=C sort"; print lines["WORDSIZE32"] | cmd; close(cmd);
+    print "#else"
+    print "# if __WORDSIZE == 32"
+    cmd = "LC_ALL=C sort"; print x32_lines["WORDSIZE64"] | cmd; close(cmd);
+    print "# else"
+    cmd = "LC_ALL=C sort"; print x86_64_lines["WORDSIZE64"] | cmd; close(cmd);
+    print "# endif"
+    cmd = "LC_ALL=C sort"; print lines["WORDSIZE64"] | cmd; close(cmd);
+    print "#endif";
+  }
+  else {
+    cmd = "LC_ALL=C sort"; print lines["DEFAULT"] | cmd; close(cmd);
+  }
+
+  print "";
+  print "#endif	/* gnu/lib-names.h */"
+}
diff --git a/sysdeps/x86_64/memcpy.S b/sysdeps/x86_64/memcpy.S
index 724d44e..5511e04 100644
--- a/sysdeps/x86_64/memcpy.S
+++ b/sysdeps/x86_64/memcpy.S
@@ -255,7 +255,7 @@ L(32after):
 
 L(fasttry):				/* first 1/2 L1 */
 #ifndef NOT_IN_libc			/* only up to this algorithm outside of libc.so */
-	movq	__x86_64_data_cache_size_half(%rip), %r11
+	mov	__x86_64_data_cache_size_half(%rip), %R11_LP
 	cmpq	%rdx, %r11		/* calculate the smaller of */
 	cmovaq	%rdx, %r11		/* remaining bytes and 1/2 L1 */
 #endif
@@ -304,7 +304,7 @@ L(fastafter):
 /* Handle large blocks smaller than 1/2 L2. */
 
 L(pretry):				/* first 1/2 L2 */
-	movq	__x86_64_shared_cache_size_half (%rip), %r8
+	mov	__x86_64_shared_cache_size_half (%rip), %R8_LP
 	cmpq	%rdx, %r8		/* calculate the lesser of */
 	cmovaq	%rdx, %r8		/* remaining bytes and 1/2 L2 */
 
diff --git a/sysdeps/x86_64/multiarch/memcmp-sse4.S b/sysdeps/x86_64/multiarch/memcmp-sse4.S
index 28dd505..12d9e00 100644
--- a/sysdeps/x86_64/multiarch/memcmp-sse4.S
+++ b/sysdeps/x86_64/multiarch/memcmp-sse4.S
@@ -320,9 +320,9 @@ L(less32bytesin256):
 	ALIGN (4)
 L(512bytesormore):
 # ifdef DATA_CACHE_SIZE_HALF
-	mov	$DATA_CACHE_SIZE_HALF, %r8
+	mov	$DATA_CACHE_SIZE_HALF, %R8_LP
 # else
-	mov	__x86_64_data_cache_size_half(%rip), %r8
+	mov	__x86_64_data_cache_size_half(%rip), %R8_LP
 # endif
 	mov	%r8, %r9
 	shr	$1, %r8
@@ -636,9 +636,9 @@ L(less32bytesin256in2alinged):
 	ALIGN (4)
 L(512bytesormorein2aligned):
 # ifdef DATA_CACHE_SIZE_HALF
-	mov	$DATA_CACHE_SIZE_HALF, %r8
+	mov	$DATA_CACHE_SIZE_HALF, %R8_LP
 # else
-	mov	__x86_64_data_cache_size_half(%rip), %r8
+	mov	__x86_64_data_cache_size_half(%rip), %R8_LP
 # endif
 	mov	%r8, %r9
 	shr	$1, %r8
diff --git a/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S b/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S
index bdd114a..a4b1fe4 100644
--- a/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S
+++ b/sysdeps/x86_64/multiarch/memcpy-ssse3-back.S
@@ -107,9 +107,9 @@ L(144bytesormore):
 	and	$0xf, %r9
 	jz	L(shl_0)
 #ifdef DATA_CACHE_SIZE
-	mov	$DATA_CACHE_SIZE, %rcx
+	mov	$DATA_CACHE_SIZE, %RCX_LP
 #else
-	mov	__x86_64_data_cache_size(%rip), %rcx
+	mov	__x86_64_data_cache_size(%rip), %RCX_LP
 #endif
 	cmp	%rcx, %rdx
 	jae	L(gobble_mem_fwd)
@@ -123,9 +123,9 @@ L(144bytesormore):
 	ALIGN (4)
 L(copy_backward):
 #ifdef DATA_CACHE_SIZE
-	mov	$DATA_CACHE_SIZE, %rcx
+	mov	$DATA_CACHE_SIZE, %RCX_LP
 #else
-	mov	__x86_64_data_cache_size(%rip), %rcx
+	mov	__x86_64_data_cache_size(%rip), %RCX_LP
 #endif
 	shl	$1, %rcx
 	cmp	%rcx, %rdx
@@ -157,9 +157,9 @@ L(shl_0):
 	shr	$8, %r9
 	add	%rdx, %r9
 #ifdef DATA_CACHE_SIZE
-	cmp	$DATA_CACHE_SIZE_HALF, %r9
+	cmp	$DATA_CACHE_SIZE_HALF, %R9_LP
 #else
-	cmp	__x86_64_data_cache_size_half(%rip), %r9
+	cmp	__x86_64_data_cache_size_half(%rip), %R9_LP
 #endif
 	jae	L(gobble_mem_fwd)
 	sub	$0x80, %rdx
@@ -1479,9 +1479,9 @@ L(gobble_mem_fwd):
 	add	$16, %rdi
 
 #ifdef SHARED_CACHE_SIZE_HALF
-	mov	$SHARED_CACHE_SIZE_HALF, %rcx
+	mov	$SHARED_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_shared_cache_size_half(%rip), %rcx
+	mov	__x86_64_shared_cache_size_half(%rip), %RCX_LP
 #endif
 #ifdef USE_AS_MEMMOVE
 	mov	%rsi, %r9
@@ -1586,9 +1586,9 @@ L(gobble_mem_bwd):
 
 
 #ifdef SHARED_CACHE_SIZE_HALF
-	mov	$SHARED_CACHE_SIZE_HALF, %rcx
+	mov	$SHARED_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_shared_cache_size_half(%rip), %rcx
+	mov	__x86_64_shared_cache_size_half(%rip), %RCX_LP
 #endif
 #ifdef USE_AS_MEMMOVE
 	mov	%rdi, %r9
diff --git a/sysdeps/x86_64/multiarch/memcpy-ssse3.S b/sysdeps/x86_64/multiarch/memcpy-ssse3.S
index cd7e45f..0c5a82b 100644
--- a/sysdeps/x86_64/multiarch/memcpy-ssse3.S
+++ b/sysdeps/x86_64/multiarch/memcpy-ssse3.S
@@ -98,9 +98,9 @@ L(80bytesormore):
 	sub	%rcx, %rsi
 
 #ifdef SHARED_CACHE_SIZE_HALF
-	mov	$SHARED_CACHE_SIZE_HALF, %rcx
+	mov	$SHARED_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_shared_cache_size_half(%rip), %rcx
+	mov	__x86_64_shared_cache_size_half(%rip), %RCX_LP
 #endif
 	cmp	%rcx, %rdx
 	mov	%rsi, %r9
@@ -108,9 +108,9 @@ L(80bytesormore):
 	and	$0xf, %r9
 	jz	L(shl_0)
 #ifdef DATA_CACHE_SIZE_HALF
-	mov	$DATA_CACHE_SIZE_HALF, %rcx
+	mov	$DATA_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_data_cache_size_half(%rip), %rcx
+	mov	__x86_64_data_cache_size_half(%rip), %RCX_LP
 #endif
 	BRANCH_TO_JMPTBL_ENTRY (L(shl_table), %r9, 4)
 
@@ -128,9 +128,9 @@ L(copy_backward):
 	sub	%rcx, %rsi
 
 #ifdef SHARED_CACHE_SIZE_HALF
-	mov	$SHARED_CACHE_SIZE_HALF, %rcx
+	mov	$SHARED_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_shared_cache_size_half(%rip), %rcx
+	mov	__x86_64_shared_cache_size_half(%rip), %RCX_LP
 #endif
 
 	cmp	%rcx, %rdx
@@ -139,9 +139,9 @@ L(copy_backward):
 	and	$0xf, %r9
 	jz	L(shl_0_bwd)
 #ifdef DATA_CACHE_SIZE_HALF
-	mov	$DATA_CACHE_SIZE_HALF, %rcx
+	mov	$DATA_CACHE_SIZE_HALF, %RCX_LP
 #else
-	mov	__x86_64_data_cache_size_half(%rip), %rcx
+	mov	__x86_64_data_cache_size_half(%rip), %RCX_LP
 #endif
 	BRANCH_TO_JMPTBL_ENTRY (L(shl_table_bwd), %r9, 4)
 
@@ -176,9 +176,9 @@ L(shl_0_less_64bytes):
 	ALIGN (4)
 L(shl_0_gobble):
 #ifdef DATA_CACHE_SIZE_HALF
-	cmp	$DATA_CACHE_SIZE_HALF, %rdx
+	cmp	$DATA_CACHE_SIZE_HALF, %RDX_LP
 #else
-	cmp	__x86_64_data_cache_size_half(%rip), %rdx
+	cmp	__x86_64_data_cache_size_half(%rip), %RDX_LP
 #endif
 	lea	-128(%rdx), %rdx
 	jae	L(shl_0_gobble_mem_loop)
@@ -317,9 +317,9 @@ L(shl_0_less_64bytes_bwd):
 	ALIGN (4)
 L(shl_0_gobble_bwd):
 #ifdef DATA_CACHE_SIZE_HALF
-	cmp	$DATA_CACHE_SIZE_HALF, %rdx
+	cmp	$DATA_CACHE_SIZE_HALF, %RDX_LP
 #else
-	cmp	__x86_64_data_cache_size_half(%rip), %rdx
+	cmp	__x86_64_data_cache_size_half(%rip), %RDX_LP
 #endif
 	lea	-128(%rdx), %rdx
 	jae	L(shl_0_gobble_mem_bwd_loop)
diff --git a/sysdeps/x86_64/multiarch/strcmp-sse42.S b/sysdeps/x86_64/multiarch/strcmp-sse42.S
index 7a50ff0..c0dbf8c 100644
--- a/sysdeps/x86_64/multiarch/strcmp-sse42.S
+++ b/sysdeps/x86_64/multiarch/strcmp-sse42.S
@@ -52,7 +52,7 @@
 #ifdef USE_AS_STRCASECMP_L
 ENTRY (GLABEL(__strcasecmp))
 	movq	__libc_tsd_LOCALE@gottpoff(%rip),%rax
-	movq	%fs:(%rax),%rdx
+	mov	%fs:(%rax),%RDX_LP
 
 	// XXX 5 byte should be before the function
 	/* 5-byte NOP.  */
@@ -63,7 +63,7 @@ END (GLABEL(__strcasecmp))
 #ifdef USE_AS_STRNCASECMP_L
 ENTRY (GLABEL(__strncasecmp))
 	movq	__libc_tsd_LOCALE@gottpoff(%rip),%rax
-	movq	%fs:(%rax),%rcx
+	mov	%fs:(%rax),%RCX_LP
 
 	// XXX 5 byte should be before the function
 	/* 5-byte NOP.  */
@@ -100,9 +100,9 @@ STRCMP_SSE42:
 	/* We have to fall back on the C implementation for locales
 	   with encodings not matching ASCII for single bytes.  */
 # if LOCALE_T___LOCALES != 0 || LC_CTYPE != 0
-	movq	LOCALE_T___LOCALES+LC_CTYPE*8(%rdx), %rax
+	mov	LOCALE_T___LOCALES+LC_CTYPE*LP_SIZE(%rdx), %RAX_LP
 # else
-	movq	(%rdx), %rax
+	mov	(%rdx), %RAX_LP
 # endif
 	testl	$1, LOCALE_DATA_VALUES+_NL_CTYPE_NONASCII_CASE*SIZEOF_VALUES(%rax)
 	jne	__strcasecmp_l_nonascii
@@ -111,9 +111,9 @@ STRCMP_SSE42:
 	/* We have to fall back on the C implementation for locales
 	   with encodings not matching ASCII for single bytes.  */
 # if LOCALE_T___LOCALES != 0 || LC_CTYPE != 0
-	movq	LOCALE_T___LOCALES+LC_CTYPE*8(%rcx), %rax
+	mov	LOCALE_T___LOCALES+LC_CTYPE*LP_SIZE(%rcx), %RAX_LP
 # else
-	movq	(%rcx), %rax
+	mov	(%rcx), %RAX_LP
 # endif
 	testl	$1, LOCALE_DATA_VALUES+_NL_CTYPE_NONASCII_CASE*SIZEOF_VALUES(%rax)
 	jne	__strncasecmp_l_nonascii
diff --git a/sysdeps/x86_64/preconfigure b/sysdeps/x86_64/preconfigure
new file mode 100644
index 0000000..d8df7ba
--- /dev/null
+++ b/sysdeps/x86_64/preconfigure
@@ -0,0 +1,17 @@
+case "$base_machine" in
+x86_64)
+  stubs_biarch_h=sysdeps/x86_64/stubs-biarch.h
+  lib_names_awk=sysdeps/x86_64/lib-names.awk
+  if echo __LP64__ | ${CC-cc} $CFLAGS $CPPFLAGS -E - | grep __LP64__ > /dev/null; then
+    machine=x86_64/x32
+    data_machine=x32
+    libc_cv_slibdir="/libx32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/libx32';
+      # Locale data can be shared.
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+  else
+    machine=x86_64/64
+  fi
+esac
diff --git a/sysdeps/x86_64/setjmp.S b/sysdeps/x86_64/setjmp.S
index a66b0e6..9cab2fa 100644
--- a/sysdeps/x86_64/setjmp.S
+++ b/sysdeps/x86_64/setjmp.S
@@ -26,7 +26,6 @@ ENTRY (__sigsetjmp)
 	movq %rbx, (JB_RBX*8)(%rdi)
 #ifdef PTR_MANGLE
 	movq %rbp, %rax
-	PTR_MANGLE (%rax)
 	movq %rax, (JB_RBP*8)(%rdi)
 #else
 	movq %rbp, (JB_RBP*8)(%rdi)
@@ -35,14 +34,14 @@ ENTRY (__sigsetjmp)
 	movq %r13, (JB_R13*8)(%rdi)
 	movq %r14, (JB_R14*8)(%rdi)
 	movq %r15, (JB_R15*8)(%rdi)
-	leaq 8(%rsp), %rdx	/* Save SP as it will be after we return.  */
+	lea 8(%rsp), %RDX_LP	/* Save SP as it will be after we return.  */
 #ifdef PTR_MANGLE
-	PTR_MANGLE (%rdx)
+	PTR_MANGLE (%RDX_LP)
 #endif
 	movq %rdx, (JB_RSP*8)(%rdi)
-	movq (%rsp), %rax	/* Save PC we are returning to now.  */
+	mov (%rsp), %RAX_LP	/* Save PC we are returning to now.  */
 #ifdef PTR_MANGLE
-	PTR_MANGLE (%rax)
+	PTR_MANGLE (%RAX_LP)
 #endif
 	movq %rax, (JB_PC*8)(%rdi)
 
diff --git a/sysdeps/x86_64/stackinfo.h b/sysdeps/x86_64/stackinfo.h
index d4fc25f..179e421 100644
--- a/sysdeps/x86_64/stackinfo.h
+++ b/sysdeps/x86_64/stackinfo.h
@@ -35,10 +35,10 @@
    for which they need to act as barriers as well, hence the additional
    (unnecessary) parameters.  */
 #define stackinfo_get_sp() \
-  ({ void *p__; asm volatile ("mov %%rsp, %0" : "=r" (p__)); p__; })
+  ({ void *p__; asm volatile ("mov %%" RSP_LP ", %0" : "=r" (p__)); p__; })
 #define stackinfo_sub_sp(ptr) \
   ({ ptrdiff_t d__;						\
-     asm volatile ("sub %%rsp, %0" : "=r" (d__) : "0" (ptr));	\
+     asm volatile ("sub %%" RSP_LP " , %0" : "=r" (d__) : "0" (ptr));	\
      d__; })
 
 #endif	/* stackinfo.h */
diff --git a/sysdeps/x86_64/strcmp.S b/sysdeps/x86_64/strcmp.S
index 6e5bdaa..d08666b 100644
--- a/sysdeps/x86_64/strcmp.S
+++ b/sysdeps/x86_64/strcmp.S
@@ -97,7 +97,7 @@
 
 ENTRY2 (__strcasecmp)
 	movq	__libc_tsd_LOCALE@gottpoff(%rip),%rax
-	movq	%fs:(%rax),%rdx
+	mov	%fs:(%rax),%RDX_LP
 
 	// XXX 5 byte should be before the function
 	/* 5-byte NOP.  */
@@ -116,7 +116,7 @@ libc_hidden_def (__strcasecmp)
 
 ENTRY2 (__strncasecmp)
 	movq	__libc_tsd_LOCALE@gottpoff(%rip),%rax
-	movq	%fs:(%rax),%rcx
+	mov	%fs:(%rax),%RCX_LP
 
 	// XXX 5 byte should be before the function
 	/* 5-byte NOP.  */
@@ -153,9 +153,9 @@ END (BP_SYM (STRCMP))
 	/* We have to fall back on the C implementation for locales
 	   with encodings not matching ASCII for single bytes.  */
 #  if LOCALE_T___LOCALES != 0 || LC_CTYPE != 0
-	movq	LOCALE_T___LOCALES+LC_CTYPE*8(%rdx), %rax
+	mov	LOCALE_T___LOCALES+LC_CTYPE*LP_SIZE(%rdx), %RAX_LP
 #  else
-	movq	(%rdx), %rax
+	mov	(%rdx), %RAX_LP
 #  endif
 	testl	$1, LOCALE_DATA_VALUES+_NL_CTYPE_NONASCII_CASE*SIZEOF_VALUES(%rax)
 	jne	__strcasecmp_l_nonascii
@@ -163,9 +163,9 @@ END (BP_SYM (STRCMP))
 	/* We have to fall back on the C implementation for locales
 	   with encodings not matching ASCII for single bytes.  */
 #  if LOCALE_T___LOCALES != 0 || LC_CTYPE != 0
-	movq	LOCALE_T___LOCALES+LC_CTYPE*8(%rcx), %rax
+	mov	LOCALE_T___LOCALES+LC_CTYPE*LP_SIZE(%rcx), %RAX_LP
 #  else
-	movq	(%rcx), %rax
+	mov	(%rcx), %RAX_LP
 #  endif
 	testl	$1, LOCALE_DATA_VALUES+_NL_CTYPE_NONASCII_CASE*SIZEOF_VALUES(%rax)
 	jne	__strncasecmp_l_nonascii
diff --git a/sysdeps/x86_64/stubs-biarch.h b/sysdeps/x86_64/stubs-biarch.h
new file mode 100644
index 0000000..2579ec6
--- /dev/null
+++ b/sysdeps/x86_64/stubs-biarch.h
@@ -0,0 +1,8 @@
+/* This file selects the right generated file of `__stub_FUNCTION' macros
+   based on the architecture being compiled for.  */
+
+#ifdef __x86_64__
+# include <gnu/stubs-64.h>
+#else
+# include <gnu/stubs-32.h>
+#endif
diff --git a/sysdeps/x86_64/sysdep.h b/sysdeps/x86_64/sysdep.h
index d61e126..c0116da 100644
--- a/sysdeps/x86_64/sysdep.h
+++ b/sysdeps/x86_64/sysdep.h
@@ -116,4 +116,60 @@ lose:									      \
 
 #define atom_text_section .section ".text.atom", "ax"
 
+/* Long and pointer size in bytes.  */
+#define LP_SIZE	8
+
+/* Instruction to operate on long and pointer.  */
+#define LP_OP(insn) insn##q
+
+/* Assembler address directive. */
+#define ASM_ADDR .quad
+
+/* Registers to hold long and pointer.  */
+#define RAX_LP	rax
+#define RBP_LP	rbp
+#define RBX_LP	rbx
+#define RCX_LP	rcx
+#define RDI_LP	rdi
+#define RDX_LP	rdx
+#define RSI_LP	rsi
+#define RSP_LP	rsp
+#define R8_LP	r8
+#define R9_LP	r9
+#define R10_LP	r10
+#define R11_LP	r11
+#define R12_LP	r12
+#define R13_LP	r13
+#define R14_LP	r14
+#define R15_LP	r15
+
+#else	/* __ASSEMBLER__ */
+
+/* Long and pointer size in bytes.  */
+#define LP_SIZE "8"
+
+/* Assembler address directive. */
+#define ASM_ADDR ".quad"
+
+/* Instruction to operate on long and pointer.  */
+#define LP_OP(insn) #insn "q"
+
+/* Registers to hold long and pointer.  */
+#define RAX_LP	"rax"
+#define RBP_LP	"rbp"
+#define RBX_LP	"rbx"
+#define RCX_LP	"rcx"
+#define RDI_LP	"rdi"
+#define RDX_LP	"rdx"
+#define RSI_LP	"rsi"
+#define RSP_LP	"rsp"
+#define R8_LP	"r8"
+#define R9_LP	"r9"
+#define R10_LP	"r10"
+#define R11_LP	"r11"
+#define R12_LP	"r12"
+#define R13_LP	"r13"
+#define R14_LP	"r14"
+#define R15_LP	"r15"
+
 #endif	/* __ASSEMBLER__ */
diff --git a/sysdeps/x86_64/x32/Implies b/sysdeps/x86_64/x32/Implies
new file mode 100644
index 0000000..6d48462
--- /dev/null
+++ b/sysdeps/x86_64/x32/Implies
@@ -0,0 +1,6 @@
+x86_64/fpu
+wordsize-32
+ieee754/ldbl-96
+ieee754/dbl-64/wordsize-64
+ieee754/dbl-64
+ieee754/flt-32
diff --git a/sysdeps/x86_64/x32/Makefile b/sysdeps/x86_64/x32/Makefile
new file mode 100644
index 0000000..5b3ac54
--- /dev/null
+++ b/sysdeps/x86_64/x32/Makefile
@@ -0,0 +1,3 @@
+ifeq ($(subdir),malloc)
+CFLAGS-malloc.c += -DMALLOC_ALIGNMENT=16
+endif
diff --git a/sysdeps/x86_64/x32/bits/wordsize.h b/sysdeps/x86_64/x32/bits/wordsize.h
new file mode 100644
index 0000000..9b38756
--- /dev/null
+++ b/sysdeps/x86_64/x32/bits/wordsize.h
@@ -0,0 +1,8 @@
+/* Determine the wordsize from the preprocessor defines.  */
+
+#if defined __x86_64__ && !defined __ILP32__
+# define __WORDSIZE	64
+# define __WORDSIZE_COMPAT32	1
+#else
+# define __WORDSIZE	32
+#endif
diff --git a/sysdeps/x86_64/x32/divdi3.c b/sysdeps/x86_64/x32/divdi3.c
new file mode 100644
index 0000000..bc7b4c4
--- /dev/null
+++ b/sysdeps/x86_64/x32/divdi3.c
@@ -0,0 +1 @@
+/* Fortunately nothing to do.  */
diff --git a/sysdeps/x86_64/x32/dl-machine.h b/sysdeps/x86_64/x32/dl-machine.h
new file mode 100644
index 0000000..2364910
--- /dev/null
+++ b/sysdeps/x86_64/x32/dl-machine.h
@@ -0,0 +1,86 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  x32 version.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/x86_64/dl-machine.h>
+
+#ifndef x32_dl_machine_h
+#define x32_dl_machine_h
+
+#undef ARCH_LA_PLTENTER
+#undef ARCH_LA_PLTEXIT
+#undef RTLD_START
+
+/* Names of the architecture-specific auditing callback functions.  */
+#define ARCH_LA_PLTENTER x32_gnu_pltenter
+#define ARCH_LA_PLTEXIT x32_gnu_pltexit
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+#define RTLD_START asm ("\n\
+.text\n\
+	.align 16\n\
+.globl _start\n\
+.globl _dl_start_user\n\
+_start:\n\
+	movl %esp, %edi\n\
+	call _dl_start\n\
+_dl_start_user:\n\
+	# Save the user entry point address in %r12.\n\
+	movl %eax, %r12d\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	movl _dl_skip_args(%rip), %eax\n\
+	# Pop the original argument count.\n\
+	movl (%rsp), %edx\n\
+	addl $4,%esp\n\
+	# Adjust the stack pointer to skip _dl_skip_args words.\n\
+	lea (%rsp,%rax,4), %esp\n\
+	# Subtract _dl_skip_args from argc.\n\
+	subl %eax, %edx\n\
+	# Push argc back on the stack.\n\
+	subl $4,%esp\n\
+	movl %edx, (%rsp)\n\
+	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env)\n\
+	# argc -> rsi\n\
+	movl %edx, %esi\n\
+	# Save %rsp value in %r13.\n\
+	movl %esp, %r13d\n\
+	# And align stack for the _dl_init_internal call. \n\
+	and $-16, %esp\n\
+	# _dl_loaded -> rdi\n\
+	movl _rtld_local(%rip), %edi\n\
+	# env -> rcx\n\
+	lea 8(%r13,%rdx,4), %ecx\n\
+	# argv -> rdx\n\
+	lea 4(%r13), %edx\n\
+	# Clear %rbp to mark outermost frame obviously even for constructors.\n\
+	xorl %ebp, %ebp\n\
+	# Call the function to run the initializers.\n\
+	call _dl_init_internal@PLT\n\
+	# Pass our finalizer function to the user in %rdx, as per ELF ABI.\n\
+	lea _dl_fini(%rip), %edx\n\
+	# And make sure %rsp points to argc stored on the stack.\n\
+	movl %r13d, %esp\n\
+	# Jump to the user's entry point.\n\
+	jmp *%r12\n\
+.previous\n\
+");
+
+#endif /* !x32_dl_machine_h */
diff --git a/sysdeps/x86_64/x32/ffs.c b/sysdeps/x86_64/x32/ffs.c
new file mode 100644
index 0000000..393f501
--- /dev/null
+++ b/sysdeps/x86_64/x32/ffs.c
@@ -0,0 +1 @@
+#include <sysdeps/i386/i686/ffs.c>
diff --git a/sysdeps/x86_64/x32/gmp-mparam.h b/sysdeps/x86_64/x32/gmp-mparam.h
new file mode 100644
index 0000000..33cb36e
--- /dev/null
+++ b/sysdeps/x86_64/x32/gmp-mparam.h
@@ -0,0 +1,33 @@
+/* gmp-mparam.h -- Compiler/machine parameter header file.
+
+Copyright (C) 2011 Free Software Foundation, Inc.
+
+This file is part of the GNU MP Library.
+
+The GNU MP Library is free software; you can redistribute it and/or modify
+it under the terms of the GNU Lesser General Public License as published by
+the Free Software Foundation; either version 2.1 of the License, or (at your
+option) any later version.
+
+The GNU MP Library is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+License for more details.
+
+You should have received a copy of the GNU Lesser General Public License
+along with the GNU MP Library; see the file COPYING.LIB.  If not, write to
+the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
+
+#if defined __GMP_H__ && ! defined _LONG_LONG_LIMB
+#error "Included too late for _LONG_LONG_LIMB to take effect"
+#endif
+
+#define _LONG_LONG_LIMB
+#define BITS_PER_MP_LIMB 64
+#define BYTES_PER_MP_LIMB 8
+#define BITS_PER_LONGINT __WORDSIZE
+#define BITS_PER_INT 32
+#define BITS_PER_SHORTINT 16
+#define BITS_PER_CHAR 8
+/* Prefer long long.  */
+#define PREFER_LONG_LONG
diff --git a/sysdeps/x86_64/x32/shlib-versions b/sysdeps/x86_64/x32/shlib-versions
new file mode 100644
index 0000000..c30aeef
--- /dev/null
+++ b/sysdeps/x86_64/x32/shlib-versions
@@ -0,0 +1,3 @@
+x86_64-.*-linux.*       DEFAULT			GLIBC_2.16
+x86_64-.*-linux.*	ld=ld-linux-x32.so.2	GLIBC_2.16
+x86_64-.*-.*		ABI			x32-@OS@
diff --git a/sysdeps/x86_64/x32/symbol-hacks.h b/sysdeps/x86_64/x32/symbol-hacks.h
new file mode 100644
index 0000000..bc7b4c4
--- /dev/null
+++ b/sysdeps/x86_64/x32/symbol-hacks.h
@@ -0,0 +1 @@
+/* Fortunately nothing to do.  */
diff --git a/sysdeps/x86_64/x32/sysdep.h b/sysdeps/x86_64/x32/sysdep.h
new file mode 100644
index 0000000..d8c87d9
--- /dev/null
+++ b/sysdeps/x86_64/x32/sysdep.h
@@ -0,0 +1,91 @@
+/* Assembler macros for x32.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#undef LP_SIZE
+#undef LP_OP
+#undef ASM_ADDR
+
+#undef RAX_LP
+#undef RBP_LP
+#undef RBX_LP
+#undef RCX_LP
+#undef RDI_LP
+#undef RDX_LP
+#undef RSP_LP
+#undef RSI_LP
+#undef R8_LP
+#undef R9_LP
+#undef R10_LP
+#undef R11_LP
+#undef R12_LP
+#undef R13_LP
+#undef R14_LP
+#undef R15_LP
+
+#ifdef	__ASSEMBLER__
+
+# define LP_SIZE 4
+
+# define LP_OP(insn) insn##l
+
+# define ASM_ADDR .long
+
+# define RAX_LP	eax
+# define RBP_LP	ebp
+# define RBX_LP	ebx
+# define RCX_LP	ecx
+# define RDI_LP	edi
+# define RDX_LP	edx
+# define RSI_LP	esi
+# define RSP_LP	esp
+# define R8_LP	r8d
+# define R9_LP	r9d
+# define R10_LP	r10d
+# define R11_LP	r11d
+# define R12_LP	r12d
+# define R13_LP	r13d
+# define R14_LP	r14d
+# define R15_LP	r15d
+
+#else	/* __ASSEMBLER__ */
+
+# define LP_SIZE "4"
+
+# define LP_OP(insn) #insn "l"
+
+# define ASM_ADDR ".long"
+
+# define RAX_LP	"eax"
+# define RBP_LP	"ebp"
+# define RBX_LP	"ebx"
+# define RCX_LP	"ecx"
+# define RDI_LP	"edi"
+# define RDX_LP	"edx"
+# define RSI_LP	"esi"
+# define RSP_LP	"esp"
+# define R8_LP	"r8d"
+# define R9_LP	"r9d"
+# define R10_LP	"r10d"
+# define R11_LP	"r11d"
+# define R12_LP	"r12d"
+# define R13_LP	"r13d"
+# define R14_LP	"r14d"
+# define R15_LP	"r15d"
+
+#endif	/* __ASSEMBLER__ */
diff --git a/time/mktime.c b/time/mktime.c
index e47d696..da0a15a 100644
--- a/time/mktime.c
+++ b/time/mktime.c
@@ -22,31 +22,62 @@
    mktime.  */
 /* #define DEBUG 1 */
 
-#ifdef HAVE_CONFIG_H
+#ifndef _LIBC
 # include <config.h>
 #endif
 
 /* Assume that leap seconds are possible, unless told otherwise.
-   If the host has a `zic' command with a `-L leapsecondfilename' option,
+   If the host has a 'zic' command with a '-L leapsecondfilename' option,
    then it supports leap seconds; otherwise it probably doesn't.  */
 #ifndef LEAP_SECONDS_POSSIBLE
 # define LEAP_SECONDS_POSSIBLE 1
 #endif
 
-#include <sys/types.h>		/* Some systems define `time_t' here.  */
 #include <time.h>
 
 #include <limits.h>
 
-#include <string.h>		/* For the real memcpy prototype.  */
+#include <string.h>             /* For the real memcpy prototype.  */
 
 #if DEBUG
 # include <stdio.h>
 # include <stdlib.h>
 /* Make it work even if the system's libc has its own mktime routine.  */
+# undef mktime
 # define mktime my_mktime
 #endif /* DEBUG */
 
+/* Some of the code in this file assumes that signed integer overflow
+   silently wraps around.  This assumption can't easily be programmed
+   around, nor can it be checked for portably at compile-time or
+   easily eliminated at run-time.
+
+   Define WRAPV to 1 if the assumption is valid and if
+     #pragma GCC optimize ("wrapv")
+   does not trigger GCC bug <http://gcc.gnu.org/bugzilla/show_bug.cgi?id=51793>.
+   Otherwise, define it to 0; this forces the use of slower code that,
+   while not guaranteed by the C Standard, works on all production
+   platforms that we know about.  */
+#ifndef WRAPV
+# if ((__GNUC__ == 4 && 4 <= __GNUC_MINOR__) || 4 < __GNUC__) && defined __GLIBC__
+#  pragma GCC optimize ("wrapv")
+#  define WRAPV 1
+# else
+#  define WRAPV 0
+# endif
+#endif
+
+/* Verify a requirement at compile-time (unlike assert, which is runtime).  */
+#define verify(name, assertion) struct name { char a[(assertion) ? 1 : -1]; }
+
+/* A signed type that is at least one bit wider than int.  */
+#if INT_MAX <= LONG_MAX / 2
+typedef long int long_int;
+#else
+typedef long long int long_int;
+#endif
+verify (long_int_is_wide_enough, INT_MAX == INT_MAX * (long_int) 2 / 2);
+
 /* Shift A right by B bits portably, by dividing A by 2**B and
    truncating towards minus infinity.  A and B should be free of side
    effects, and B should be in the range 0 <= B <= INT_BITS - 2, where
@@ -57,9 +88,11 @@
    implementations (e.g., UNICOS 9.0 on a Cray Y-MP EL) don't shift
    right in the usual way when A < 0, so SHR falls back on division if
    ordinary A >> B doesn't seem to be the usual signed shift.  */
-#define SHR(a, b)	\
-  (-1 >> 1 == -1	\
-   ? (a) >> (b)		\
+#define SHR(a, b)                                               \
+  ((-1 >> 1 == -1                                               \
+    && (long_int) -1 >> 1 == -1                                 \
+    && ((time_t) -1 >> 1 == -1 || ! TYPE_SIGNED (time_t)))      \
+   ? (a) >> (b)                                                 \
    : (a) / (1 << (b)) - ((a) % (1 << (b)) < 0))
 
 /* The extra casts in the following macros work around compiler bugs,
@@ -70,12 +103,8 @@
 #define TYPE_IS_INTEGER(t) ((t) 1.5 == 1)
 
 /* True if negative values of the signed integer type T use two's
-   complement, ones' complement, or signed magnitude representation,
-   respectively.  Much GNU code assumes two's complement, but some
-   people like to be portable to all possible C hosts.  */
+   complement, or if T is an unsigned integer type.  */
 #define TYPE_TWOS_COMPLEMENT(t) ((t) ~ (t) 0 == (t) -1)
-#define TYPE_ONES_COMPLEMENT(t) ((t) ~ (t) 0 == 0)
-#define TYPE_SIGNED_MAGNITUDE(t) ((t) ~ (t) 0 < (t) -1)
 
 /* True if the arithmetic type T is signed.  */
 #define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))
@@ -86,14 +115,12 @@
    your host.  */
 #define TYPE_MINIMUM(t) \
   ((t) (! TYPE_SIGNED (t) \
-	? (t) 0 \
-	: TYPE_SIGNED_MAGNITUDE (t) \
-	? ~ (t) 0 \
-	: ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1)))
+        ? (t) 0 \
+        : ~ TYPE_MAXIMUM (t)))
 #define TYPE_MAXIMUM(t) \
   ((t) (! TYPE_SIGNED (t) \
-	? (t) -1 \
-	: ~ (~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))))
+        ? (t) -1 \
+        : ((((t) 1 << (sizeof (t) * CHAR_BIT - 2)) - 1) * 2 + 1)))
 
 #ifndef TIME_T_MIN
 # define TIME_T_MIN TYPE_MINIMUM (time_t)
@@ -103,14 +130,11 @@
 #endif
 #define TIME_T_MIDPOINT (SHR (TIME_T_MIN + TIME_T_MAX, 1) + 1)
 
-/* Verify a requirement at compile-time (unlike assert, which is runtime).  */
-#define verify(name, assertion) struct name { char a[(assertion) ? 1 : -1]; }
-
 verify (time_t_is_integer, TYPE_IS_INTEGER (time_t));
-verify (twos_complement_arithmetic, TYPE_TWOS_COMPLEMENT (int));
-/* The code also assumes that signed integer overflow silently wraps
-   around, but this assumption can't be stated without causing a
-   diagnostic on some hosts.  */
+verify (twos_complement_arithmetic,
+        (TYPE_TWOS_COMPLEMENT (int)
+         && TYPE_TWOS_COMPLEMENT (long_int)
+         && TYPE_TWOS_COMPLEMENT (time_t)));
 
 #define EPOCH_YEAR 1970
 #define TM_YEAR_BASE 1900
@@ -118,14 +142,14 @@ verify (base_year_is_a_multiple_of_100, TM_YEAR_BASE % 100 == 0);
 
 /* Return 1 if YEAR + TM_YEAR_BASE is a leap year.  */
 static inline int
-leapyear (long int year)
+leapyear (long_int year)
 {
   /* Don't add YEAR to TM_YEAR_BASE, as that might overflow.
      Also, work even if YEAR is negative.  */
   return
     ((year & 3) == 0
      && (year % 100 != 0
-	 || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));
+         || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));
 }
 
 /* How many days come before each month (0-12).  */
@@ -142,16 +166,24 @@ const unsigned short int __mon_yday[2][13] =
 
 
 #ifndef _LIBC
-/* Portable standalone applications should supply a "time_r.h" that
+/* Portable standalone applications should supply a <time.h> that
    declares a POSIX-compliant localtime_r, for the benefit of older
    implementations that lack localtime_r or have a nonstandard one.
    See the gnulib time_r module for one way to implement this.  */
-# include "time_r.h"
 # undef __localtime_r
 # define __localtime_r localtime_r
 # define __mktime_internal mktime_internal
+# include "mktime-internal.h"
 #endif
 
+/* Return 1 if the values A and B differ according to the rules for
+   tm_isdst: A and B differ if one is zero and the other positive.  */
+static int
+isdst_differ (int a, int b)
+{
+  return (!a != !b) & (0 <= a) & (0 <= b);
+}
+
 /* Return an integer value measuring (YEAR1-YDAY1 HOUR1:MIN1:SEC1) -
    (YEAR0-YDAY0 HOUR0:MIN0:SEC0) in seconds, assuming that the clocks
    were not adjusted between the time stamps.
@@ -164,12 +196,10 @@ const unsigned short int __mon_yday[2][13] =
    detect overflow.  */
 
 static inline time_t
-ydhms_diff (long int year1, long int yday1, int hour1, int min1, int sec1,
-	    int year0, int yday0, int hour0, int min0, int sec0)
+ydhms_diff (long_int year1, long_int yday1, int hour1, int min1, int sec1,
+            int year0, int yday0, int hour0, int min0, int sec0)
 {
   verify (C99_integer_division, -1 / 2 == 0);
-  verify (long_int_year_and_yday_are_wide_enough,
-	  INT_MAX <= LONG_MAX / 2 || TIME_T_MAX <= UINT_MAX);
 
   /* Compute intervening leap days correctly even if year is negative.
      Take care to avoid integer overflow here.  */
@@ -192,6 +222,53 @@ ydhms_diff (long int year1, long int yday1, int hour1, int min1, int sec1,
   return seconds;
 }
 
+/* Return the average of A and B, even if A + B would overflow.  */
+static time_t
+time_t_avg (time_t a, time_t b)
+{
+  return SHR (a, 1) + SHR (b, 1) + (a & b & 1);
+}
+
+/* Return 1 if A + B does not overflow.  If time_t is unsigned and if
+   B's top bit is set, assume that the sum represents A - -B, and
+   return 1 if the subtraction does not wrap around.  */
+static int
+time_t_add_ok (time_t a, time_t b)
+{
+  if (! TYPE_SIGNED (time_t))
+    {
+      time_t sum = a + b;
+      return (sum < a) == (TIME_T_MIDPOINT <= b);
+    }
+  else if (WRAPV)
+    {
+      time_t sum = a + b;
+      return (sum < a) == (b < 0);
+    }
+  else
+    {
+      time_t avg = time_t_avg (a, b);
+      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;
+    }
+}
+
+/* Return 1 if A + B does not overflow.  */
+static int
+time_t_int_add_ok (time_t a, int b)
+{
+  verify (int_no_wider_than_time_t, INT_MAX <= TIME_T_MAX);
+  if (WRAPV)
+    {
+      time_t sum = a + b;
+      return (sum < a) == (b < 0);
+    }
+  else
+    {
+      int a_odd = a & 1;
+      time_t avg = SHR (a, 1) + (SHR (b, 1) + (a_odd & b));
+      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;
+    }
+}
 
 /* Return a time_t value corresponding to (YEAR-YDAY HOUR:MIN:SEC),
    assuming that *T corresponds to *TP and that no clock adjustments
@@ -200,17 +277,16 @@ ydhms_diff (long int year1, long int yday1, int hour1, int min1, int sec1,
    If overflow occurs, yield the minimal or maximal value, except do not
    yield a value equal to *T.  */
 static time_t
-guess_time_tm (long int year, long int yday, int hour, int min, int sec,
-	       const time_t *t, const struct tm *tp)
+guess_time_tm (long_int year, long_int yday, int hour, int min, int sec,
+               const time_t *t, const struct tm *tp)
 {
   if (tp)
     {
       time_t d = ydhms_diff (year, yday, hour, min, sec,
-			     tp->tm_year, tp->tm_yday,
-			     tp->tm_hour, tp->tm_min, tp->tm_sec);
-      time_t t1 = *t + d;
-      if ((t1 < *t) == (TYPE_SIGNED (time_t) ? d < 0 : TIME_T_MAX / 2 < d))
-	return t1;
+                             tp->tm_year, tp->tm_yday,
+                             tp->tm_hour, tp->tm_min, tp->tm_sec);
+      if (time_t_add_ok (*t, d))
+        return *t + d;
     }
 
   /* Overflow occurred one way or another.  Return the nearest result
@@ -219,8 +295,8 @@ guess_time_tm (long int year, long int yday, int hour, int min, int sec,
      match; and don't oscillate between two values, as that would
      confuse the spring-forward gap detector.  */
   return (*t < TIME_T_MIDPOINT
-	  ? (*t <= TIME_T_MIN + 1 ? *t + 1 : TIME_T_MIN)
-	  : (TIME_T_MAX - 1 <= *t ? *t - 1 : TIME_T_MAX));
+          ? (*t <= TIME_T_MIN + 1 ? *t + 1 : TIME_T_MIN)
+          : (TIME_T_MAX - 1 <= *t ? *t - 1 : TIME_T_MAX));
 }
 
 /* Use CONVERT to convert *T to a broken down time in *TP.
@@ -228,7 +304,7 @@ guess_time_tm (long int year, long int yday, int hour, int min, int sec,
    it is the nearest in-range value and then convert that.  */
 static struct tm *
 ranged_convert (struct tm *(*convert) (const time_t *, struct tm *),
-		time_t *t, struct tm *tp)
+                time_t *t, struct tm *tp)
 {
   struct tm *r = convert (t, tp);
 
@@ -238,27 +314,25 @@ ranged_convert (struct tm *(*convert) (const time_t *, struct tm *),
       time_t ok = 0;
 
       /* BAD is a known unconvertible time_t, and OK is a known good one.
-	 Use binary search to narrow the range between BAD and OK until
-	 they differ by 1.  */
+         Use binary search to narrow the range between BAD and OK until
+         they differ by 1.  */
       while (bad != ok + (bad < 0 ? -1 : 1))
-	{
-	  time_t mid = *t = (bad < 0
-			     ? bad + ((ok - bad) >> 1)
-			     : ok + ((bad - ok) >> 1));
-	  r = convert (t, tp);
-	  if (r)
-	    ok = mid;
-	  else
-	    bad = mid;
-	}
+        {
+          time_t mid = *t = time_t_avg (ok, bad);
+          r = convert (t, tp);
+          if (r)
+            ok = mid;
+          else
+            bad = mid;
+        }
 
       if (!r && ok)
-	{
-	  /* The last conversion attempt failed;
-	     revert to the most recent successful attempt.  */
-	  *t = ok;
-	  r = convert (t, tp);
-	}
+        {
+          /* The last conversion attempt failed;
+             revert to the most recent successful attempt.  */
+          *t = ok;
+          r = convert (t, tp);
+        }
     }
 
   return r;
@@ -273,8 +347,8 @@ ranged_convert (struct tm *(*convert) (const time_t *, struct tm *),
    This function is external because it is used also by timegm.c.  */
 time_t
 __mktime_internal (struct tm *tp,
-		   struct tm *(*convert) (const time_t *, struct tm *),
-		   time_t *offset)
+                   struct tm *(*convert) (const time_t *, struct tm *),
+                   time_t *offset)
 {
   time_t t, gt, t0, t1, t2;
   struct tm tm;
@@ -293,9 +367,7 @@ __mktime_internal (struct tm *tp,
   int mday = tp->tm_mday;
   int mon = tp->tm_mon;
   int year_requested = tp->tm_year;
-  /* Normalize the value.  */
-  int isdst = ((tp->tm_isdst >> (8 * sizeof (tp->tm_isdst) - 1))
-	       | (tp->tm_isdst != 0));
+  int isdst = tp->tm_isdst;
 
   /* 1 if the previous probe was DST.  */
   int dst2;
@@ -304,8 +376,8 @@ __mktime_internal (struct tm *tp,
   int mon_remainder = mon % 12;
   int negative_mon_remainder = mon_remainder < 0;
   int mon_years = mon / 12 - negative_mon_remainder;
-  long int lyear_requested = year_requested;
-  long int year = lyear_requested + mon_years;
+  long_int lyear_requested = year_requested;
+  long_int year = lyear_requested + mon_years;
 
   /* The other values need not be in range:
      the remaining code handles minor overflows correctly,
@@ -315,10 +387,10 @@ __mktime_internal (struct tm *tp,
   /* Calculate day of year from year, month, and day of month.
      The result need not be in range.  */
   int mon_yday = ((__mon_yday[leapyear (year)]
-		   [mon_remainder + 12 * negative_mon_remainder])
-		  - 1);
-  long int lmday = mday;
-  long int yday = mon_yday + lmday;
+                   [mon_remainder + 12 * negative_mon_remainder])
+                  - 1);
+  long_int lmday = mday;
+  long_int yday = mon_yday + lmday;
 
   time_t guessed_offset = *offset;
 
@@ -327,33 +399,33 @@ __mktime_internal (struct tm *tp,
   if (LEAP_SECONDS_POSSIBLE)
     {
       /* Handle out-of-range seconds specially,
-	 since ydhms_tm_diff assumes every minute has 60 seconds.  */
+         since ydhms_tm_diff assumes every minute has 60 seconds.  */
       if (sec < 0)
-	sec = 0;
+        sec = 0;
       if (59 < sec)
-	sec = 59;
+        sec = 59;
     }
 
   /* Invert CONVERT by probing.  First assume the same offset as last
      time.  */
 
   t0 = ydhms_diff (year, yday, hour, min, sec,
-		   EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, - guessed_offset);
+                   EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, - guessed_offset);
 
   if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)
     {
       /* time_t isn't large enough to rule out overflows, so check
-	 for major overflows.  A gross check suffices, since if t0
-	 has overflowed, it is off by a multiple of TIME_T_MAX -
-	 TIME_T_MIN + 1.  So ignore any component of the difference
-	 that is bounded by a small value.  */
+         for major overflows.  A gross check suffices, since if t0
+         has overflowed, it is off by a multiple of TIME_T_MAX -
+         TIME_T_MIN + 1.  So ignore any component of the difference
+         that is bounded by a small value.  */
 
       /* Approximate log base 2 of the number of time units per
-	 biennium.  A biennium is 2 years; use this unit instead of
-	 years to avoid integer overflow.  For example, 2 average
-	 Gregorian years are 2 * 365.2425 * 24 * 60 * 60 seconds,
-	 which is 63113904 seconds, and rint (log2 (63113904)) is
-	 26.  */
+         biennium.  A biennium is 2 years; use this unit instead of
+         years to avoid integer overflow.  For example, 2 average
+         Gregorian years are 2 * 365.2425 * 24 * 60 * 60 seconds,
+         which is 63113904 seconds, and rint (log2 (63113904)) is
+         26.  */
       int ALOG2_SECONDS_PER_BIENNIUM = 26;
       int ALOG2_MINUTES_PER_BIENNIUM = 20;
       int ALOG2_HOURS_PER_BIENNIUM = 14;
@@ -361,119 +433,117 @@ __mktime_internal (struct tm *tp,
       int LOG2_YEARS_PER_BIENNIUM = 1;
 
       int approx_requested_biennia =
-	(SHR (year_requested, LOG2_YEARS_PER_BIENNIUM)
-	 - SHR (EPOCH_YEAR - TM_YEAR_BASE, LOG2_YEARS_PER_BIENNIUM)
-	 + SHR (mday, ALOG2_DAYS_PER_BIENNIUM)
-	 + SHR (hour, ALOG2_HOURS_PER_BIENNIUM)
-	 + SHR (min, ALOG2_MINUTES_PER_BIENNIUM)
-	 + (LEAP_SECONDS_POSSIBLE
-	    ? 0
-	    : SHR (sec, ALOG2_SECONDS_PER_BIENNIUM)));
+        (SHR (year_requested, LOG2_YEARS_PER_BIENNIUM)
+         - SHR (EPOCH_YEAR - TM_YEAR_BASE, LOG2_YEARS_PER_BIENNIUM)
+         + SHR (mday, ALOG2_DAYS_PER_BIENNIUM)
+         + SHR (hour, ALOG2_HOURS_PER_BIENNIUM)
+         + SHR (min, ALOG2_MINUTES_PER_BIENNIUM)
+         + (LEAP_SECONDS_POSSIBLE
+            ? 0
+            : SHR (sec, ALOG2_SECONDS_PER_BIENNIUM)));
 
       int approx_biennia = SHR (t0, ALOG2_SECONDS_PER_BIENNIUM);
       int diff = approx_biennia - approx_requested_biennia;
-      int abs_diff = diff < 0 ? - diff : diff;
+      int abs_diff = diff < 0 ? -1 - diff : diff;
 
       /* IRIX 4.0.5 cc miscalculates TIME_T_MIN / 3: it erroneously
-	 gives a positive value of 715827882.  Setting a variable
-	 first then doing math on it seems to work.
-	 (ghazi@caip.rutgers.edu) */
+         gives a positive value of 715827882.  Setting a variable
+         first then doing math on it seems to work.
+         (ghazi@caip.rutgers.edu) */
       time_t time_t_max = TIME_T_MAX;
       time_t time_t_min = TIME_T_MIN;
       time_t overflow_threshold =
-	(time_t_max / 3 - time_t_min / 3) >> ALOG2_SECONDS_PER_BIENNIUM;
+        (time_t_max / 3 - time_t_min / 3) >> ALOG2_SECONDS_PER_BIENNIUM;
 
       if (overflow_threshold < abs_diff)
-	{
-	  /* Overflow occurred.  Try repairing it; this might work if
-	     the time zone offset is enough to undo the overflow.  */
-	  time_t repaired_t0 = -1 - t0;
-	  approx_biennia = SHR (repaired_t0, ALOG2_SECONDS_PER_BIENNIUM);
-	  diff = approx_biennia - approx_requested_biennia;
-	  abs_diff = diff < 0 ? - diff : diff;
-	  if (overflow_threshold < abs_diff)
-	    return -1;
-	  guessed_offset += repaired_t0 - t0;
-	  t0 = repaired_t0;
-	}
+        {
+          /* Overflow occurred.  Try repairing it; this might work if
+             the time zone offset is enough to undo the overflow.  */
+          time_t repaired_t0 = -1 - t0;
+          approx_biennia = SHR (repaired_t0, ALOG2_SECONDS_PER_BIENNIUM);
+          diff = approx_biennia - approx_requested_biennia;
+          abs_diff = diff < 0 ? -1 - diff : diff;
+          if (overflow_threshold < abs_diff)
+            return -1;
+          guessed_offset += repaired_t0 - t0;
+          t0 = repaired_t0;
+        }
     }
 
   /* Repeatedly use the error to improve the guess.  */
 
   for (t = t1 = t2 = t0, dst2 = 0;
        (gt = guess_time_tm (year, yday, hour, min, sec, &t,
-			    ranged_convert (convert, &t, &tm)),
-	t != gt);
+                            ranged_convert (convert, &t, &tm)),
+        t != gt);
        t1 = t2, t2 = t, t = gt, dst2 = tm.tm_isdst != 0)
     if (t == t1 && t != t2
-	&& (tm.tm_isdst < 0
-	    || (isdst < 0
-		? dst2 <= (tm.tm_isdst != 0)
-		: (isdst != 0) != (tm.tm_isdst != 0))))
+        && (tm.tm_isdst < 0
+            || (isdst < 0
+                ? dst2 <= (tm.tm_isdst != 0)
+                : (isdst != 0) != (tm.tm_isdst != 0))))
       /* We can't possibly find a match, as we are oscillating
-	 between two values.  The requested time probably falls
-	 within a spring-forward gap of size GT - T.  Follow the common
-	 practice in this case, which is to return a time that is GT - T
-	 away from the requested time, preferring a time whose
-	 tm_isdst differs from the requested value.  (If no tm_isdst
-	 was requested and only one of the two values has a nonzero
-	 tm_isdst, prefer that value.)  In practice, this is more
-	 useful than returning -1.  */
+         between two values.  The requested time probably falls
+         within a spring-forward gap of size GT - T.  Follow the common
+         practice in this case, which is to return a time that is GT - T
+         away from the requested time, preferring a time whose
+         tm_isdst differs from the requested value.  (If no tm_isdst
+         was requested and only one of the two values has a nonzero
+         tm_isdst, prefer that value.)  In practice, this is more
+         useful than returning -1.  */
       goto offset_found;
     else if (--remaining_probes == 0)
       return -1;
 
   /* We have a match.  Check whether tm.tm_isdst has the requested
      value, if any.  */
-  if (isdst != tm.tm_isdst && 0 <= isdst && 0 <= tm.tm_isdst)
+  if (isdst_differ (isdst, tm.tm_isdst))
     {
       /* tm.tm_isdst has the wrong value.  Look for a neighboring
-	 time with the right value, and use its UTC offset.
+         time with the right value, and use its UTC offset.
 
-	 Heuristic: probe the adjacent timestamps in both directions,
-	 looking for the desired isdst.  This should work for all real
-	 time zone histories in the tz database.  */
+         Heuristic: probe the adjacent timestamps in both directions,
+         looking for the desired isdst.  This should work for all real
+         time zone histories in the tz database.  */
 
       /* Distance between probes when looking for a DST boundary.  In
-	 tzdata2003a, the shortest period of DST is 601200 seconds
-	 (e.g., America/Recife starting 2000-10-08 01:00), and the
-	 shortest period of non-DST surrounded by DST is 694800
-	 seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the
-	 minimum of these two values, so we don't miss these short
-	 periods when probing.  */
+         tzdata2003a, the shortest period of DST is 601200 seconds
+         (e.g., America/Recife starting 2000-10-08 01:00), and the
+         shortest period of non-DST surrounded by DST is 694800
+         seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the
+         minimum of these two values, so we don't miss these short
+         periods when probing.  */
       int stride = 601200;
 
       /* The longest period of DST in tzdata2003a is 536454000 seconds
-	 (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest
-	 period of non-DST is much longer, but it makes no real sense
-	 to search for more than a year of non-DST, so use the DST
-	 max.  */
+         (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest
+         period of non-DST is much longer, but it makes no real sense
+         to search for more than a year of non-DST, so use the DST
+         max.  */
       int duration_max = 536454000;
 
       /* Search in both directions, so the maximum distance is half
-	 the duration; add the stride to avoid off-by-1 problems.  */
+         the duration; add the stride to avoid off-by-1 problems.  */
       int delta_bound = duration_max / 2 + stride;
 
       int delta, direction;
 
       for (delta = stride; delta < delta_bound; delta += stride)
-	for (direction = -1; direction <= 1; direction += 2)
-	  {
-	    time_t ot = t + delta * direction;
-	    if ((ot < t) == (direction < 0))
-	      {
-		struct tm otm;
-		ranged_convert (convert, &ot, &otm);
-		if (otm.tm_isdst == isdst)
-		  {
-		    /* We found the desired tm_isdst.
-		       Extrapolate back to the desired time.  */
-		    t = guess_time_tm (year, yday, hour, min, sec, &ot, &otm);
-		    ranged_convert (convert, &t, &tm);
-		    goto offset_found;
-		  }
-	      }
-	  }
+        for (direction = -1; direction <= 1; direction += 2)
+          if (time_t_int_add_ok (t, delta * direction))
+            {
+              time_t ot = t + delta * direction;
+              struct tm otm;
+              ranged_convert (convert, &ot, &otm);
+              if (! isdst_differ (isdst, otm.tm_isdst))
+                {
+                  /* We found the desired tm_isdst.
+                     Extrapolate back to the desired time.  */
+                  t = guess_time_tm (year, yday, hour, min, sec, &ot, &otm);
+                  ranged_convert (convert, &t, &tm);
+                  goto offset_found;
+                }
+            }
     }
 
  offset_found:
@@ -482,14 +552,16 @@ __mktime_internal (struct tm *tp,
   if (LEAP_SECONDS_POSSIBLE && sec_requested != tm.tm_sec)
     {
       /* Adjust time to reflect the tm_sec requested, not the normalized value.
-	 Also, repair any damage from a false match due to a leap second.  */
+         Also, repair any damage from a false match due to a leap second.  */
       int sec_adjustment = (sec == 0 && tm.tm_sec == 60) - sec;
+      if (! time_t_int_add_ok (t, sec_requested))
+        return -1;
       t1 = t + sec_requested;
+      if (! time_t_int_add_ok (t1, sec_adjustment))
+        return -1;
       t2 = t1 + sec_adjustment;
-      if (((t1 < t) != (sec_requested < 0))
-	  | ((t2 < t1) != (sec_adjustment < 0))
-	  | ! convert (&t2, &tm))
-	return -1;
+      if (! convert (&t2, &tm))
+        return -1;
       t = t2;
     }
 
@@ -510,7 +582,7 @@ mktime (struct tm *tp)
 {
 #ifdef _LIBC
   /* POSIX.1 8.1.1 requires that whenever mktime() is called, the
-     time zone names contained in the external variable `tzname' shall
+     time zone names contained in the external variable 'tzname' shall
      be set as if the tzset() function had been called.  */
   __tzset ();
 #endif
@@ -533,13 +605,13 @@ static int
 not_equal_tm (const struct tm *a, const struct tm *b)
 {
   return ((a->tm_sec ^ b->tm_sec)
-	  | (a->tm_min ^ b->tm_min)
-	  | (a->tm_hour ^ b->tm_hour)
-	  | (a->tm_mday ^ b->tm_mday)
-	  | (a->tm_mon ^ b->tm_mon)
-	  | (a->tm_year ^ b->tm_year)
-	  | (a->tm_yday ^ b->tm_yday)
-	  | (a->tm_isdst ^ b->tm_isdst));
+          | (a->tm_min ^ b->tm_min)
+          | (a->tm_hour ^ b->tm_hour)
+          | (a->tm_mday ^ b->tm_mday)
+          | (a->tm_mon ^ b->tm_mon)
+          | (a->tm_year ^ b->tm_year)
+          | (a->tm_yday ^ b->tm_yday)
+          | isdst_differ (a->tm_isdst, b->tm_isdst));
 }
 
 static void
@@ -547,9 +619,9 @@ print_tm (const struct tm *tp)
 {
   if (tp)
     printf ("%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d",
-	    tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,
-	    tp->tm_hour, tp->tm_min, tp->tm_sec,
-	    tp->tm_yday, tp->tm_wday, tp->tm_isdst);
+            tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,
+            tp->tm_hour, tp->tm_min, tp->tm_sec,
+            tp->tm_yday, tp->tm_wday, tp->tm_isdst);
   else
     printf ("0");
 }
@@ -581,11 +653,11 @@ main (int argc, char **argv)
 
   if ((argc == 3 || argc == 4)
       && (sscanf (argv[1], "%d-%d-%d%c",
-		  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)
-	  == 3)
+                  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)
+          == 3)
       && (sscanf (argv[2], "%d:%d:%d%c",
-		  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)
-	  == 3))
+                  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)
+          == 3))
     {
       tm.tm_year -= TM_YEAR_BASE;
       tm.tm_mon--;
@@ -594,10 +666,10 @@ main (int argc, char **argv)
       tl = mktime (&tmk);
       lt = localtime (&tl);
       if (lt)
-	{
-	  tml = *lt;
-	  lt = &tml;
-	}
+        {
+          tml = *lt;
+          lt = &tml;
+        }
       printf ("mktime returns %ld == ", (long int) tl);
       print_tm (&tmk);
       printf ("\n");
@@ -610,51 +682,51 @@ main (int argc, char **argv)
       time_t to = atol (argv[3]);
 
       if (argc == 4)
-	for (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)
-	  {
-	    lt = localtime (&tl);
-	    if (lt)
-	      {
-		tmk = tml = *lt;
-		tk = mktime (&tmk);
-		status |= check_result (tk, tmk, tl, &tml);
-	      }
-	    else
-	      {
-		printf ("localtime (%ld) yields 0\n", (long int) tl);
-		status = 1;
-	      }
-	    tl1 = tl + by;
-	    if ((tl1 < tl) != (by < 0))
-	      break;
-	  }
+        for (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)
+          {
+            lt = localtime (&tl);
+            if (lt)
+              {
+                tmk = tml = *lt;
+                tk = mktime (&tmk);
+                status |= check_result (tk, tmk, tl, &tml);
+              }
+            else
+              {
+                printf ("localtime (%ld) yields 0\n", (long int) tl);
+                status = 1;
+              }
+            tl1 = tl + by;
+            if ((tl1 < tl) != (by < 0))
+              break;
+          }
       else
-	for (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)
-	  {
-	    /* Null benchmark.  */
-	    lt = localtime (&tl);
-	    if (lt)
-	      {
-		tmk = tml = *lt;
-		tk = tl;
-		status |= check_result (tk, tmk, tl, &tml);
-	      }
-	    else
-	      {
-		printf ("localtime (%ld) yields 0\n", (long int) tl);
-		status = 1;
-	      }
-	    tl1 = tl + by;
-	    if ((tl1 < tl) != (by < 0))
-	      break;
-	  }
+        for (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)
+          {
+            /* Null benchmark.  */
+            lt = localtime (&tl);
+            if (lt)
+              {
+                tmk = tml = *lt;
+                tk = tl;
+                status |= check_result (tk, tmk, tl, &tml);
+              }
+            else
+              {
+                printf ("localtime (%ld) yields 0\n", (long int) tl);
+                status = 1;
+              }
+            tl1 = tl + by;
+            if ((tl1 < tl) != (by < 0))
+              break;
+          }
     }
   else
     printf ("Usage:\
 \t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\n\
 \t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\n\
 \t%s FROM BY TO - # Do not test those values (for benchmark).\n",
-	    argv[0], argv[0], argv[0]);
+            argv[0], argv[0], argv[0]);
 
   return status;
 }
@@ -663,6 +735,6 @@ main (int argc, char **argv)
 
 /*
 Local Variables:
-compile-command: "gcc -DDEBUG -Wall -W -O -g mktime.c -o mktime"
+compile-command: "gcc -DDEBUG -I. -Wall -W -O2 -g mktime.c -o mktime"
 End:
 */
diff --git a/time/offtime.c b/time/offtime.c
index c0b1db5..703ae9e 100644
--- a/time/offtime.c
+++ b/time/offtime.c
@@ -32,7 +32,7 @@ __offtime (t, offset, tp)
      long int offset;
      struct tm *tp;
 {
-  long int days, rem, y;
+  time_t days, rem, y;
   const unsigned short int *ip;
 
   days = *t / SECS_PER_DAY;
@@ -64,7 +64,7 @@ __offtime (t, offset, tp)
   while (days < 0 || days >= (__isleap (y) ? 366 : 365))
     {
       /* Guess a corrected year, assuming 365 days per year.  */
-      long int yg = y + days / 365 - (days % 365 < 0);
+      time_t yg = y + days / 365 - (days % 365 < 0);
 
       /* Adjust DAYS and Y to match the guessed year.  */
       days -= ((yg - y) * 365
diff --git a/time/time.h b/time/time.h
index fee8d27..c448ee2 100644
--- a/time/time.h
+++ b/time/time.h
@@ -120,7 +120,7 @@ typedef __timer_t timer_t;
 struct timespec
   {
     __time_t tv_sec;		/* Seconds.  */
-    long int tv_nsec;		/* Nanoseconds.  */
+    __snseconds_t tv_nsec;	/* Nanoseconds.  */
   };
 
 #endif /* timespec not defined and <time.h> or need timespec.  */
diff --git a/sysdeps/x86_64/strtok.S b/sysdeps/x86_64/strtok.S
index 150f4d6..fe4a947 100644
--- a/sysdeps/x86_64/strtok.S
+++ b/sysdeps/x86_64/strtok.S
@@ -1,6 +1,6 @@
 /* strtok (str, delim) -- Return next DELIM separated token from STR.
    For AMD x86-64.
-   Copyright (C) 1998,2000-2003,2005,2006 Free Software Foundation, Inc.
+   Copyright (C) 1998-2012 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Based on i686 version contributed by Ulrich Drepper
    <drepper@cygnus.com>, 1998.
@@ -45,9 +45,9 @@
 	.bss
 	.local save_ptr
 	ASM_TYPE_DIRECTIVE (save_ptr, @object)
-	.size save_ptr, 8
+	.size save_ptr, LP_SIZE
 save_ptr:
-	.space 8
+	.space LP_SIZE
 
 # ifdef PIC
 #  define SAVE_PTR save_ptr(%rip)
@@ -79,13 +79,12 @@ ENTRY (BP_SYM (FUNCTION))
 
 #ifdef USE_AS_STRTOK_R
 	/* The value is stored in the third argument.  */
-	movq %rdx, %rax
-	movq %rdx, %r9		/* Save value - see def. of SAVE_PTR.  */
-	movq (%rax), %rax
+	mov %RDX_LP, %R9_LP	/* Save value - see def. of SAVE_PTR.  */
+	mov (%rdx), %RAX_LP
 #else
 	/* The value is in the local variable defined above.  But
 	   we have to take care for PIC code.  */
-	movq SAVE_PTR, %rax
+	mov SAVE_PTR, %RAX_LP
 #endif
 	movq %r8, %rdx		/* Get start of string.  */
 
@@ -194,7 +193,7 @@ L(8):	cmpq %rax, %rdx
 	cmovne %rcx, %rdx
 
 	/* Store the pointer to the next character.  */
-	movq %rdx, SAVE_PTR
+	mov %RDX_LP, SAVE_PTR
 
 L(epilogue):
 	/* Remove the stopset table.  */
@@ -205,7 +204,7 @@ L(epilogue):
 L(returnNULL):
 	xorl %eax, %eax
 	/* Store the pointer to the next character.  */
-	movq %rdx, SAVE_PTR
+	mov %RDX_LP, SAVE_PTR
 	jmp L(epilogue)
 
 END (BP_SYM (FUNCTION))
