NPTL patch from fedora.

2004-09-02  Jakub Jelinek  <jakub@redhat.com>

	* pthread_cond_destroy.c (__pthread_cond_destroy): If there are
	waiters, awake all waiters on the associated mutex.
 
2003-07-22  Jakub Jelinek  <jakub@redhat.com>

	* descr.h: Don't include lowlevellock.h, pthreaddef.h and dl-sysdep.h
	if __need_struct_pthread_size, instead define lll_lock_t.
--- glibc-20050722T0433/nptl/Makefile	11 Jul 2005 16:40:21 -0000	1.169
+++ glibc-20050722T0433-fedora/nptl/Makefile	21 Jul 2005 08:25:47 -0000	1.157.2.12
@@ -502,15 +502,19 @@ $(addprefix $(objpfx), \
     $(tests) $(xtests) $(test-srcs))): $(objpfx)libpthread.so \
 				       $(objpfx)libpthread_nonshared.a
 $(objpfx)tst-unload: $(common-objpfx)dlfcn/libdl.so
-# $(objpfx)../libc.so is used instead of $(common-objpfx)libc.so,
+# $(objpfx)linklibc.so is used instead of $(common-objpfx)libc.so,
 # since otherwise libpthread.so comes before libc.so when linking.
 $(addprefix $(objpfx), $(tests-reverse)): \
-  $(objpfx)../libc.so $(objpfx)libpthread.so \
+  $(objpfx)linklibc.so $(objpfx)libpthread.so \
   $(objpfx)libpthread_nonshared.a
 $(objpfx)../libc.so: $(common-objpfx)libc.so ;
 $(addprefix $(objpfx),$(tests-static) $(xtests-static)): $(objpfx)libpthread.a
 
 $(objpfx)tst-atfork2.out: $(objpfx)tst-atfork2mod.so
+
+$(objpfx)linklibc.so: $(common-objpfx)libc.so
+	ln -s ../libc.so $@
+generated += libclink.so
 else
 $(addprefix $(objpfx),$(tests) $(test-srcs)): $(objpfx)libpthread.a
 endif
--- glibc-20050722T0433/nptl/pthread_cond_destroy.c	2 Sep 2004 18:45:37 -0000	1.5
+++ glibc-20050722T0433-fedora/nptl/pthread_cond_destroy.c	22 Sep 2004 21:21:01 -0000	1.5.2.1
@@ -44,15 +44,35 @@ __pthread_cond_destroy (cond)
      broadcasted, but still are using the pthread_cond_t structure,
      pthread_cond_destroy needs to wait for them.  */
   unsigned int nwaiters = cond->__data.__nwaiters;
-  while (nwaiters >= (1 << COND_CLOCK_BITS))
+
+  if (nwaiters >= (1 << COND_CLOCK_BITS))
     {
-      lll_mutex_unlock (cond->__data.__lock);
+      /* Wake everybody on the associated mutex in case there are
+         threads that have been requeued to it.
+         Without this, pthread_cond_destroy could block potentially
+         for a long time or forever, as it would depend on other
+         thread's using the mutex.
+         When all threads waiting on the mutex are woken up, pthread_cond_wait
+         only waits for threads to acquire and release the internal
+         condvar lock.  */
+      if (cond->__data.__mutex != NULL
+	  && cond->__data.__mutex != (void *) ~0l)
+	{
+	  pthread_mutex_t *mut = (pthread_mutex_t *) cond->__data.__mutex;
+	  lll_futex_wake (&mut->__data.__lock, INT_MAX);
+	}
+
+      do
+	{
+	  lll_mutex_unlock (cond->__data.__lock);
 
-      lll_futex_wait (&cond->__data.__nwaiters, nwaiters);
+	  lll_futex_wait (&cond->__data.__nwaiters, nwaiters);
 
-      lll_mutex_lock (cond->__data.__lock);
+	  lll_mutex_lock (cond->__data.__lock);
 
-      nwaiters = cond->__data.__nwaiters;
+	  nwaiters = cond->__data.__nwaiters;
+	}
+      while (nwaiters >= (1 << COND_CLOCK_BITS));
     }
 
   return 0;
--- glibc-20050722T0433/nptl/sysdeps/unix/sysv/linux/kernel-features.h 1 Jan 1970 00:00:00 -0000
+++ glibc-20050722T0433-fedora/nptl/sysdeps/unix/sysv/linux/kernel-features.h	22 Sep 2004 21:21:02 -0000	1.1.2.1
@@ -0,0 +1,6 @@
+#include_next <kernel-features.h>
+
+/* NPTL can always assume all clone thread flags work.  */
+#ifndef __ASSUME_CLONE_THREAD_FLAGS
+# define __ASSUME_CLONE_THREAD_FLAGS	1
+#endif
